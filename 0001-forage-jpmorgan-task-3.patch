From 06bf40b2be9c044087bc9b1201f6b414b2a87e9b Mon Sep 17 00:00:00 2001
From: ri1n <hfchin118@gmail.com>
Date: Mon, 2 Sep 2024 18:21:38 +0100
Subject: [PATCH] forage jpmorgan task 3

---
 .../__pycache__/six.cpython-312.pyc           |  Bin 0 -> 41261 bytes
 Lib/site-packages/dateutil/__init__.py        |   24 +
 .../__pycache__/__init__.cpython-312.pyc      |  Bin 0 -> 1130 bytes
 .../__pycache__/_common.cpython-312.pyc       |  Bin 0 -> 1927 bytes
 .../__pycache__/_version.cpython-312.pyc      |  Bin 0 -> 306 bytes
 .../__pycache__/easter.cpython-312.pyc        |  Bin 0 -> 2850 bytes
 .../__pycache__/relativedelta.cpython-312.pyc |  Bin 0 -> 28363 bytes
 .../__pycache__/rrule.cpython-312.pyc         |  Bin 0 -> 69223 bytes
 .../__pycache__/tzwin.cpython-312.pyc         |  Bin 0 -> 209 bytes
 .../__pycache__/utils.cpython-312.pyc         |  Bin 0 -> 2562 bytes
 Lib/site-packages/dateutil/_common.py         |   43 +
 Lib/site-packages/dateutil/_version.py        |    4 +
 Lib/site-packages/dateutil/easter.py          |   89 +
 Lib/site-packages/dateutil/parser/__init__.py |   61 +
 .../__pycache__/__init__.cpython-312.pyc      |  Bin 0 -> 2656 bytes
 .../__pycache__/_parser.cpython-312.pyc       |  Bin 0 -> 61849 bytes
 .../__pycache__/isoparser.cpython-312.pyc     |  Bin 0 -> 15582 bytes
 Lib/site-packages/dateutil/parser/_parser.py  | 1613 ++++++++++++++
 .../dateutil/parser/isoparser.py              |  416 ++++
 Lib/site-packages/dateutil/relativedelta.py   |  599 ++++++
 Lib/site-packages/dateutil/rrule.py           | 1737 ++++++++++++++++
 Lib/site-packages/dateutil/tz/__init__.py     |   12 +
 .../tz/__pycache__/__init__.cpython-312.pyc   |  Bin 0 -> 709 bytes
 .../tz/__pycache__/_common.cpython-312.pyc    |  Bin 0 -> 14162 bytes
 .../tz/__pycache__/_factories.cpython-312.pyc |  Bin 0 -> 4595 bytes
 .../tz/__pycache__/tz.cpython-312.pyc         |  Bin 0 -> 66009 bytes
 .../tz/__pycache__/win.cpython-312.pyc        |  Bin 0 -> 17265 bytes
 Lib/site-packages/dateutil/tz/_common.py      |  419 ++++
 Lib/site-packages/dateutil/tz/_factories.py   |   80 +
 Lib/site-packages/dateutil/tz/tz.py           | 1849 +++++++++++++++++
 Lib/site-packages/dateutil/tz/win.py          |  370 ++++
 Lib/site-packages/dateutil/tzwin.py           |    2 +
 Lib/site-packages/dateutil/utils.py           |   71 +
 .../dateutil/zoneinfo/__init__.py             |  167 ++
 .../__pycache__/__init__.cpython-312.pyc      |  Bin 0 -> 7432 bytes
 .../__pycache__/rebuild.cpython-312.pyc       |  Bin 0 -> 3958 bytes
 .../zoneinfo/dateutil-zoneinfo.tar.gz         |  Bin 0 -> 156400 bytes
 .../dateutil/zoneinfo/rebuild.py              |   75 +
 .../INSTALLER                                 |    1 +
 .../LICENSE                                   |   54 +
 .../METADATA                                  |  204 ++
 .../RECORD                                    |   45 +
 .../REQUESTED                                 |    0
 .../WHEEL                                     |    6 +
 .../top_level.txt                             |    1 +
 .../zip-safe                                  |    1 +
 .../six-1.16.0.dist-info/INSTALLER            |    1 +
 .../six-1.16.0.dist-info/LICENSE              |   18 +
 .../six-1.16.0.dist-info/METADATA             |   49 +
 Lib/site-packages/six-1.16.0.dist-info/RECORD |    8 +
 Lib/site-packages/six-1.16.0.dist-info/WHEEL  |    6 +
 .../six-1.16.0.dist-info/top_level.txt        |    1 +
 Lib/site-packages/six.py                      |  998 +++++++++
 src/DataManipulator.ts                        |   32 +-
 src/Graph.tsx                                 |   29 +-
 55 files changed, 9063 insertions(+), 22 deletions(-)
 create mode 100644 Lib/site-packages/__pycache__/six.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__init__.py
 create mode 100644 Lib/site-packages/dateutil/__pycache__/__init__.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__pycache__/_common.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__pycache__/_version.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__pycache__/easter.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__pycache__/relativedelta.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__pycache__/rrule.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__pycache__/tzwin.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/__pycache__/utils.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/_common.py
 create mode 100644 Lib/site-packages/dateutil/_version.py
 create mode 100644 Lib/site-packages/dateutil/easter.py
 create mode 100644 Lib/site-packages/dateutil/parser/__init__.py
 create mode 100644 Lib/site-packages/dateutil/parser/__pycache__/__init__.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/parser/__pycache__/_parser.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/parser/__pycache__/isoparser.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/parser/_parser.py
 create mode 100644 Lib/site-packages/dateutil/parser/isoparser.py
 create mode 100644 Lib/site-packages/dateutil/relativedelta.py
 create mode 100644 Lib/site-packages/dateutil/rrule.py
 create mode 100644 Lib/site-packages/dateutil/tz/__init__.py
 create mode 100644 Lib/site-packages/dateutil/tz/__pycache__/__init__.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/tz/__pycache__/_common.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/tz/__pycache__/_factories.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/tz/__pycache__/tz.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/tz/__pycache__/win.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/tz/_common.py
 create mode 100644 Lib/site-packages/dateutil/tz/_factories.py
 create mode 100644 Lib/site-packages/dateutil/tz/tz.py
 create mode 100644 Lib/site-packages/dateutil/tz/win.py
 create mode 100644 Lib/site-packages/dateutil/tzwin.py
 create mode 100644 Lib/site-packages/dateutil/utils.py
 create mode 100644 Lib/site-packages/dateutil/zoneinfo/__init__.py
 create mode 100644 Lib/site-packages/dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc
 create mode 100644 Lib/site-packages/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz
 create mode 100644 Lib/site-packages/dateutil/zoneinfo/rebuild.py
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/INSTALLER
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/LICENSE
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/METADATA
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/RECORD
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/REQUESTED
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/WHEEL
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/top_level.txt
 create mode 100644 Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/zip-safe
 create mode 100644 Lib/site-packages/six-1.16.0.dist-info/INSTALLER
 create mode 100644 Lib/site-packages/six-1.16.0.dist-info/LICENSE
 create mode 100644 Lib/site-packages/six-1.16.0.dist-info/METADATA
 create mode 100644 Lib/site-packages/six-1.16.0.dist-info/RECORD
 create mode 100644 Lib/site-packages/six-1.16.0.dist-info/WHEEL
 create mode 100644 Lib/site-packages/six-1.16.0.dist-info/top_level.txt
 create mode 100644 Lib/site-packages/six.py

diff --git a/Lib/site-packages/__pycache__/six.cpython-312.pyc b/Lib/site-packages/__pycache__/six.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..140fb48462cb81333ed02e108183ee2ae69595c9
GIT binary patch
literal 41261
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

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__init__.py b/Lib/site-packages/dateutil/__init__.py
new file mode 100644
index 0000000..a2c19c0
--- /dev/null
+++ b/Lib/site-packages/dateutil/__init__.py
@@ -0,0 +1,24 @@
+# -*- coding: utf-8 -*-
+import sys
+
+try:
+    from ._version import version as __version__
+except ImportError:
+    __version__ = 'unknown'
+
+__all__ = ['easter', 'parser', 'relativedelta', 'rrule', 'tz',
+           'utils', 'zoneinfo']
+
+def __getattr__(name):
+    import importlib
+
+    if name in __all__:
+        return importlib.import_module("." + name, __name__)
+    raise AttributeError(
+        "module {!r} has not attribute {!r}".format(__name__, name)
+    )
+
+
+def __dir__():
+    # __dir__ should include all the lazy-importable modules as well.
+    return [x for x in globals() if x not in sys.modules] + __all__
diff --git a/Lib/site-packages/dateutil/__pycache__/__init__.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..ce4d2100f8ae8496ce11c312b241876bce150ceb
GIT binary patch
literal 1130
zcmYjQ&ubJ{9RI$V*_lbE>52^|!637ZNC#Xi>?KMl4T-2!a*0K{t_+i%$!3z-ndQBg
zY_i?ZG!zdK(b7Y%Q4o|Adhy_)|ACkMpfyY@2udNhkiFEL{Jz;8;}_od*L;7y_x;Sv
zo}O+%vi|#PI*<U~3L_<@qqMG}vJNh|B!D7xfh)OkK&nzvCQt!4^OzJfuKEiURaZl<
zEs-Jcl(RrH1YD&k{{U;fby!4MCzif1%1-PP<Q9pw1&=a63S(_PoC~9RXlb$PIgEQW
zR%;GrD0`?EINV?GTrc2GoS}3+@M4KK;><kv0~YIzDD?brIx35*DXFN)cv|<6;rzsf
z0G3G;INr2P3qS{&WHyu9$I_LW&_I)mDhX|NvL=Cdr9M}lHB$Xp9_KV6&D!itwn{8z
zf{Ic{<U-@iYUJWw%pY@f*_?5h8AjZ6IH&&9Ja4-#HSY4OwTSY-pNcixc7njR<DRz9
zZWoAk+YX(ohaWy4P1CPX8sQ^ON3`m2ONtc{L9^JJiT<W}bZhK#>3e)(R+^bE&-f(_
zbt;}&_ZB;9ezsOE=ULs$bBE343#A+WREhcA%h#Op9LBPe>u^tO;cMIWL!aCBh1ybV
z*mlL^;v%+9`>@$(qU*QFR^T6{_l;(()qnnJFWdhrdu}^>Zi79&`Ka-HcsDz;rH}mE
z-M^=wf29|;^}_ROFWg;ytR+i^dH_;JZD9>43zm{tUb5yID(k>MLSVBKF%A!)ELHH_
z!BLjsQvl4SAWy5ITp*0Bood3b(%OK6S<9b*KtN&=eI)VM5y2Cd5^I$pnsN|`GFxJ?
z*4_!DComWxP8OM%$)u-{iw(NIc$PD02@m@U*$TYtJM-Jp-^QhfxsB1^C;zzp?Do#t
z;d`Sy#-%^6ZX07;%Gi6<nU2Bt`wGevrJz_kJ&h(Vzw;AOaU1dY9UI|bTu-o*U?CYO
zSx3_R8PI-=PsTdZN7_?=Lx<2O=4Hdk4rD^eTj)MeWHR_#xp=4(!(7o0RgI{vUWts8
k{||DYe{l$e4DOvgz51QV7(8NP;dj+OSl4p$2Fb}E0GOE-(*OVf

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__pycache__/_common.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/_common.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..a6c681637ac6b42b5d84c7511b3d4c0bc95244ce
GIT binary patch
literal 1927
zcmZ`)O-vhC5Pt9NuKzG#YFeO;(3YPN^Ou%XL`o|pN=T{NP^pAgv8=Al?m8I!L-wsh
zOpSyp4kk*Kaxy)YNRcAMg`8+lRnNVURF&LS50NVM?BZ0aICW;%nAmln<k@-i^XAR>
zX2w4^H~R>z(4W7?9tni}ft%AMRhV)&Fa@HKFk$2aqR~yFF`e#%J+3gz3L$ZAz&Djn
zCetZdO>4TG;kqWrQ*ttsFyku;T~4O8OhV_QKGpGZD64GBSAZ!HorEcbVHyOv#lnK-
z)r3tN7Bz8`ge6S^>e5_5-I^PyNAm#nW?9H*xmR_4S&L>ZnwnKBH?t4N5V$YPKnf&B
zb3_5oSvdwfdb-P!JvzI`3^X@HAR)mLxt@rfNjU0cSw8t}>Plpu>jsZ3#?-}lB$hU!
zw{&?`zguBPmR6GL2w&Al%qU+TxfJ<0z7XMYQy*E0s>@)@BU;qdGiE$-QBiH^Mpv?y
zM^WObxTz>>fl5ZBrxGuO<^doZq}b7&7w`LvZLj3TuU%!35%m;H+~DQyq$9vMNiU(i
zZY^JcL;-?1k|RrKU$;PtC)KSS-LJ%&BZdo<A;Ct=@+yj&h;ptdHeexUctC6GIC{vk
zfjMA~YBZ6k&C!uGgPsonfgGFs--rd*w(H)z#b8JNqvyen!o>E(Zr|hKhr<W-m*Ciu
zf6QnC+s3Ki2Tg%^F*V@oSB^H4E?<W5UEuLDm=#y>Xdp!ogJ!9hWLYmUt8n!ZL!jg)
z$<kGFSGY-5X-Js8b_1ZQR+rT>X_`iSA!F*(hLJX)@(?deN}G#NST7^yQWX6*;MH<g
z6Sxn8IiCTtK}t;Yb`@KL4{}?%oy>RZ->yGv9X=2bT~A!!_y0KX!@#q*CW{^CN&<QN
zeOmI6K>I&0BogR8Ce+*YTd=bv!1si=!eL*HT_%U#NkRCDQJ`wIKR}21*@bl#m;y1Y
zy8pqfVFAV1e#Ng^K$f@|<%?(7gs6=LN4vACL7UpDaU^em74HGEL4I!y7JV%bhPQ_C
zbAIc5NfKW5m5C5&DiOik^xuL(ob8lafPr3t5rKW-hpw=zdyg1xcz)e`r1aYN!2O$O
zhY&*bws-DKZ(l!Z?K$%FI6<pefdK}zgMI-F%vP96jq0%rwCkwD;B||$9G!znj1#Sq
zKE~FdIp?4|XG3m_UH`;lH|8z&`80fIEOzZvi_J~KZ+^|)&oA^3X(7W6Au3&KQC^cV
z^sJ$;7`5m-l0NX_7lA<5{_z9zF!v<))PFTku^jK*yHgCd=VzV=&+XFPcOH*F9N+o!
zX>jn!KWL-k3=kjAgj6&M7+O9>asDiT_bbZnOf*r^z<l9}w2AY@2jL8SFavwQcnt}H
zW%MHHM1qsSo;OZaA=)^s_#lu?QfzyDXX+>*Z+uu5nG`(sh|;BFze{RA4v13Iv7bu4
zWtSukIme*$Ec_d|6-7&{a4}bUVM$j_=jhsSC!Y75`%f4c3SXV${h-4r{fjXwzVP+Z
Np?vIb0w4SQe*p#RgSY?y

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__pycache__/_version.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/_version.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..77ab59b77c26d79e92f6ee098ca766876533ed5c
GIT binary patch
literal 306
zcmX@j%ge<81e(vTrY!@~k3k$5V1hC}ivStZ8B!Q37^4`X7*iO5G*c9FC6gv|6}OR|
zrJjLaL4I+GfhO}ykd~L6AOfV<Pm|>qcYJ(VYEf}!eqMb1Ep{mLmLNj3q_iL>6)49G
zQwA1T$?zFu!mn^=tC-MYpaC%%X~`LxF=_cliRq~d<*5}=rfyb2ZnAE1d8%$nVsW;v
zag0x9QcQ7XNvdu^VsbW6ZE;LWVo7RgNoI~d%q4mSmA^P_a`RJ4b5iY!c!2gW0&%en
kkodsN$jJDCjX_fF0)uJ;cSrgS72OLAKqNTPw+Iwe0D-exH2?qr

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__pycache__/easter.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/easter.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..4189b1f6db8689edbc3e9e0a05b1e49602de384d
GIT binary patch
literal 2850
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
E2Zja_ivR!s

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__pycache__/relativedelta.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/relativedelta.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..9d17c15124442d1f53876e83f5f9e8506ad619a2
GIT binary patch
literal 28363
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

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__pycache__/rrule.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/rrule.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..b76014bff6108cf688c154899c263fca5ac50057
GIT binary patch
literal 69223
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
E0eA~y{Qv*}

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__pycache__/tzwin.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/tzwin.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..a83d8594ff4d9fe09b4f8821c5f667bd538d5d8f
GIT binary patch
literal 209
zcmX@j%ge<81e(vTrdb2&#~=<2FhLog`GAb+3@HpLj5!QznHU)=nKYSSG6DrP8E-La
z`2k6`k}AFO%)FHhpFw(lg*aQqgche36~|<xC1+&Dq~#YSrl%^Dr&d6jx>*Ie$-2em
zsk$YJ#o4;XF+Q0|F~ylBsk#M;$=N`)#W5*~C8?z)nK}9;RX~&V3Mzkb*yQG?l;)(`
a6>$J90oh*+Vtim`WMq8GAX>x*<NyFh^EkZ#

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/__pycache__/utils.cpython-312.pyc b/Lib/site-packages/dateutil/__pycache__/utils.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..a9cd69f8643d5a2c8392a92055cdfbc76528c2ab
GIT binary patch
literal 2562
zcmbVO&2Jk;6yIIjv12DqQxKxGMWcdLuc(caQm9rm(3VnBp&m$ju_D>yomqR*^{&|&
z$Fb!~sZ@y;4h^S*IM726R4Eew2bWakqgru5LIQCs1TH=CX1r_1QK%3j?|44my!YnK
z@BL=Jou1BWP|RPycfL+*+Ap#b7b9wHpMu71jc8?!=)`dKrcpL@*-p5LW}=*ECd*0a
zXGrS0UQUsT>son&q@hlCljdZPXO|j`qoz;VE=9iM(14>l^=N=yWc%JK^%(VRim*pe
zTQHZ2E^^wQEtv0d<oE$16uZo;qYe{|EWv^b)}*|c%@&Jj71V(sCWI2pLi5EpilyxD
z(sxr2_qRP}`-E0NskFyUBh17K!lYDl$=0Kd%0CE#mVj^jW2kOxVmP-FhXcmr($_Yl
z`K$U4$z(h~`tR#2QuD5|8TG|vJVErncHh{HY{mbJnwh{af~hQm@&Og?00M)N)#_Td
zi#fNd@t&$Epsj#%>IoSz(V)m~2LW^u!Ciy}YBJ)ndP8KDGOL9H+(e?sJjb`xkhHM`
z>tt|H&-b9^!$N`W2FgPSebnZZ$U#COs7)p%#_gDJG*XQfC|^f<&+O%Mapb&TTcNgi
z>K=wZ?$}FF4F)o7_w;aLup2WK$dd>Yp5F=6w%@FQr(seW3sNv)8bL<R8$@uq5}_wc
z=d9(+900Z4aO?(K2JGQFMIE{pH47`Prd{A2S`e6DDV$h-pVgK*V5`u=_7#xj%Tm8Y
z@vE}p#a1^=2_Iq~>;oIq@bP)5*0sN$*Rlt09lm*Z!+AJ)Wc}<<xo3XN9eR*E^x4@j
zFMNLCi}&t|ug-kqe0S{h!`#AFa$y@*Y4%PON}MXJo`uG3t*@;}kzM7Q(bpE`oRr*E
z`ucr+GeR(6%)oa+NQH8d3a$>dS{($lT15&e^2CwvArG@v3XqCY5r*9E;LKIBL%st@
zoVKgdm#*Pv3v$2HpdRY_ZG;1gT7kdHAZHOCssW4gPywe6yh@cL6fzzxVh=G;!E7cF
z@Bv+m+Cz*UN4yRA#C%``eB~1Vc!Xl5j*9?>BXk0J5Z@M*3(Fe#E-|~Xuz;MvZz`|k
z85TuP8utSMX#(`csZhH17M7O5;b?*CJw;k!Bo-#r!EIMm1`!`yMI1GbP7htkA3eXg
zbo4kX%$+KgO6Hh!3pOe8<LdItmHe^!(%fr>(j5HI+`M(7gf1_gJ7yk7kp*+4X}6?R
zD!o!FLH)mN{bxIc(n)DY8HyN+h!KlOc8Z}V!PsdqIC~%@;64|_O(N-N2#ql{dlB6p
zGzw=f39$;Oswsv=%;N&fTS}54=dA8QYZ!@Yl?X@?<^V&&Ehe)8Iwk_RLMo_a`8P@&
z(z%ClM<&Kz?!>#TMocF!lbFBK(XOFC1;dKeB0>u!--P?dkq{h!!6WeTm!VqM9$Q)_
z`%(8=cPoAP(ah|P$)9ItZ}o2W?mTy+_i!e^mB|M)AZYI-5ZRXB_B&ARye9j`W_%?A
z@$~f`yf3aM`bJLcCv0QQxblLgt?5BZ*ZQix2$ZG+L795bQ_%$ajcEfY8$heBu?}1|
zL#`QP2}p5|)?HR-HDDOR<nuzlCX_Nbs~TK@@QeVa34m+phi&W*VhFE;1g>#2877FB
zlhu5fBGeT)%#PIXBy3P-`XH23@&&@YijoTs!ra^N@gh{f=vi%g|3>PQi|gkf%|5%q
zKRvj9@zK=mjn_BIKjiXvPCm%xx03lmtwL(*m&{C<u2g`ADwQx>sW@%8+i9f|$l$8$
zOI=m!?oj8ZY~It<a^=#K%$tLk)j}Z8R0f|Ph3aua*Y!V=DLwi3l&0r@(_Y%1nAYF=
P6CvH)epgTHrqb~b#)7h%

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/_common.py b/Lib/site-packages/dateutil/_common.py
new file mode 100644
index 0000000..4eb2659
--- /dev/null
+++ b/Lib/site-packages/dateutil/_common.py
@@ -0,0 +1,43 @@
+"""
+Common code used in multiple modules.
+"""
+
+
+class weekday(object):
+    __slots__ = ["weekday", "n"]
+
+    def __init__(self, weekday, n=None):
+        self.weekday = weekday
+        self.n = n
+
+    def __call__(self, n):
+        if n == self.n:
+            return self
+        else:
+            return self.__class__(self.weekday, n)
+
+    def __eq__(self, other):
+        try:
+            if self.weekday != other.weekday or self.n != other.n:
+                return False
+        except AttributeError:
+            return False
+        return True
+
+    def __hash__(self):
+        return hash((
+          self.weekday,
+          self.n,
+        ))
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
+        if not self.n:
+            return s
+        else:
+            return "%s(%+d)" % (s, self.n)
+
+# vim:ts=4:sw=4:et
diff --git a/Lib/site-packages/dateutil/_version.py b/Lib/site-packages/dateutil/_version.py
new file mode 100644
index 0000000..ddda980
--- /dev/null
+++ b/Lib/site-packages/dateutil/_version.py
@@ -0,0 +1,4 @@
+# file generated by setuptools_scm
+# don't change, don't track in version control
+__version__ = version = '2.9.0.post0'
+__version_tuple__ = version_tuple = (2, 9, 0)
diff --git a/Lib/site-packages/dateutil/easter.py b/Lib/site-packages/dateutil/easter.py
new file mode 100644
index 0000000..f74d1f7
--- /dev/null
+++ b/Lib/site-packages/dateutil/easter.py
@@ -0,0 +1,89 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a generic Easter computing method for any given year, using
+Western, Orthodox or Julian algorithms.
+"""
+
+import datetime
+
+__all__ = ["easter", "EASTER_JULIAN", "EASTER_ORTHODOX", "EASTER_WESTERN"]
+
+EASTER_JULIAN = 1
+EASTER_ORTHODOX = 2
+EASTER_WESTERN = 3
+
+
+def easter(year, method=EASTER_WESTERN):
+    """
+    This method was ported from the work done by GM Arts,
+    on top of the algorithm by Claus Tondering, which was
+    based in part on the algorithm of Ouding (1940), as
+    quoted in "Explanatory Supplement to the Astronomical
+    Almanac", P.  Kenneth Seidelmann, editor.
+
+    This algorithm implements three different Easter
+    calculation methods:
+
+    1. Original calculation in Julian calendar, valid in
+       dates after 326 AD
+    2. Original method, with date converted to Gregorian
+       calendar, valid in years 1583 to 4099
+    3. Revised method, in Gregorian calendar, valid in
+       years 1583 to 4099 as well
+
+    These methods are represented by the constants:
+
+    * ``EASTER_JULIAN   = 1``
+    * ``EASTER_ORTHODOX = 2``
+    * ``EASTER_WESTERN  = 3``
+
+    The default method is method 3.
+
+    More about the algorithm may be found at:
+
+    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_
+
+    and
+
+    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_
+
+    """
+
+    if not (1 <= method <= 3):
+        raise ValueError("invalid method")
+
+    # g - Golden year - 1
+    # c - Century
+    # h - (23 - Epact) mod 30
+    # i - Number of days from March 21 to Paschal Full Moon
+    # j - Weekday for PFM (0=Sunday, etc)
+    # p - Number of days from March 21 to Sunday on or before PFM
+    #     (-6 to 28 methods 1 & 3, to 56 for method 2)
+    # e - Extra days to add for method 2 (converting Julian
+    #     date to Gregorian date)
+
+    y = year
+    g = y % 19
+    e = 0
+    if method < 3:
+        # Old method
+        i = (19*g + 15) % 30
+        j = (y + y//4 + i) % 7
+        if method == 2:
+            # Extra dates to convert Julian to Gregorian date
+            e = 10
+            if y > 1600:
+                e = e + y//100 - 16 - (y//100 - 16)//4
+    else:
+        # New method
+        c = y//100
+        h = (c - c//4 - (8*c + 13)//25 + 19*g + 15) % 30
+        i = h - (h//28)*(1 - (h//28)*(29//(h + 1))*((21 - g)//11))
+        j = (y + y//4 + i + 2 - c + c//4) % 7
+
+    # p can be from -6 to 56 corresponding to dates 22 March to 23 May
+    # (later dates apply to method 2, although 23 May never actually occurs)
+    p = i - j + e
+    d = 1 + (p + 27 + (p + 6)//40) % 31
+    m = 3 + (p + 26)//30
+    return datetime.date(int(y), int(m), int(d))
diff --git a/Lib/site-packages/dateutil/parser/__init__.py b/Lib/site-packages/dateutil/parser/__init__.py
new file mode 100644
index 0000000..d174b0e
--- /dev/null
+++ b/Lib/site-packages/dateutil/parser/__init__.py
@@ -0,0 +1,61 @@
+# -*- coding: utf-8 -*-
+from ._parser import parse, parser, parserinfo, ParserError
+from ._parser import DEFAULTPARSER, DEFAULTTZPARSER
+from ._parser import UnknownTimezoneWarning
+
+from ._parser import __doc__
+
+from .isoparser import isoparser, isoparse
+
+__all__ = ['parse', 'parser', 'parserinfo',
+           'isoparse', 'isoparser',
+           'ParserError',
+           'UnknownTimezoneWarning']
+
+
+###
+# Deprecate portions of the private interface so that downstream code that
+# is improperly relying on it is given *some* notice.
+
+
+def __deprecated_private_func(f):
+    from functools import wraps
+    import warnings
+
+    msg = ('{name} is a private function and may break without warning, '
+           'it will be moved and or renamed in future versions.')
+    msg = msg.format(name=f.__name__)
+
+    @wraps(f)
+    def deprecated_func(*args, **kwargs):
+        warnings.warn(msg, DeprecationWarning)
+        return f(*args, **kwargs)
+
+    return deprecated_func
+
+def __deprecate_private_class(c):
+    import warnings
+
+    msg = ('{name} is a private class and may break without warning, '
+           'it will be moved and or renamed in future versions.')
+    msg = msg.format(name=c.__name__)
+
+    class private_class(c):
+        __doc__ = c.__doc__
+
+        def __init__(self, *args, **kwargs):
+            warnings.warn(msg, DeprecationWarning)
+            super(private_class, self).__init__(*args, **kwargs)
+
+    private_class.__name__ = c.__name__
+
+    return private_class
+
+
+from ._parser import _timelex, _resultbase
+from ._parser import _tzparser, _parsetz
+
+_timelex = __deprecate_private_class(_timelex)
+_tzparser = __deprecate_private_class(_tzparser)
+_resultbase = __deprecate_private_class(_resultbase)
+_parsetz = __deprecated_private_func(_parsetz)
diff --git a/Lib/site-packages/dateutil/parser/__pycache__/__init__.cpython-312.pyc b/Lib/site-packages/dateutil/parser/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..809cdc529e3a998834382ac7b83becd2c8e61d31
GIT binary patch
literal 2656
zcmb_e-ES0C6u);qc4xo0P%BWRQ{=-fcFTu}Q3z>+Xkvg6J_4CE4%404GVRQ6y)#Q`
zEy)_2bhn9uiG=b5F+ND(fk*!Y6JJVN6FW+P7$Lk>szK|E=iJ>bZBt`Ryvdw<&b{Z}
zIp^H-JNJH<NJI&=%;WF#k3)p~j6$P{b!OpPV6G99nA9OI)u=0If-7pGD`^tNaRJ6<
zO?E?Ch|40#VJ*yg33x?QI4?U9H=;${s1~K9pO~R9sTMQC<3x*_3eW`X6#@OEmUL5E
zim!=+oYvBAlh#CuK&*t7yiIGCX-O`pm*g~;Q%iCR<ha$eBsY!3GV!OlIwJ-0kik4F
z2=R^u(OPd8^2H!_9H-b}#)>Q>1c`SJzuR;A$f@H!Cr%zd5v1zkDXlh;p+U>(!eF5|
zTsURB)@ZR{oiSL!F7(4pSl7*BPS;_Zi0u{YKT{fPCd@F*OhO_fi6e<2f%70N0wh=W
z7g$126PGNMflQDIaYBN#q5KT!B?>X4CUJyG$rLBWsyGk^wN<T329#ApAl{K0ahenb
zGDfSUAy-I6tVns$l*g6Z^@W#&G2tZ1gpNJM0dQ0vX2y^=TKuSBxYi}r_EbY1V)g~Y
zx72*8kn`<gK{X1d>KY?zAG3@>b=daL7fZf6T#MH0stvsDIBK7zy2T5Y$@Pm&WfpE~
zs&)ak@=MH8FIdcj4ZZ9w8b~;qtJ}pp3}hR83*A7jiq}Y08dx4f7{yi<eWAt?a=Xr9
zj#Y&*VnYPJqMy-|<Q6>!hbN(t!Mb;>A!g+abf$5}av&M3-wQ&6paMP32cqls2TI*7
z&qH%mwOlSQesJjR-qVm-UhnyQ?!4WbFEXRwQirXJb+&V0$jx<n!&awnc!Qn$dXLzB
zy`Jq`okK=$5Olp>6CzsjZKtc2OI^Bd7i?eGvqK|6%B<UGnK}l2bT6dei=p~?@Tu$p
zr<gMw?_hSB0<L)lto616`J+r8D(TCKYT`<6wzYFs$<C$HSGG;3+NXBhOSMlc?F$&a
zj2uMx0T+vo$5JrDHUSAj;GAptfuiepKmY-mZNOQsvKhIJ4P_ppbE?|i&02Bo#(y-M
zwZr^N@Og)TESAZAsqIH;{k%luJ+yr2VKi~MquMdmexu`hN2OyXy1jhpksPh;`Q+^H
zf*@~Q5J@OGkKDXM;;qxtCWij5Kp5hVBkT)c0AX}On1CGOxFVCHDNNET9YBp$4RD3%
zT-EM~4IE8UfxJfmO|&9Z#Jprm<BBN*&gy$j3Ty9B74)S%t=3S-lJJ*NXDzVh9K!?f
z{qIO)Y4~MsxpNI?YcP{0;F7S22IWT+&XBuw00X(IX(G4}&O<qoOggS;QiWWknhd2x
zSlqqr)b&QLa(7-N>x$tO$F>Ce<M7X`P!y}7H9;?}1$rM>^H!C|$fpq9F$yI>z!E^o
z2x04CG9$5O=oqG7AbX`Di(z)x;Fk#pl4m)2)`BW8qe?{Ax%IlvGd)PGFrK5t!}6^1
z;!x(P&vwGV=v)6a64{0sSy=Av00QX!A>MrXX!YpStFvu;X5)K*iZ@;9yxDv&-gUQm
zI^O+F%S^nRXMZNdR9F#2b=@tRB?qt?#C83{lHt^l%kYuFEejHLpK_Mta7brxCC$~a
z+<|(Ceh%nvD0y|S_{27t*oBi=2L2o;bL-Y$%Y2@xgr7@7q=zmLq}(Eg`WcaL#juid
z10nwC-s)dr8lLN3t8}bPBGv_pXoL4YkiW|0U+TtlNtS!)uLS87{f+nYNwTHwhIU;m
zADxvpJ&bLbmNwL4C_pOsaQ!>h#UQ3L%PTp4pW#_}@$3F*<Kovj<BuN8tb?~fZFKb$
zfM5KW7!0pz{sgF<0Dl(X0|B2E1|9$}hukr?8+G>}*^6W!kXxh{O{}Sl%7NP99%OHV
zh}WTa7RbCvDSblr&yf8O$iDkz*DqxA6VmZa5@XxT;b$!g+WKrunr?i)gV0?M$ZL;c
n+isqniDk>mTzvaYdnUfS9GOe*{5m$1e4`wjtIvL{@IU_z`DKmo

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/parser/__pycache__/_parser.cpython-312.pyc b/Lib/site-packages/dateutil/parser/__pycache__/_parser.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..899ee2875b5f5ca02ab9769fa49e9d431e3cefd6
GIT binary patch
literal 61849
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
SPKhc#Zw^2EfWwJ(@BaWqVH@%Q

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/parser/__pycache__/isoparser.cpython-312.pyc b/Lib/site-packages/dateutil/parser/__pycache__/isoparser.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..40414dcbe8a72c06443f9e087a408794eddb4247
GIT binary patch
literal 15582
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
N&Wva058bTa{{wt#PV)c&

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/parser/_parser.py b/Lib/site-packages/dateutil/parser/_parser.py
new file mode 100644
index 0000000..37d1663
--- /dev/null
+++ b/Lib/site-packages/dateutil/parser/_parser.py
@@ -0,0 +1,1613 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a generic date/time string parser which is able to parse
+most known formats to represent a date and/or time.
+
+This module attempts to be forgiving with regards to unlikely input formats,
+returning a datetime object even for dates which are ambiguous. If an element
+of a date/time stamp is omitted, the following rules are applied:
+
+- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour
+  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is
+  specified.
+- If a time zone is omitted, a timezone-naive datetime is returned.
+
+If any other elements are missing, they are taken from the
+:class:`datetime.datetime` object passed to the parameter ``default``. If this
+results in a day number exceeding the valid number of days per month, the
+value falls back to the end of the month.
+
+Additional resources about date/time string formats can be found below:
+
+- `A summary of the international standard date and time notation
+  <https://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_
+- `W3C Date and Time Formats <https://www.w3.org/TR/NOTE-datetime>`_
+- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_
+- `CPAN ParseDate module
+  <https://metacpan.org/pod/release/MUIR/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_
+- `Java SimpleDateFormat Class
+  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_
+"""
+from __future__ import unicode_literals
+
+import datetime
+import re
+import string
+import time
+import warnings
+
+from calendar import monthrange
+from io import StringIO
+
+import six
+from six import integer_types, text_type
+
+from decimal import Decimal
+
+from warnings import warn
+
+from .. import relativedelta
+from .. import tz
+
+__all__ = ["parse", "parserinfo", "ParserError"]
+
+
+# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth
+# making public and/or figuring out if there is something we can
+# take off their plate.
+class _timelex(object):
+    # Fractional seconds are sometimes split by a comma
+    _split_decimal = re.compile("([.,])")
+
+    def __init__(self, instream):
+        if isinstance(instream, (bytes, bytearray)):
+            instream = instream.decode()
+
+        if isinstance(instream, text_type):
+            instream = StringIO(instream)
+        elif getattr(instream, 'read', None) is None:
+            raise TypeError('Parser must be a string or character stream, not '
+                            '{itype}'.format(itype=instream.__class__.__name__))
+
+        self.instream = instream
+        self.charstack = []
+        self.tokenstack = []
+        self.eof = False
+
+    def get_token(self):
+        """
+        This function breaks the time string into lexical units (tokens), which
+        can be parsed by the parser. Lexical units are demarcated by changes in
+        the character set, so any continuous string of letters is considered
+        one unit, any continuous string of numbers is considered one unit.
+
+        The main complication arises from the fact that dots ('.') can be used
+        both as separators (e.g. "Sep.20.2009") or decimal points (e.g.
+        "4:30:21.447"). As such, it is necessary to read the full context of
+        any dot-separated strings before breaking it into tokens; as such, this
+        function maintains a "token stack", for when the ambiguous context
+        demands that multiple tokens be parsed at once.
+        """
+        if self.tokenstack:
+            return self.tokenstack.pop(0)
+
+        seenletters = False
+        token = None
+        state = None
+
+        while not self.eof:
+            # We only realize that we've reached the end of a token when we
+            # find a character that's not part of the current token - since
+            # that character may be part of the next token, it's stored in the
+            # charstack.
+            if self.charstack:
+                nextchar = self.charstack.pop(0)
+            else:
+                nextchar = self.instream.read(1)
+                while nextchar == '\x00':
+                    nextchar = self.instream.read(1)
+
+            if not nextchar:
+                self.eof = True
+                break
+            elif not state:
+                # First character of the token - determines if we're starting
+                # to parse a word, a number or something else.
+                token = nextchar
+                if self.isword(nextchar):
+                    state = 'a'
+                elif self.isnum(nextchar):
+                    state = '0'
+                elif self.isspace(nextchar):
+                    token = ' '
+                    break  # emit token
+                else:
+                    break  # emit token
+            elif state == 'a':
+                # If we've already started reading a word, we keep reading
+                # letters until we find something that's not part of a word.
+                seenletters = True
+                if self.isword(nextchar):
+                    token += nextchar
+                elif nextchar == '.':
+                    token += nextchar
+                    state = 'a.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == '0':
+                # If we've already started reading a number, we keep reading
+                # numbers until we find something that doesn't fit.
+                if self.isnum(nextchar):
+                    token += nextchar
+                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):
+                    token += nextchar
+                    state = '0.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == 'a.':
+                # If we've seen some letters and a dot separator, continue
+                # parsing, and the tokens will be broken up later.
+                seenletters = True
+                if nextchar == '.' or self.isword(nextchar):
+                    token += nextchar
+                elif self.isnum(nextchar) and token[-1] == '.':
+                    token += nextchar
+                    state = '0.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == '0.':
+                # If we've seen at least one dot separator, keep going, we'll
+                # break up the tokens later.
+                if nextchar == '.' or self.isnum(nextchar):
+                    token += nextchar
+                elif self.isword(nextchar) and token[-1] == '.':
+                    token += nextchar
+                    state = 'a.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+
+        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or
+                                       token[-1] in '.,')):
+            l = self._split_decimal.split(token)
+            token = l[0]
+            for tok in l[1:]:
+                if tok:
+                    self.tokenstack.append(tok)
+
+        if state == '0.' and token.count('.') == 0:
+            token = token.replace(',', '.')
+
+        return token
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        token = self.get_token()
+        if token is None:
+            raise StopIteration
+
+        return token
+
+    def next(self):
+        return self.__next__()  # Python 2.x support
+
+    @classmethod
+    def split(cls, s):
+        return list(cls(s))
+
+    @classmethod
+    def isword(cls, nextchar):
+        """ Whether or not the next character is part of a word """
+        return nextchar.isalpha()
+
+    @classmethod
+    def isnum(cls, nextchar):
+        """ Whether the next character is part of a number """
+        return nextchar.isdigit()
+
+    @classmethod
+    def isspace(cls, nextchar):
+        """ Whether the next character is whitespace """
+        return nextchar.isspace()
+
+
+class _resultbase(object):
+
+    def __init__(self):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+
+    def _repr(self, classname):
+        l = []
+        for attr in self.__slots__:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("%s=%s" % (attr, repr(value)))
+        return "%s(%s)" % (classname, ", ".join(l))
+
+    def __len__(self):
+        return (sum(getattr(self, attr) is not None
+                    for attr in self.__slots__))
+
+    def __repr__(self):
+        return self._repr(self.__class__.__name__)
+
+
+class parserinfo(object):
+    """
+    Class which handles what inputs are accepted. Subclass this to customize
+    the language and acceptable values for each parameter.
+
+    :param dayfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+        ``yearfirst`` is set to ``True``, this distinguishes between YDM
+        and YMD. Default is ``False``.
+
+    :param yearfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the year. If ``True``, the first number is taken
+        to be the year, otherwise the last number is taken to be the year.
+        Default is ``False``.
+    """
+
+    # m from a.m/p.m, t from ISO T separator
+    JUMP = [" ", ".", ",", ";", "-", "/", "'",
+            "at", "on", "and", "ad", "m", "t", "of",
+            "st", "nd", "rd", "th"]
+
+    WEEKDAYS = [("Mon", "Monday"),
+                ("Tue", "Tuesday"),     # TODO: "Tues"
+                ("Wed", "Wednesday"),
+                ("Thu", "Thursday"),    # TODO: "Thurs"
+                ("Fri", "Friday"),
+                ("Sat", "Saturday"),
+                ("Sun", "Sunday")]
+    MONTHS = [("Jan", "January"),
+              ("Feb", "February"),      # TODO: "Febr"
+              ("Mar", "March"),
+              ("Apr", "April"),
+              ("May", "May"),
+              ("Jun", "June"),
+              ("Jul", "July"),
+              ("Aug", "August"),
+              ("Sep", "Sept", "September"),
+              ("Oct", "October"),
+              ("Nov", "November"),
+              ("Dec", "December")]
+    HMS = [("h", "hour", "hours"),
+           ("m", "minute", "minutes"),
+           ("s", "second", "seconds")]
+    AMPM = [("am", "a"),
+            ("pm", "p")]
+    UTCZONE = ["UTC", "GMT", "Z", "z"]
+    PERTAIN = ["of"]
+    TZOFFSET = {}
+    # TODO: ERA = ["AD", "BC", "CE", "BCE", "Stardate",
+    #              "Anno Domini", "Year of Our Lord"]
+
+    def __init__(self, dayfirst=False, yearfirst=False):
+        self._jump = self._convert(self.JUMP)
+        self._weekdays = self._convert(self.WEEKDAYS)
+        self._months = self._convert(self.MONTHS)
+        self._hms = self._convert(self.HMS)
+        self._ampm = self._convert(self.AMPM)
+        self._utczone = self._convert(self.UTCZONE)
+        self._pertain = self._convert(self.PERTAIN)
+
+        self.dayfirst = dayfirst
+        self.yearfirst = yearfirst
+
+        self._year = time.localtime().tm_year
+        self._century = self._year // 100 * 100
+
+    def _convert(self, lst):
+        dct = {}
+        for i, v in enumerate(lst):
+            if isinstance(v, tuple):
+                for v in v:
+                    dct[v.lower()] = i
+            else:
+                dct[v.lower()] = i
+        return dct
+
+    def jump(self, name):
+        return name.lower() in self._jump
+
+    def weekday(self, name):
+        try:
+            return self._weekdays[name.lower()]
+        except KeyError:
+            pass
+        return None
+
+    def month(self, name):
+        try:
+            return self._months[name.lower()] + 1
+        except KeyError:
+            pass
+        return None
+
+    def hms(self, name):
+        try:
+            return self._hms[name.lower()]
+        except KeyError:
+            return None
+
+    def ampm(self, name):
+        try:
+            return self._ampm[name.lower()]
+        except KeyError:
+            return None
+
+    def pertain(self, name):
+        return name.lower() in self._pertain
+
+    def utczone(self, name):
+        return name.lower() in self._utczone
+
+    def tzoffset(self, name):
+        if name in self._utczone:
+            return 0
+
+        return self.TZOFFSET.get(name)
+
+    def convertyear(self, year, century_specified=False):
+        """
+        Converts two-digit years to year within [-50, 49]
+        range of self._year (current local time)
+        """
+
+        # Function contract is that the year is always positive
+        assert year >= 0
+
+        if year < 100 and not century_specified:
+            # assume current century to start
+            year += self._century
+
+            if year >= self._year + 50:  # if too far in future
+                year -= 100
+            elif year < self._year - 50:  # if too far in past
+                year += 100
+
+        return year
+
+    def validate(self, res):
+        # move to info
+        if res.year is not None:
+            res.year = self.convertyear(res.year, res.century_specified)
+
+        if ((res.tzoffset == 0 and not res.tzname) or
+             (res.tzname == 'Z' or res.tzname == 'z')):
+            res.tzname = "UTC"
+            res.tzoffset = 0
+        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):
+            res.tzoffset = 0
+        return True
+
+
+class _ymd(list):
+    def __init__(self, *args, **kwargs):
+        super(self.__class__, self).__init__(*args, **kwargs)
+        self.century_specified = False
+        self.dstridx = None
+        self.mstridx = None
+        self.ystridx = None
+
+    @property
+    def has_year(self):
+        return self.ystridx is not None
+
+    @property
+    def has_month(self):
+        return self.mstridx is not None
+
+    @property
+    def has_day(self):
+        return self.dstridx is not None
+
+    def could_be_day(self, value):
+        if self.has_day:
+            return False
+        elif not self.has_month:
+            return 1 <= value <= 31
+        elif not self.has_year:
+            # Be permissive, assume leap year
+            month = self[self.mstridx]
+            return 1 <= value <= monthrange(2000, month)[1]
+        else:
+            month = self[self.mstridx]
+            year = self[self.ystridx]
+            return 1 <= value <= monthrange(year, month)[1]
+
+    def append(self, val, label=None):
+        if hasattr(val, '__len__'):
+            if val.isdigit() and len(val) > 2:
+                self.century_specified = True
+                if label not in [None, 'Y']:  # pragma: no cover
+                    raise ValueError(label)
+                label = 'Y'
+        elif val > 100:
+            self.century_specified = True
+            if label not in [None, 'Y']:  # pragma: no cover
+                raise ValueError(label)
+            label = 'Y'
+
+        super(self.__class__, self).append(int(val))
+
+        if label == 'M':
+            if self.has_month:
+                raise ValueError('Month is already set')
+            self.mstridx = len(self) - 1
+        elif label == 'D':
+            if self.has_day:
+                raise ValueError('Day is already set')
+            self.dstridx = len(self) - 1
+        elif label == 'Y':
+            if self.has_year:
+                raise ValueError('Year is already set')
+            self.ystridx = len(self) - 1
+
+    def _resolve_from_stridxs(self, strids):
+        """
+        Try to resolve the identities of year/month/day elements using
+        ystridx, mstridx, and dstridx, if enough of these are specified.
+        """
+        if len(self) == 3 and len(strids) == 2:
+            # we can back out the remaining stridx value
+            missing = [x for x in range(3) if x not in strids.values()]
+            key = [x for x in ['y', 'm', 'd'] if x not in strids]
+            assert len(missing) == len(key) == 1
+            key = key[0]
+            val = missing[0]
+            strids[key] = val
+
+        assert len(self) == len(strids)  # otherwise this should not be called
+        out = {key: self[strids[key]] for key in strids}
+        return (out.get('y'), out.get('m'), out.get('d'))
+
+    def resolve_ymd(self, yearfirst, dayfirst):
+        len_ymd = len(self)
+        year, month, day = (None, None, None)
+
+        strids = (('y', self.ystridx),
+                  ('m', self.mstridx),
+                  ('d', self.dstridx))
+
+        strids = {key: val for key, val in strids if val is not None}
+        if (len(self) == len(strids) > 0 or
+                (len(self) == 3 and len(strids) == 2)):
+            return self._resolve_from_stridxs(strids)
+
+        mstridx = self.mstridx
+
+        if len_ymd > 3:
+            raise ValueError("More than three YMD values")
+        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):
+            # One member, or two members with a month string
+            if mstridx is not None:
+                month = self[mstridx]
+                # since mstridx is 0 or 1, self[mstridx-1] always
+                # looks up the other element
+                other = self[mstridx - 1]
+            else:
+                other = self[0]
+
+            if len_ymd > 1 or mstridx is None:
+                if other > 31:
+                    year = other
+                else:
+                    day = other
+
+        elif len_ymd == 2:
+            # Two members with numbers
+            if self[0] > 31:
+                # 99-01
+                year, month = self
+            elif self[1] > 31:
+                # 01-99
+                month, year = self
+            elif dayfirst and self[1] <= 12:
+                # 13-01
+                day, month = self
+            else:
+                # 01-13
+                month, day = self
+
+        elif len_ymd == 3:
+            # Three members
+            if mstridx == 0:
+                if self[1] > 31:
+                    # Apr-2003-25
+                    month, year, day = self
+                else:
+                    month, day, year = self
+            elif mstridx == 1:
+                if self[0] > 31 or (yearfirst and self[2] <= 31):
+                    # 99-Jan-01
+                    year, month, day = self
+                else:
+                    # 01-Jan-01
+                    # Give precedence to day-first, since
+                    # two-digit years is usually hand-written.
+                    day, month, year = self
+
+            elif mstridx == 2:
+                # WTF!?
+                if self[1] > 31:
+                    # 01-99-Jan
+                    day, year, month = self
+                else:
+                    # 99-01-Jan
+                    year, day, month = self
+
+            else:
+                if (self[0] > 31 or
+                    self.ystridx == 0 or
+                        (yearfirst and self[1] <= 12 and self[2] <= 31)):
+                    # 99-01-01
+                    if dayfirst and self[2] <= 12:
+                        year, day, month = self
+                    else:
+                        year, month, day = self
+                elif self[0] > 12 or (dayfirst and self[1] <= 12):
+                    # 13-01-01
+                    day, month, year = self
+                else:
+                    # 01-13-01
+                    month, day, year = self
+
+        return year, month, day
+
+
+class parser(object):
+    def __init__(self, info=None):
+        self.info = info or parserinfo()
+
+    def parse(self, timestr, default=None,
+              ignoretz=False, tzinfos=None, **kwargs):
+        """
+        Parse the date/time string into a :class:`datetime.datetime` object.
+
+        :param timestr:
+            Any date/time string using the supported formats.
+
+        :param default:
+            The default datetime object, if this is a datetime object and not
+            ``None``, elements specified in ``timestr`` replace elements in the
+            default object.
+
+        :param ignoretz:
+            If set ``True``, time zones in parsed strings are ignored and a
+            naive :class:`datetime.datetime` object is returned.
+
+        :param tzinfos:
+            Additional time zone names / aliases which may be present in the
+            string. This argument maps time zone names (and optionally offsets
+            from those time zones) to time zones. This parameter can be a
+            dictionary with timezone aliases mapping time zone names to time
+            zones or a function taking two parameters (``tzname`` and
+            ``tzoffset``) and returning a time zone.
+
+            The timezones to which the names are mapped can be an integer
+            offset from UTC in seconds or a :class:`tzinfo` object.
+
+            .. doctest::
+               :options: +NORMALIZE_WHITESPACE
+
+                >>> from dateutil.parser import parse
+                >>> from dateutil.tz import gettz
+                >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
+                >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
+                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
+                >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
+                datetime.datetime(2012, 1, 19, 17, 21,
+                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
+
+            This parameter is ignored if ``ignoretz`` is set.
+
+        :param \\*\\*kwargs:
+            Keyword arguments as passed to ``_parse()``.
+
+        :return:
+            Returns a :class:`datetime.datetime` object or, if the
+            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+            first element being a :class:`datetime.datetime` object, the second
+            a tuple containing the fuzzy tokens.
+
+        :raises ParserError:
+            Raised for invalid or unknown string format, if the provided
+            :class:`tzinfo` is not in a valid format, or if an invalid date
+            would be created.
+
+        :raises TypeError:
+            Raised for non-string or character stream input.
+
+        :raises OverflowError:
+            Raised if the parsed date exceeds the largest valid C integer on
+            your system.
+        """
+
+        if default is None:
+            default = datetime.datetime.now().replace(hour=0, minute=0,
+                                                      second=0, microsecond=0)
+
+        res, skipped_tokens = self._parse(timestr, **kwargs)
+
+        if res is None:
+            raise ParserError("Unknown string format: %s", timestr)
+
+        if len(res) == 0:
+            raise ParserError("String does not contain a date: %s", timestr)
+
+        try:
+            ret = self._build_naive(res, default)
+        except ValueError as e:
+            six.raise_from(ParserError(str(e) + ": %s", timestr), e)
+
+        if not ignoretz:
+            ret = self._build_tzaware(ret, res, tzinfos)
+
+        if kwargs.get('fuzzy_with_tokens', False):
+            return ret, skipped_tokens
+        else:
+            return ret
+
+    class _result(_resultbase):
+        __slots__ = ["year", "month", "day", "weekday",
+                     "hour", "minute", "second", "microsecond",
+                     "tzname", "tzoffset", "ampm","any_unused_tokens"]
+
+    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,
+               fuzzy_with_tokens=False):
+        """
+        Private method which performs the heavy lifting of parsing, called from
+        ``parse()``, which passes on its ``kwargs`` to this function.
+
+        :param timestr:
+            The string to parse.
+
+        :param dayfirst:
+            Whether to interpret the first value in an ambiguous 3-integer date
+            (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+            ``yearfirst`` is set to ``True``, this distinguishes between YDM
+            and YMD. If set to ``None``, this value is retrieved from the
+            current :class:`parserinfo` object (which itself defaults to
+            ``False``).
+
+        :param yearfirst:
+            Whether to interpret the first value in an ambiguous 3-integer date
+            (e.g. 01/05/09) as the year. If ``True``, the first number is taken
+            to be the year, otherwise the last number is taken to be the year.
+            If this is set to ``None``, the value is retrieved from the current
+            :class:`parserinfo` object (which itself defaults to ``False``).
+
+        :param fuzzy:
+            Whether to allow fuzzy parsing, allowing for string like "Today is
+            January 1, 2047 at 8:21:00AM".
+
+        :param fuzzy_with_tokens:
+            If ``True``, ``fuzzy`` is automatically set to True, and the parser
+            will return a tuple where the first element is the parsed
+            :class:`datetime.datetime` datetimestamp and the second element is
+            a tuple containing the portions of the string which were ignored:
+
+            .. doctest::
+
+                >>> from dateutil.parser import parse
+                >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
+                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
+
+        """
+        if fuzzy_with_tokens:
+            fuzzy = True
+
+        info = self.info
+
+        if dayfirst is None:
+            dayfirst = info.dayfirst
+
+        if yearfirst is None:
+            yearfirst = info.yearfirst
+
+        res = self._result()
+        l = _timelex.split(timestr)         # Splits the timestr into tokens
+
+        skipped_idxs = []
+
+        # year/month/day list
+        ymd = _ymd()
+
+        len_l = len(l)
+        i = 0
+        try:
+            while i < len_l:
+
+                # Check if it's a number
+                value_repr = l[i]
+                try:
+                    value = float(value_repr)
+                except ValueError:
+                    value = None
+
+                if value is not None:
+                    # Numeric token
+                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)
+
+                # Check weekday
+                elif info.weekday(l[i]) is not None:
+                    value = info.weekday(l[i])
+                    res.weekday = value
+
+                # Check month name
+                elif info.month(l[i]) is not None:
+                    value = info.month(l[i])
+                    ymd.append(value, 'M')
+
+                    if i + 1 < len_l:
+                        if l[i + 1] in ('-', '/'):
+                            # Jan-01[-99]
+                            sep = l[i + 1]
+                            ymd.append(l[i + 2])
+
+                            if i + 3 < len_l and l[i + 3] == sep:
+                                # Jan-01-99
+                                ymd.append(l[i + 4])
+                                i += 2
+
+                            i += 2
+
+                        elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and
+                              info.pertain(l[i + 2])):
+                            # Jan of 01
+                            # In this case, 01 is clearly year
+                            if l[i + 4].isdigit():
+                                # Convert it here to become unambiguous
+                                value = int(l[i + 4])
+                                year = str(info.convertyear(value))
+                                ymd.append(year, 'Y')
+                            else:
+                                # Wrong guess
+                                pass
+                                # TODO: not hit in tests
+                            i += 4
+
+                # Check am/pm
+                elif info.ampm(l[i]) is not None:
+                    value = info.ampm(l[i])
+                    val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)
+
+                    if val_is_ampm:
+                        res.hour = self._adjust_ampm(res.hour, value)
+                        res.ampm = value
+
+                    elif fuzzy:
+                        skipped_idxs.append(i)
+
+                # Check for a timezone name
+                elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):
+                    res.tzname = l[i]
+                    res.tzoffset = info.tzoffset(res.tzname)
+
+                    # Check for something like GMT+3, or BRST+3. Notice
+                    # that it doesn't mean "I am 3 hours after GMT", but
+                    # "my time +3 is GMT". If found, we reverse the
+                    # logic so that timezone parsing code will get it
+                    # right.
+                    if i + 1 < len_l and l[i + 1] in ('+', '-'):
+                        l[i + 1] = ('+', '-')[l[i + 1] == '+']
+                        res.tzoffset = None
+                        if info.utczone(res.tzname):
+                            # With something like GMT+3, the timezone
+                            # is *not* GMT.
+                            res.tzname = None
+
+                # Check for a numbered timezone
+                elif res.hour is not None and l[i] in ('+', '-'):
+                    signal = (-1, 1)[l[i] == '+']
+                    len_li = len(l[i + 1])
+
+                    # TODO: check that l[i + 1] is integer?
+                    if len_li == 4:
+                        # -0300
+                        hour_offset = int(l[i + 1][:2])
+                        min_offset = int(l[i + 1][2:])
+                    elif i + 2 < len_l and l[i + 2] == ':':
+                        # -03:00
+                        hour_offset = int(l[i + 1])
+                        min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?
+                        i += 2
+                    elif len_li <= 2:
+                        # -[0]3
+                        hour_offset = int(l[i + 1][:2])
+                        min_offset = 0
+                    else:
+                        raise ValueError(timestr)
+
+                    res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)
+
+                    # Look for a timezone name between parenthesis
+                    if (i + 5 < len_l and
+                            info.jump(l[i + 2]) and l[i + 3] == '(' and
+                            l[i + 5] == ')' and
+                            3 <= len(l[i + 4]) and
+                            self._could_be_tzname(res.hour, res.tzname,
+                                                  None, l[i + 4])):
+                        # -0300 (BRST)
+                        res.tzname = l[i + 4]
+                        i += 4
+
+                    i += 1
+
+                # Check jumps
+                elif not (info.jump(l[i]) or fuzzy):
+                    raise ValueError(timestr)
+
+                else:
+                    skipped_idxs.append(i)
+                i += 1
+
+            # Process year/month/day
+            year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)
+
+            res.century_specified = ymd.century_specified
+            res.year = year
+            res.month = month
+            res.day = day
+
+        except (IndexError, ValueError):
+            return None, None
+
+        if not info.validate(res):
+            return None, None
+
+        if fuzzy_with_tokens:
+            skipped_tokens = self._recombine_skipped(l, skipped_idxs)
+            return res, tuple(skipped_tokens)
+        else:
+            return res, None
+
+    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):
+        # Token is a number
+        value_repr = tokens[idx]
+        try:
+            value = self._to_decimal(value_repr)
+        except Exception as e:
+            six.raise_from(ValueError('Unknown numeric token'), e)
+
+        len_li = len(value_repr)
+
+        len_l = len(tokens)
+
+        if (len(ymd) == 3 and len_li in (2, 4) and
+            res.hour is None and
+            (idx + 1 >= len_l or
+             (tokens[idx + 1] != ':' and
+              info.hms(tokens[idx + 1]) is None))):
+            # 19990101T23[59]
+            s = tokens[idx]
+            res.hour = int(s[:2])
+
+            if len_li == 4:
+                res.minute = int(s[2:])
+
+        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):
+            # YYMMDD or HHMMSS[.ss]
+            s = tokens[idx]
+
+            if not ymd and '.' not in tokens[idx]:
+                ymd.append(s[:2])
+                ymd.append(s[2:4])
+                ymd.append(s[4:])
+            else:
+                # 19990101T235959[.59]
+
+                # TODO: Check if res attributes already set.
+                res.hour = int(s[:2])
+                res.minute = int(s[2:4])
+                res.second, res.microsecond = self._parsems(s[4:])
+
+        elif len_li in (8, 12, 14):
+            # YYYYMMDD
+            s = tokens[idx]
+            ymd.append(s[:4], 'Y')
+            ymd.append(s[4:6])
+            ymd.append(s[6:8])
+
+            if len_li > 8:
+                res.hour = int(s[8:10])
+                res.minute = int(s[10:12])
+
+                if len_li > 12:
+                    res.second = int(s[12:])
+
+        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:
+            # HH[ ]h or MM[ ]m or SS[.ss][ ]s
+            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)
+            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)
+            if hms is not None:
+                # TODO: checking that hour/minute/second are not
+                # already set?
+                self._assign_hms(res, value_repr, hms)
+
+        elif idx + 2 < len_l and tokens[idx + 1] == ':':
+            # HH:MM[:SS[.ss]]
+            res.hour = int(value)
+            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?
+            (res.minute, res.second) = self._parse_min_sec(value)
+
+            if idx + 4 < len_l and tokens[idx + 3] == ':':
+                res.second, res.microsecond = self._parsems(tokens[idx + 4])
+
+                idx += 2
+
+            idx += 2
+
+        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):
+            sep = tokens[idx + 1]
+            ymd.append(value_repr)
+
+            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):
+                if tokens[idx + 2].isdigit():
+                    # 01-01[-01]
+                    ymd.append(tokens[idx + 2])
+                else:
+                    # 01-Jan[-01]
+                    value = info.month(tokens[idx + 2])
+
+                    if value is not None:
+                        ymd.append(value, 'M')
+                    else:
+                        raise ValueError()
+
+                if idx + 3 < len_l and tokens[idx + 3] == sep:
+                    # We have three members
+                    value = info.month(tokens[idx + 4])
+
+                    if value is not None:
+                        ymd.append(value, 'M')
+                    else:
+                        ymd.append(tokens[idx + 4])
+                    idx += 2
+
+                idx += 1
+            idx += 1
+
+        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):
+            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:
+                # 12 am
+                hour = int(value)
+                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))
+                idx += 1
+            else:
+                # Year, month or day
+                ymd.append(value)
+            idx += 1
+
+        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):
+            # 12am
+            hour = int(value)
+            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))
+            idx += 1
+
+        elif ymd.could_be_day(value):
+            ymd.append(value)
+
+        elif not fuzzy:
+            raise ValueError()
+
+        return idx
+
+    def _find_hms_idx(self, idx, tokens, info, allow_jump):
+        len_l = len(tokens)
+
+        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:
+            # There is an "h", "m", or "s" label following this token.  We take
+            # assign the upcoming label to the current token.
+            # e.g. the "12" in 12h"
+            hms_idx = idx + 1
+
+        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and
+              info.hms(tokens[idx+2]) is not None):
+            # There is a space and then an "h", "m", or "s" label.
+            # e.g. the "12" in "12 h"
+            hms_idx = idx + 2
+
+        elif idx > 0 and info.hms(tokens[idx-1]) is not None:
+            # There is a "h", "m", or "s" preceding this token.  Since neither
+            # of the previous cases was hit, there is no label following this
+            # token, so we use the previous label.
+            # e.g. the "04" in "12h04"
+            hms_idx = idx-1
+
+        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and
+              info.hms(tokens[idx-2]) is not None):
+            # If we are looking at the final token, we allow for a
+            # backward-looking check to skip over a space.
+            # TODO: Are we sure this is the right condition here?
+            hms_idx = idx - 2
+
+        else:
+            hms_idx = None
+
+        return hms_idx
+
+    def _assign_hms(self, res, value_repr, hms):
+        # See GH issue #427, fixing float rounding
+        value = self._to_decimal(value_repr)
+
+        if hms == 0:
+            # Hour
+            res.hour = int(value)
+            if value % 1:
+                res.minute = int(60*(value % 1))
+
+        elif hms == 1:
+            (res.minute, res.second) = self._parse_min_sec(value)
+
+        elif hms == 2:
+            (res.second, res.microsecond) = self._parsems(value_repr)
+
+    def _could_be_tzname(self, hour, tzname, tzoffset, token):
+        return (hour is not None and
+                tzname is None and
+                tzoffset is None and
+                len(token) <= 5 and
+                (all(x in string.ascii_uppercase for x in token)
+                 or token in self.info.UTCZONE))
+
+    def _ampm_valid(self, hour, ampm, fuzzy):
+        """
+        For fuzzy parsing, 'a' or 'am' (both valid English words)
+        may erroneously trigger the AM/PM flag. Deal with that
+        here.
+        """
+        val_is_ampm = True
+
+        # If there's already an AM/PM flag, this one isn't one.
+        if fuzzy and ampm is not None:
+            val_is_ampm = False
+
+        # If AM/PM is found and hour is not, raise a ValueError
+        if hour is None:
+            if fuzzy:
+                val_is_ampm = False
+            else:
+                raise ValueError('No hour specified with AM or PM flag.')
+        elif not 0 <= hour <= 12:
+            # If AM/PM is found, it's a 12 hour clock, so raise
+            # an error for invalid range
+            if fuzzy:
+                val_is_ampm = False
+            else:
+                raise ValueError('Invalid hour specified for 12-hour clock.')
+
+        return val_is_ampm
+
+    def _adjust_ampm(self, hour, ampm):
+        if hour < 12 and ampm == 1:
+            hour += 12
+        elif hour == 12 and ampm == 0:
+            hour = 0
+        return hour
+
+    def _parse_min_sec(self, value):
+        # TODO: Every usage of this function sets res.second to the return
+        # value. Are there any cases where second will be returned as None and
+        # we *don't* want to set res.second = None?
+        minute = int(value)
+        second = None
+
+        sec_remainder = value % 1
+        if sec_remainder:
+            second = int(60 * sec_remainder)
+        return (minute, second)
+
+    def _parse_hms(self, idx, tokens, info, hms_idx):
+        # TODO: Is this going to admit a lot of false-positives for when we
+        # just happen to have digits and "h", "m" or "s" characters in non-date
+        # text?  I guess hex hashes won't have that problem, but there's plenty
+        # of random junk out there.
+        if hms_idx is None:
+            hms = None
+            new_idx = idx
+        elif hms_idx > idx:
+            hms = info.hms(tokens[hms_idx])
+            new_idx = hms_idx
+        else:
+            # Looking backwards, increment one.
+            hms = info.hms(tokens[hms_idx]) + 1
+            new_idx = idx
+
+        return (new_idx, hms)
+
+    # ------------------------------------------------------------------
+    # Handling for individual tokens.  These are kept as methods instead
+    #  of functions for the sake of customizability via subclassing.
+
+    def _parsems(self, value):
+        """Parse a I[.F] seconds value into (seconds, microseconds)."""
+        if "." not in value:
+            return int(value), 0
+        else:
+            i, f = value.split(".")
+            return int(i), int(f.ljust(6, "0")[:6])
+
+    def _to_decimal(self, val):
+        try:
+            decimal_value = Decimal(val)
+            # See GH 662, edge case, infinite value should not be converted
+            #  via `_to_decimal`
+            if not decimal_value.is_finite():
+                raise ValueError("Converted decimal value is infinite or NaN")
+        except Exception as e:
+            msg = "Could not convert %s to decimal" % val
+            six.raise_from(ValueError(msg), e)
+        else:
+            return decimal_value
+
+    # ------------------------------------------------------------------
+    # Post-Parsing construction of datetime output.  These are kept as
+    #  methods instead of functions for the sake of customizability via
+    #  subclassing.
+
+    def _build_tzinfo(self, tzinfos, tzname, tzoffset):
+        if callable(tzinfos):
+            tzdata = tzinfos(tzname, tzoffset)
+        else:
+            tzdata = tzinfos.get(tzname)
+        # handle case where tzinfo is paased an options that returns None
+        # eg tzinfos = {'BRST' : None}
+        if isinstance(tzdata, datetime.tzinfo) or tzdata is None:
+            tzinfo = tzdata
+        elif isinstance(tzdata, text_type):
+            tzinfo = tz.tzstr(tzdata)
+        elif isinstance(tzdata, integer_types):
+            tzinfo = tz.tzoffset(tzname, tzdata)
+        else:
+            raise TypeError("Offset must be tzinfo subclass, tz string, "
+                            "or int offset.")
+        return tzinfo
+
+    def _build_tzaware(self, naive, res, tzinfos):
+        if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):
+            tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)
+            aware = naive.replace(tzinfo=tzinfo)
+            aware = self._assign_tzname(aware, res.tzname)
+
+        elif res.tzname and res.tzname in time.tzname:
+            aware = naive.replace(tzinfo=tz.tzlocal())
+
+            # Handle ambiguous local datetime
+            aware = self._assign_tzname(aware, res.tzname)
+
+            # This is mostly relevant for winter GMT zones parsed in the UK
+            if (aware.tzname() != res.tzname and
+                    res.tzname in self.info.UTCZONE):
+                aware = aware.replace(tzinfo=tz.UTC)
+
+        elif res.tzoffset == 0:
+            aware = naive.replace(tzinfo=tz.UTC)
+
+        elif res.tzoffset:
+            aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))
+
+        elif not res.tzname and not res.tzoffset:
+            # i.e. no timezone information was found.
+            aware = naive
+
+        elif res.tzname:
+            # tz-like string was parsed but we don't know what to do
+            # with it
+            warnings.warn("tzname {tzname} identified but not understood.  "
+                          "Pass `tzinfos` argument in order to correctly "
+                          "return a timezone-aware datetime.  In a future "
+                          "version, this will raise an "
+                          "exception.".format(tzname=res.tzname),
+                          category=UnknownTimezoneWarning)
+            aware = naive
+
+        return aware
+
+    def _build_naive(self, res, default):
+        repl = {}
+        for attr in ("year", "month", "day", "hour",
+                     "minute", "second", "microsecond"):
+            value = getattr(res, attr)
+            if value is not None:
+                repl[attr] = value
+
+        if 'day' not in repl:
+            # If the default day exceeds the last day of the month, fall back
+            # to the end of the month.
+            cyear = default.year if res.year is None else res.year
+            cmonth = default.month if res.month is None else res.month
+            cday = default.day if res.day is None else res.day
+
+            if cday > monthrange(cyear, cmonth)[1]:
+                repl['day'] = monthrange(cyear, cmonth)[1]
+
+        naive = default.replace(**repl)
+
+        if res.weekday is not None and not res.day:
+            naive = naive + relativedelta.relativedelta(weekday=res.weekday)
+
+        return naive
+
+    def _assign_tzname(self, dt, tzname):
+        if dt.tzname() != tzname:
+            new_dt = tz.enfold(dt, fold=1)
+            if new_dt.tzname() == tzname:
+                return new_dt
+
+        return dt
+
+    def _recombine_skipped(self, tokens, skipped_idxs):
+        """
+        >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
+        >>> skipped_idxs = [0, 1, 2, 5]
+        >>> _recombine_skipped(tokens, skipped_idxs)
+        ["foo bar", "baz"]
+        """
+        skipped_tokens = []
+        for i, idx in enumerate(sorted(skipped_idxs)):
+            if i > 0 and idx - 1 == skipped_idxs[i - 1]:
+                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]
+            else:
+                skipped_tokens.append(tokens[idx])
+
+        return skipped_tokens
+
+
+DEFAULTPARSER = parser()
+
+
+def parse(timestr, parserinfo=None, **kwargs):
+    """
+
+    Parse a string in one of the supported formats, using the
+    ``parserinfo`` parameters.
+
+    :param timestr:
+        A string containing a date/time stamp.
+
+    :param parserinfo:
+        A :class:`parserinfo` object containing parameters for the parser.
+        If ``None``, the default arguments to the :class:`parserinfo`
+        constructor are used.
+
+    The ``**kwargs`` parameter takes the following keyword arguments:
+
+    :param default:
+        The default datetime object, if this is a datetime object and not
+        ``None``, elements specified in ``timestr`` replace elements in the
+        default object.
+
+    :param ignoretz:
+        If set ``True``, time zones in parsed strings are ignored and a naive
+        :class:`datetime` object is returned.
+
+    :param tzinfos:
+        Additional time zone names / aliases which may be present in the
+        string. This argument maps time zone names (and optionally offsets
+        from those time zones) to time zones. This parameter can be a
+        dictionary with timezone aliases mapping time zone names to time
+        zones or a function taking two parameters (``tzname`` and
+        ``tzoffset``) and returning a time zone.
+
+        The timezones to which the names are mapped can be an integer
+        offset from UTC in seconds or a :class:`tzinfo` object.
+
+        .. doctest::
+           :options: +NORMALIZE_WHITESPACE
+
+            >>> from dateutil.parser import parse
+            >>> from dateutil.tz import gettz
+            >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
+            >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
+            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
+            >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
+            datetime.datetime(2012, 1, 19, 17, 21,
+                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
+
+        This parameter is ignored if ``ignoretz`` is set.
+
+    :param dayfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
+        YMD. If set to ``None``, this value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+
+    :param yearfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
+        be the year, otherwise the last number is taken to be the year. If
+        this is set to ``None``, the value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+
+    :param fuzzy:
+        Whether to allow fuzzy parsing, allowing for string like "Today is
+        January 1, 2047 at 8:21:00AM".
+
+    :param fuzzy_with_tokens:
+        If ``True``, ``fuzzy`` is automatically set to True, and the parser
+        will return a tuple where the first element is the parsed
+        :class:`datetime.datetime` datetimestamp and the second element is
+        a tuple containing the portions of the string which were ignored:
+
+        .. doctest::
+
+            >>> from dateutil.parser import parse
+            >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
+            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
+
+    :return:
+        Returns a :class:`datetime.datetime` object or, if the
+        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+        first element being a :class:`datetime.datetime` object, the second
+        a tuple containing the fuzzy tokens.
+
+    :raises ParserError:
+        Raised for invalid or unknown string formats, if the provided
+        :class:`tzinfo` is not in a valid format, or if an invalid date would
+        be created.
+
+    :raises OverflowError:
+        Raised if the parsed date exceeds the largest valid C integer on
+        your system.
+    """
+    if parserinfo:
+        return parser(parserinfo).parse(timestr, **kwargs)
+    else:
+        return DEFAULTPARSER.parse(timestr, **kwargs)
+
+
+class _tzparser(object):
+
+    class _result(_resultbase):
+
+        __slots__ = ["stdabbr", "stdoffset", "dstabbr", "dstoffset",
+                     "start", "end"]
+
+        class _attr(_resultbase):
+            __slots__ = ["month", "week", "weekday",
+                         "yday", "jyday", "day", "time"]
+
+        def __repr__(self):
+            return self._repr("")
+
+        def __init__(self):
+            _resultbase.__init__(self)
+            self.start = self._attr()
+            self.end = self._attr()
+
+    def parse(self, tzstr):
+        res = self._result()
+        l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]
+        used_idxs = list()
+        try:
+
+            len_l = len(l)
+
+            i = 0
+            while i < len_l:
+                # BRST+3[BRDT[+2]]
+                j = i
+                while j < len_l and not [x for x in l[j]
+                                         if x in "0123456789:,-+"]:
+                    j += 1
+                if j != i:
+                    if not res.stdabbr:
+                        offattr = "stdoffset"
+                        res.stdabbr = "".join(l[i:j])
+                    else:
+                        offattr = "dstoffset"
+                        res.dstabbr = "".join(l[i:j])
+
+                    for ii in range(j):
+                        used_idxs.append(ii)
+                    i = j
+                    if (i < len_l and (l[i] in ('+', '-') or l[i][0] in
+                                       "0123456789")):
+                        if l[i] in ('+', '-'):
+                            # Yes, that's right.  See the TZ variable
+                            # documentation.
+                            signal = (1, -1)[l[i] == '+']
+                            used_idxs.append(i)
+                            i += 1
+                        else:
+                            signal = -1
+                        len_li = len(l[i])
+                        if len_li == 4:
+                            # -0300
+                            setattr(res, offattr, (int(l[i][:2]) * 3600 +
+                                                   int(l[i][2:]) * 60) * signal)
+                        elif i + 1 < len_l and l[i + 1] == ':':
+                            # -03:00
+                            setattr(res, offattr,
+                                    (int(l[i]) * 3600 +
+                                     int(l[i + 2]) * 60) * signal)
+                            used_idxs.append(i)
+                            i += 2
+                        elif len_li <= 2:
+                            # -[0]3
+                            setattr(res, offattr,
+                                    int(l[i][:2]) * 3600 * signal)
+                        else:
+                            return None
+                        used_idxs.append(i)
+                        i += 1
+                    if res.dstabbr:
+                        break
+                else:
+                    break
+
+
+            if i < len_l:
+                for j in range(i, len_l):
+                    if l[j] == ';':
+                        l[j] = ','
+
+                assert l[i] == ','
+
+                i += 1
+
+            if i >= len_l:
+                pass
+            elif (8 <= l.count(',') <= 9 and
+                  not [y for x in l[i:] if x != ','
+                       for y in x if y not in "0123456789+-"]):
+                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]
+                for x in (res.start, res.end):
+                    x.month = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    if l[i] == '-':
+                        value = int(l[i + 1]) * -1
+                        used_idxs.append(i)
+                        i += 1
+                    else:
+                        value = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    if value:
+                        x.week = value
+                        x.weekday = (int(l[i]) - 1) % 7
+                    else:
+                        x.day = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    x.time = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                if i < len_l:
+                    if l[i] in ('-', '+'):
+                        signal = (-1, 1)[l[i] == "+"]
+                        used_idxs.append(i)
+                        i += 1
+                    else:
+                        signal = 1
+                    used_idxs.append(i)
+                    res.dstoffset = (res.stdoffset + int(l[i]) * signal)
+
+                # This was a made-up format that is not in normal use
+                warn(('Parsed time zone "%s"' % tzstr) +
+                     'is in a non-standard dateutil-specific format, which ' +
+                     'is now deprecated; support for parsing this format ' +
+                     'will be removed in future versions. It is recommended ' +
+                     'that you switch to a standard format like the GNU ' +
+                     'TZ variable format.', tz.DeprecatedTzFormatWarning)
+            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and
+                  not [y for x in l[i:] if x not in (',', '/', 'J', 'M',
+                                                     '.', '-', ':')
+                       for y in x if y not in "0123456789"]):
+                for x in (res.start, res.end):
+                    if l[i] == 'J':
+                        # non-leap year day (1 based)
+                        used_idxs.append(i)
+                        i += 1
+                        x.jyday = int(l[i])
+                    elif l[i] == 'M':
+                        # month[-.]week[-.]weekday
+                        used_idxs.append(i)
+                        i += 1
+                        x.month = int(l[i])
+                        used_idxs.append(i)
+                        i += 1
+                        assert l[i] in ('-', '.')
+                        used_idxs.append(i)
+                        i += 1
+                        x.week = int(l[i])
+                        if x.week == 5:
+                            x.week = -1
+                        used_idxs.append(i)
+                        i += 1
+                        assert l[i] in ('-', '.')
+                        used_idxs.append(i)
+                        i += 1
+                        x.weekday = (int(l[i]) - 1) % 7
+                    else:
+                        # year day (zero based)
+                        x.yday = int(l[i]) + 1
+
+                    used_idxs.append(i)
+                    i += 1
+
+                    if i < len_l and l[i] == '/':
+                        used_idxs.append(i)
+                        i += 1
+                        # start time
+                        len_li = len(l[i])
+                        if len_li == 4:
+                            # -0300
+                            x.time = (int(l[i][:2]) * 3600 +
+                                      int(l[i][2:]) * 60)
+                        elif i + 1 < len_l and l[i + 1] == ':':
+                            # -03:00
+                            x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60
+                            used_idxs.append(i)
+                            i += 2
+                            if i + 1 < len_l and l[i + 1] == ':':
+                                used_idxs.append(i)
+                                i += 2
+                                x.time += int(l[i])
+                        elif len_li <= 2:
+                            # -[0]3
+                            x.time = (int(l[i][:2]) * 3600)
+                        else:
+                            return None
+                        used_idxs.append(i)
+                        i += 1
+
+                    assert i == len_l or l[i] == ','
+
+                    i += 1
+
+                assert i >= len_l
+
+        except (IndexError, ValueError, AssertionError):
+            return None
+
+        unused_idxs = set(range(len_l)).difference(used_idxs)
+        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({",",":"})
+        return res
+
+
+DEFAULTTZPARSER = _tzparser()
+
+
+def _parsetz(tzstr):
+    return DEFAULTTZPARSER.parse(tzstr)
+
+
+class ParserError(ValueError):
+    """Exception subclass used for any failure to parse a datetime string.
+
+    This is a subclass of :py:exc:`ValueError`, and should be raised any time
+    earlier versions of ``dateutil`` would have raised ``ValueError``.
+
+    .. versionadded:: 2.8.1
+    """
+    def __str__(self):
+        try:
+            return self.args[0] % self.args[1:]
+        except (TypeError, IndexError):
+            return super(ParserError, self).__str__()
+
+    def __repr__(self):
+        args = ", ".join("'%s'" % arg for arg in self.args)
+        return "%s(%s)" % (self.__class__.__name__, args)
+
+
+class UnknownTimezoneWarning(RuntimeWarning):
+    """Raised when the parser finds a timezone it cannot parse into a tzinfo.
+
+    .. versionadded:: 2.7.0
+    """
+# vim:ts=4:sw=4:et
diff --git a/Lib/site-packages/dateutil/parser/isoparser.py b/Lib/site-packages/dateutil/parser/isoparser.py
new file mode 100644
index 0000000..7060087
--- /dev/null
+++ b/Lib/site-packages/dateutil/parser/isoparser.py
@@ -0,0 +1,416 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a parser for ISO-8601 strings
+
+It is intended to support all valid date, time and datetime formats per the
+ISO-8601 specification.
+
+..versionadded:: 2.7.0
+"""
+from datetime import datetime, timedelta, time, date
+import calendar
+from dateutil import tz
+
+from functools import wraps
+
+import re
+import six
+
+__all__ = ["isoparse", "isoparser"]
+
+
+def _takes_ascii(f):
+    @wraps(f)
+    def func(self, str_in, *args, **kwargs):
+        # If it's a stream, read the whole thing
+        str_in = getattr(str_in, 'read', lambda: str_in)()
+
+        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII
+        if isinstance(str_in, six.text_type):
+            # ASCII is the same in UTF-8
+            try:
+                str_in = str_in.encode('ascii')
+            except UnicodeEncodeError as e:
+                msg = 'ISO-8601 strings should contain only ASCII characters'
+                six.raise_from(ValueError(msg), e)
+
+        return f(self, str_in, *args, **kwargs)
+
+    return func
+
+
+class isoparser(object):
+    def __init__(self, sep=None):
+        """
+        :param sep:
+            A single character that separates date and time portions. If
+            ``None``, the parser will accept any single character.
+            For strict ISO-8601 adherence, pass ``'T'``.
+        """
+        if sep is not None:
+            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):
+                raise ValueError('Separator must be a single, non-numeric ' +
+                                 'ASCII character')
+
+            sep = sep.encode('ascii')
+
+        self._sep = sep
+
+    @_takes_ascii
+    def isoparse(self, dt_str):
+        """
+        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.
+
+        An ISO-8601 datetime string consists of a date portion, followed
+        optionally by a time portion - the date and time portions are separated
+        by a single character separator, which is ``T`` in the official
+        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be
+        combined with a time portion.
+
+        Supported date formats are:
+
+        Common:
+
+        - ``YYYY``
+        - ``YYYY-MM``
+        - ``YYYY-MM-DD`` or ``YYYYMMDD``
+
+        Uncommon:
+
+        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)
+        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day
+
+        The ISO week and day numbering follows the same logic as
+        :func:`datetime.date.isocalendar`.
+
+        Supported time formats are:
+
+        - ``hh``
+        - ``hh:mm`` or ``hhmm``
+        - ``hh:mm:ss`` or ``hhmmss``
+        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)
+
+        Midnight is a special case for `hh`, as the standard supports both
+        00:00 and 24:00 as a representation. The decimal separator can be
+        either a dot or a comma.
+
+
+        .. caution::
+
+            Support for fractional components other than seconds is part of the
+            ISO-8601 standard, but is not currently implemented in this parser.
+
+        Supported time zone offset formats are:
+
+        - `Z` (UTC)
+        - `±HH:MM`
+        - `±HHMM`
+        - `±HH`
+
+        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,
+        with the exception of UTC, which will be represented as
+        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such
+        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.
+
+        :param dt_str:
+            A string or stream containing only an ISO-8601 datetime string
+
+        :return:
+            Returns a :class:`datetime.datetime` representing the string.
+            Unspecified components default to their lowest value.
+
+        .. warning::
+
+            As of version 2.7.0, the strictness of the parser should not be
+            considered a stable part of the contract. Any valid ISO-8601 string
+            that parses correctly with the default settings will continue to
+            parse correctly in future versions, but invalid strings that
+            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not
+            guaranteed to continue failing in future versions if they encode
+            a valid date.
+
+        .. versionadded:: 2.7.0
+        """
+        components, pos = self._parse_isodate(dt_str)
+
+        if len(dt_str) > pos:
+            if self._sep is None or dt_str[pos:pos + 1] == self._sep:
+                components += self._parse_isotime(dt_str[pos + 1:])
+            else:
+                raise ValueError('String contains unknown ISO components')
+
+        if len(components) > 3 and components[3] == 24:
+            components[3] = 0
+            return datetime(*components) + timedelta(days=1)
+
+        return datetime(*components)
+
+    @_takes_ascii
+    def parse_isodate(self, datestr):
+        """
+        Parse the date portion of an ISO string.
+
+        :param datestr:
+            The string portion of an ISO string, without a separator
+
+        :return:
+            Returns a :class:`datetime.date` object
+        """
+        components, pos = self._parse_isodate(datestr)
+        if pos < len(datestr):
+            raise ValueError('String contains unknown ISO ' +
+                             'components: {!r}'.format(datestr.decode('ascii')))
+        return date(*components)
+
+    @_takes_ascii
+    def parse_isotime(self, timestr):
+        """
+        Parse the time portion of an ISO string.
+
+        :param timestr:
+            The time portion of an ISO string, without a separator
+
+        :return:
+            Returns a :class:`datetime.time` object
+        """
+        components = self._parse_isotime(timestr)
+        if components[0] == 24:
+            components[0] = 0
+        return time(*components)
+
+    @_takes_ascii
+    def parse_tzstr(self, tzstr, zero_as_utc=True):
+        """
+        Parse a valid ISO time zone string.
+
+        See :func:`isoparser.isoparse` for details on supported formats.
+
+        :param tzstr:
+            A string representing an ISO time zone offset
+
+        :param zero_as_utc:
+            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones
+
+        :return:
+            Returns :class:`dateutil.tz.tzoffset` for offsets and
+            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is
+            specified) offsets equivalent to UTC.
+        """
+        return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)
+
+    # Constants
+    _DATE_SEP = b'-'
+    _TIME_SEP = b':'
+    _FRACTION_REGEX = re.compile(b'[\\.,]([0-9]+)')
+
+    def _parse_isodate(self, dt_str):
+        try:
+            return self._parse_isodate_common(dt_str)
+        except ValueError:
+            return self._parse_isodate_uncommon(dt_str)
+
+    def _parse_isodate_common(self, dt_str):
+        len_str = len(dt_str)
+        components = [1, 1, 1]
+
+        if len_str < 4:
+            raise ValueError('ISO string too short')
+
+        # Year
+        components[0] = int(dt_str[0:4])
+        pos = 4
+        if pos >= len_str:
+            return components, pos
+
+        has_sep = dt_str[pos:pos + 1] == self._DATE_SEP
+        if has_sep:
+            pos += 1
+
+        # Month
+        if len_str - pos < 2:
+            raise ValueError('Invalid common month')
+
+        components[1] = int(dt_str[pos:pos + 2])
+        pos += 2
+
+        if pos >= len_str:
+            if has_sep:
+                return components, pos
+            else:
+                raise ValueError('Invalid ISO format')
+
+        if has_sep:
+            if dt_str[pos:pos + 1] != self._DATE_SEP:
+                raise ValueError('Invalid separator in ISO string')
+            pos += 1
+
+        # Day
+        if len_str - pos < 2:
+            raise ValueError('Invalid common day')
+        components[2] = int(dt_str[pos:pos + 2])
+        return components, pos + 2
+
+    def _parse_isodate_uncommon(self, dt_str):
+        if len(dt_str) < 4:
+            raise ValueError('ISO string too short')
+
+        # All ISO formats start with the year
+        year = int(dt_str[0:4])
+
+        has_sep = dt_str[4:5] == self._DATE_SEP
+
+        pos = 4 + has_sep       # Skip '-' if it's there
+        if dt_str[pos:pos + 1] == b'W':
+            # YYYY-?Www-?D?
+            pos += 1
+            weekno = int(dt_str[pos:pos + 2])
+            pos += 2
+
+            dayno = 1
+            if len(dt_str) > pos:
+                if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:
+                    raise ValueError('Inconsistent use of dash separator')
+
+                pos += has_sep
+
+                dayno = int(dt_str[pos:pos + 1])
+                pos += 1
+
+            base_date = self._calculate_weekdate(year, weekno, dayno)
+        else:
+            # YYYYDDD or YYYY-DDD
+            if len(dt_str) - pos < 3:
+                raise ValueError('Invalid ordinal day')
+
+            ordinal_day = int(dt_str[pos:pos + 3])
+            pos += 3
+
+            if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):
+                raise ValueError('Invalid ordinal day' +
+                                 ' {} for year {}'.format(ordinal_day, year))
+
+            base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)
+
+        components = [base_date.year, base_date.month, base_date.day]
+        return components, pos
+
+    def _calculate_weekdate(self, year, week, day):
+        """
+        Calculate the day of corresponding to the ISO year-week-day calendar.
+
+        This function is effectively the inverse of
+        :func:`datetime.date.isocalendar`.
+
+        :param year:
+            The year in the ISO calendar
+
+        :param week:
+            The week in the ISO calendar - range is [1, 53]
+
+        :param day:
+            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]
+
+        :return:
+            Returns a :class:`datetime.date`
+        """
+        if not 0 < week < 54:
+            raise ValueError('Invalid week: {}'.format(week))
+
+        if not 0 < day < 8:     # Range is 1-7
+            raise ValueError('Invalid weekday: {}'.format(day))
+
+        # Get week 1 for the specific year:
+        jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it
+        week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)
+
+        # Now add the specific number of weeks and days to get what we want
+        week_offset = (week - 1) * 7 + (day - 1)
+        return week_1 + timedelta(days=week_offset)
+
+    def _parse_isotime(self, timestr):
+        len_str = len(timestr)
+        components = [0, 0, 0, 0, None]
+        pos = 0
+        comp = -1
+
+        if len_str < 2:
+            raise ValueError('ISO time too short')
+
+        has_sep = False
+
+        while pos < len_str and comp < 5:
+            comp += 1
+
+            if timestr[pos:pos + 1] in b'-+Zz':
+                # Detect time zone boundary
+                components[-1] = self._parse_tzstr(timestr[pos:])
+                pos = len_str
+                break
+
+            if comp == 1 and timestr[pos:pos+1] == self._TIME_SEP:
+                has_sep = True
+                pos += 1
+            elif comp == 2 and has_sep:
+                if timestr[pos:pos+1] != self._TIME_SEP:
+                    raise ValueError('Inconsistent use of colon separator')
+                pos += 1
+
+            if comp < 3:
+                # Hour, minute, second
+                components[comp] = int(timestr[pos:pos + 2])
+                pos += 2
+
+            if comp == 3:
+                # Fraction of a second
+                frac = self._FRACTION_REGEX.match(timestr[pos:])
+                if not frac:
+                    continue
+
+                us_str = frac.group(1)[:6]  # Truncate to microseconds
+                components[comp] = int(us_str) * 10**(6 - len(us_str))
+                pos += len(frac.group())
+
+        if pos < len_str:
+            raise ValueError('Unused components in ISO string')
+
+        if components[0] == 24:
+            # Standard supports 00:00 and 24:00 as representations of midnight
+            if any(component != 0 for component in components[1:4]):
+                raise ValueError('Hour may only be 24 at 24:00:00.000')
+
+        return components
+
+    def _parse_tzstr(self, tzstr, zero_as_utc=True):
+        if tzstr == b'Z' or tzstr == b'z':
+            return tz.UTC
+
+        if len(tzstr) not in {3, 5, 6}:
+            raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')
+
+        if tzstr[0:1] == b'-':
+            mult = -1
+        elif tzstr[0:1] == b'+':
+            mult = 1
+        else:
+            raise ValueError('Time zone offset requires sign')
+
+        hours = int(tzstr[1:3])
+        if len(tzstr) == 3:
+            minutes = 0
+        else:
+            minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])
+
+        if zero_as_utc and hours == 0 and minutes == 0:
+            return tz.UTC
+        else:
+            if minutes > 59:
+                raise ValueError('Invalid minutes in time zone offset')
+
+            if hours > 23:
+                raise ValueError('Invalid hours in time zone offset')
+
+            return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)
+
+
+DEFAULT_ISOPARSER = isoparser()
+isoparse = DEFAULT_ISOPARSER.isoparse
diff --git a/Lib/site-packages/dateutil/relativedelta.py b/Lib/site-packages/dateutil/relativedelta.py
new file mode 100644
index 0000000..cd323a5
--- /dev/null
+++ b/Lib/site-packages/dateutil/relativedelta.py
@@ -0,0 +1,599 @@
+# -*- coding: utf-8 -*-
+import datetime
+import calendar
+
+import operator
+from math import copysign
+
+from six import integer_types
+from warnings import warn
+
+from ._common import weekday
+
+MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))
+
+__all__ = ["relativedelta", "MO", "TU", "WE", "TH", "FR", "SA", "SU"]
+
+
+class relativedelta(object):
+    """
+    The relativedelta type is designed to be applied to an existing datetime and
+    can replace specific components of that datetime, or represents an interval
+    of time.
+
+    It is based on the specification of the excellent work done by M.-A. Lemburg
+    in his
+    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.
+    However, notice that this type does *NOT* implement the same algorithm as
+    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.
+
+    There are two different ways to build a relativedelta instance. The
+    first one is passing it two date/datetime classes::
+
+        relativedelta(datetime1, datetime2)
+
+    The second one is passing it any number of the following keyword arguments::
+
+        relativedelta(arg1=x,arg2=y,arg3=z...)
+
+        year, month, day, hour, minute, second, microsecond:
+            Absolute information (argument is singular); adding or subtracting a
+            relativedelta with absolute information does not perform an arithmetic
+            operation, but rather REPLACES the corresponding value in the
+            original datetime with the value(s) in relativedelta.
+
+        years, months, weeks, days, hours, minutes, seconds, microseconds:
+            Relative information, may be negative (argument is plural); adding
+            or subtracting a relativedelta with relative information performs
+            the corresponding arithmetic operation on the original datetime value
+            with the information in the relativedelta.
+
+        weekday:
+            One of the weekday instances (MO, TU, etc) available in the
+            relativedelta module. These instances may receive a parameter N,
+            specifying the Nth weekday, which could be positive or negative
+            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
+            +1. You can also use an integer, where 0=MO. This argument is always
+            relative e.g. if the calculated date is already Monday, using MO(1)
+            or MO(-1) won't change the day. To effectively make it absolute, use
+            it in combination with the day argument (e.g. day=1, MO(1) for first
+            Monday of the month).
+
+        leapdays:
+            Will add given days to the date found, if year is a leap
+            year, and the date found is post 28 of february.
+
+        yearday, nlyearday:
+            Set the yearday or the non-leap year day (jump leap days).
+            These are converted to day/month/leapdays information.
+
+    There are relative and absolute forms of the keyword
+    arguments. The plural is relative, and the singular is
+    absolute. For each argument in the order below, the absolute form
+    is applied first (by setting each attribute to that value) and
+    then the relative form (by adding the value to the attribute).
+
+    The order of attributes considered when this relativedelta is
+    added to a datetime is:
+
+    1. Year
+    2. Month
+    3. Day
+    4. Hours
+    5. Minutes
+    6. Seconds
+    7. Microseconds
+
+    Finally, weekday is applied, using the rule described above.
+
+    For example
+
+    >>> from datetime import datetime
+    >>> from dateutil.relativedelta import relativedelta, MO
+    >>> dt = datetime(2018, 4, 9, 13, 37, 0)
+    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))
+    >>> dt + delta
+    datetime.datetime(2018, 4, 2, 14, 37)
+
+    First, the day is set to 1 (the first of the month), then 25 hours
+    are added, to get to the 2nd day and 14th hour, finally the
+    weekday is applied, but since the 2nd is already a Monday there is
+    no effect.
+
+    """
+
+    def __init__(self, dt1=None, dt2=None,
+                 years=0, months=0, days=0, leapdays=0, weeks=0,
+                 hours=0, minutes=0, seconds=0, microseconds=0,
+                 year=None, month=None, day=None, weekday=None,
+                 yearday=None, nlyearday=None,
+                 hour=None, minute=None, second=None, microsecond=None):
+
+        if dt1 and dt2:
+            # datetime is a subclass of date. So both must be date
+            if not (isinstance(dt1, datetime.date) and
+                    isinstance(dt2, datetime.date)):
+                raise TypeError("relativedelta only diffs datetime/date")
+
+            # We allow two dates, or two datetimes, so we coerce them to be
+            # of the same type
+            if (isinstance(dt1, datetime.datetime) !=
+                    isinstance(dt2, datetime.datetime)):
+                if not isinstance(dt1, datetime.datetime):
+                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())
+                elif not isinstance(dt2, datetime.datetime):
+                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())
+
+            self.years = 0
+            self.months = 0
+            self.days = 0
+            self.leapdays = 0
+            self.hours = 0
+            self.minutes = 0
+            self.seconds = 0
+            self.microseconds = 0
+            self.year = None
+            self.month = None
+            self.day = None
+            self.weekday = None
+            self.hour = None
+            self.minute = None
+            self.second = None
+            self.microsecond = None
+            self._has_time = 0
+
+            # Get year / month delta between the two
+            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)
+            self._set_months(months)
+
+            # Remove the year/month delta so the timedelta is just well-defined
+            # time units (seconds, days and microseconds)
+            dtm = self.__radd__(dt2)
+
+            # If we've overshot our target, make an adjustment
+            if dt1 < dt2:
+                compare = operator.gt
+                increment = 1
+            else:
+                compare = operator.lt
+                increment = -1
+
+            while compare(dt1, dtm):
+                months += increment
+                self._set_months(months)
+                dtm = self.__radd__(dt2)
+
+            # Get the timedelta between the "months-adjusted" date and dt1
+            delta = dt1 - dtm
+            self.seconds = delta.seconds + delta.days * 86400
+            self.microseconds = delta.microseconds
+        else:
+            # Check for non-integer values in integer-only quantities
+            if any(x is not None and x != int(x) for x in (years, months)):
+                raise ValueError("Non-integer years and months are "
+                                 "ambiguous and not currently supported.")
+
+            # Relative information
+            self.years = int(years)
+            self.months = int(months)
+            self.days = days + weeks * 7
+            self.leapdays = leapdays
+            self.hours = hours
+            self.minutes = minutes
+            self.seconds = seconds
+            self.microseconds = microseconds
+
+            # Absolute information
+            self.year = year
+            self.month = month
+            self.day = day
+            self.hour = hour
+            self.minute = minute
+            self.second = second
+            self.microsecond = microsecond
+
+            if any(x is not None and int(x) != x
+                   for x in (year, month, day, hour,
+                             minute, second, microsecond)):
+                # For now we'll deprecate floats - later it'll be an error.
+                warn("Non-integer value passed as absolute information. " +
+                     "This is not a well-defined condition and will raise " +
+                     "errors in future versions.", DeprecationWarning)
+
+            if isinstance(weekday, integer_types):
+                self.weekday = weekdays[weekday]
+            else:
+                self.weekday = weekday
+
+            yday = 0
+            if nlyearday:
+                yday = nlyearday
+            elif yearday:
+                yday = yearday
+                if yearday > 59:
+                    self.leapdays = -1
+            if yday:
+                ydayidx = [31, 59, 90, 120, 151, 181, 212,
+                           243, 273, 304, 334, 366]
+                for idx, ydays in enumerate(ydayidx):
+                    if yday <= ydays:
+                        self.month = idx+1
+                        if idx == 0:
+                            self.day = yday
+                        else:
+                            self.day = yday-ydayidx[idx-1]
+                        break
+                else:
+                    raise ValueError("invalid year day (%d)" % yday)
+
+        self._fix()
+
+    def _fix(self):
+        if abs(self.microseconds) > 999999:
+            s = _sign(self.microseconds)
+            div, mod = divmod(self.microseconds * s, 1000000)
+            self.microseconds = mod * s
+            self.seconds += div * s
+        if abs(self.seconds) > 59:
+            s = _sign(self.seconds)
+            div, mod = divmod(self.seconds * s, 60)
+            self.seconds = mod * s
+            self.minutes += div * s
+        if abs(self.minutes) > 59:
+            s = _sign(self.minutes)
+            div, mod = divmod(self.minutes * s, 60)
+            self.minutes = mod * s
+            self.hours += div * s
+        if abs(self.hours) > 23:
+            s = _sign(self.hours)
+            div, mod = divmod(self.hours * s, 24)
+            self.hours = mod * s
+            self.days += div * s
+        if abs(self.months) > 11:
+            s = _sign(self.months)
+            div, mod = divmod(self.months * s, 12)
+            self.months = mod * s
+            self.years += div * s
+        if (self.hours or self.minutes or self.seconds or self.microseconds
+                or self.hour is not None or self.minute is not None or
+                self.second is not None or self.microsecond is not None):
+            self._has_time = 1
+        else:
+            self._has_time = 0
+
+    @property
+    def weeks(self):
+        return int(self.days / 7.0)
+
+    @weeks.setter
+    def weeks(self, value):
+        self.days = self.days - (self.weeks * 7) + value * 7
+
+    def _set_months(self, months):
+        self.months = months
+        if abs(self.months) > 11:
+            s = _sign(self.months)
+            div, mod = divmod(self.months * s, 12)
+            self.months = mod * s
+            self.years = div * s
+        else:
+            self.years = 0
+
+    def normalized(self):
+        """
+        Return a version of this object represented entirely using integer
+        values for the relative attributes.
+
+        >>> relativedelta(days=1.5, hours=2).normalized()
+        relativedelta(days=+1, hours=+14)
+
+        :return:
+            Returns a :class:`dateutil.relativedelta.relativedelta` object.
+        """
+        # Cascade remainders down (rounding each to roughly nearest microsecond)
+        days = int(self.days)
+
+        hours_f = round(self.hours + 24 * (self.days - days), 11)
+        hours = int(hours_f)
+
+        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)
+        minutes = int(minutes_f)
+
+        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)
+        seconds = int(seconds_f)
+
+        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))
+
+        # Constructor carries overflow back up with call to _fix()
+        return self.__class__(years=self.years, months=self.months,
+                              days=days, hours=hours, minutes=minutes,
+                              seconds=seconds, microseconds=microseconds,
+                              leapdays=self.leapdays, year=self.year,
+                              month=self.month, day=self.day,
+                              weekday=self.weekday, hour=self.hour,
+                              minute=self.minute, second=self.second,
+                              microsecond=self.microsecond)
+
+    def __add__(self, other):
+        if isinstance(other, relativedelta):
+            return self.__class__(years=other.years + self.years,
+                                 months=other.months + self.months,
+                                 days=other.days + self.days,
+                                 hours=other.hours + self.hours,
+                                 minutes=other.minutes + self.minutes,
+                                 seconds=other.seconds + self.seconds,
+                                 microseconds=(other.microseconds +
+                                               self.microseconds),
+                                 leapdays=other.leapdays or self.leapdays,
+                                 year=(other.year if other.year is not None
+                                       else self.year),
+                                 month=(other.month if other.month is not None
+                                        else self.month),
+                                 day=(other.day if other.day is not None
+                                      else self.day),
+                                 weekday=(other.weekday if other.weekday is not None
+                                          else self.weekday),
+                                 hour=(other.hour if other.hour is not None
+                                       else self.hour),
+                                 minute=(other.minute if other.minute is not None
+                                         else self.minute),
+                                 second=(other.second if other.second is not None
+                                         else self.second),
+                                 microsecond=(other.microsecond if other.microsecond
+                                              is not None else
+                                              self.microsecond))
+        if isinstance(other, datetime.timedelta):
+            return self.__class__(years=self.years,
+                                  months=self.months,
+                                  days=self.days + other.days,
+                                  hours=self.hours,
+                                  minutes=self.minutes,
+                                  seconds=self.seconds + other.seconds,
+                                  microseconds=self.microseconds + other.microseconds,
+                                  leapdays=self.leapdays,
+                                  year=self.year,
+                                  month=self.month,
+                                  day=self.day,
+                                  weekday=self.weekday,
+                                  hour=self.hour,
+                                  minute=self.minute,
+                                  second=self.second,
+                                  microsecond=self.microsecond)
+        if not isinstance(other, datetime.date):
+            return NotImplemented
+        elif self._has_time and not isinstance(other, datetime.datetime):
+            other = datetime.datetime.fromordinal(other.toordinal())
+        year = (self.year or other.year)+self.years
+        month = self.month or other.month
+        if self.months:
+            assert 1 <= abs(self.months) <= 12
+            month += self.months
+            if month > 12:
+                year += 1
+                month -= 12
+            elif month < 1:
+                year -= 1
+                month += 12
+        day = min(calendar.monthrange(year, month)[1],
+                  self.day or other.day)
+        repl = {"year": year, "month": month, "day": day}
+        for attr in ["hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value is not None:
+                repl[attr] = value
+        days = self.days
+        if self.leapdays and month > 2 and calendar.isleap(year):
+            days += self.leapdays
+        ret = (other.replace(**repl)
+               + datetime.timedelta(days=days,
+                                    hours=self.hours,
+                                    minutes=self.minutes,
+                                    seconds=self.seconds,
+                                    microseconds=self.microseconds))
+        if self.weekday:
+            weekday, nth = self.weekday.weekday, self.weekday.n or 1
+            jumpdays = (abs(nth) - 1) * 7
+            if nth > 0:
+                jumpdays += (7 - ret.weekday() + weekday) % 7
+            else:
+                jumpdays += (ret.weekday() - weekday) % 7
+                jumpdays *= -1
+            ret += datetime.timedelta(days=jumpdays)
+        return ret
+
+    def __radd__(self, other):
+        return self.__add__(other)
+
+    def __rsub__(self, other):
+        return self.__neg__().__radd__(other)
+
+    def __sub__(self, other):
+        if not isinstance(other, relativedelta):
+            return NotImplemented   # In case the other object defines __rsub__
+        return self.__class__(years=self.years - other.years,
+                             months=self.months - other.months,
+                             days=self.days - other.days,
+                             hours=self.hours - other.hours,
+                             minutes=self.minutes - other.minutes,
+                             seconds=self.seconds - other.seconds,
+                             microseconds=self.microseconds - other.microseconds,
+                             leapdays=self.leapdays or other.leapdays,
+                             year=(self.year if self.year is not None
+                                   else other.year),
+                             month=(self.month if self.month is not None else
+                                    other.month),
+                             day=(self.day if self.day is not None else
+                                  other.day),
+                             weekday=(self.weekday if self.weekday is not None else
+                                      other.weekday),
+                             hour=(self.hour if self.hour is not None else
+                                   other.hour),
+                             minute=(self.minute if self.minute is not None else
+                                     other.minute),
+                             second=(self.second if self.second is not None else
+                                     other.second),
+                             microsecond=(self.microsecond if self.microsecond
+                                          is not None else
+                                          other.microsecond))
+
+    def __abs__(self):
+        return self.__class__(years=abs(self.years),
+                              months=abs(self.months),
+                              days=abs(self.days),
+                              hours=abs(self.hours),
+                              minutes=abs(self.minutes),
+                              seconds=abs(self.seconds),
+                              microseconds=abs(self.microseconds),
+                              leapdays=self.leapdays,
+                              year=self.year,
+                              month=self.month,
+                              day=self.day,
+                              weekday=self.weekday,
+                              hour=self.hour,
+                              minute=self.minute,
+                              second=self.second,
+                              microsecond=self.microsecond)
+
+    def __neg__(self):
+        return self.__class__(years=-self.years,
+                             months=-self.months,
+                             days=-self.days,
+                             hours=-self.hours,
+                             minutes=-self.minutes,
+                             seconds=-self.seconds,
+                             microseconds=-self.microseconds,
+                             leapdays=self.leapdays,
+                             year=self.year,
+                             month=self.month,
+                             day=self.day,
+                             weekday=self.weekday,
+                             hour=self.hour,
+                             minute=self.minute,
+                             second=self.second,
+                             microsecond=self.microsecond)
+
+    def __bool__(self):
+        return not (not self.years and
+                    not self.months and
+                    not self.days and
+                    not self.hours and
+                    not self.minutes and
+                    not self.seconds and
+                    not self.microseconds and
+                    not self.leapdays and
+                    self.year is None and
+                    self.month is None and
+                    self.day is None and
+                    self.weekday is None and
+                    self.hour is None and
+                    self.minute is None and
+                    self.second is None and
+                    self.microsecond is None)
+    # Compatibility with Python 2.x
+    __nonzero__ = __bool__
+
+    def __mul__(self, other):
+        try:
+            f = float(other)
+        except TypeError:
+            return NotImplemented
+
+        return self.__class__(years=int(self.years * f),
+                             months=int(self.months * f),
+                             days=int(self.days * f),
+                             hours=int(self.hours * f),
+                             minutes=int(self.minutes * f),
+                             seconds=int(self.seconds * f),
+                             microseconds=int(self.microseconds * f),
+                             leapdays=self.leapdays,
+                             year=self.year,
+                             month=self.month,
+                             day=self.day,
+                             weekday=self.weekday,
+                             hour=self.hour,
+                             minute=self.minute,
+                             second=self.second,
+                             microsecond=self.microsecond)
+
+    __rmul__ = __mul__
+
+    def __eq__(self, other):
+        if not isinstance(other, relativedelta):
+            return NotImplemented
+        if self.weekday or other.weekday:
+            if not self.weekday or not other.weekday:
+                return False
+            if self.weekday.weekday != other.weekday.weekday:
+                return False
+            n1, n2 = self.weekday.n, other.weekday.n
+            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
+                return False
+        return (self.years == other.years and
+                self.months == other.months and
+                self.days == other.days and
+                self.hours == other.hours and
+                self.minutes == other.minutes and
+                self.seconds == other.seconds and
+                self.microseconds == other.microseconds and
+                self.leapdays == other.leapdays and
+                self.year == other.year and
+                self.month == other.month and
+                self.day == other.day and
+                self.hour == other.hour and
+                self.minute == other.minute and
+                self.second == other.second and
+                self.microsecond == other.microsecond)
+
+    def __hash__(self):
+        return hash((
+            self.weekday,
+            self.years,
+            self.months,
+            self.days,
+            self.hours,
+            self.minutes,
+            self.seconds,
+            self.microseconds,
+            self.leapdays,
+            self.year,
+            self.month,
+            self.day,
+            self.hour,
+            self.minute,
+            self.second,
+            self.microsecond,
+        ))
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __div__(self, other):
+        try:
+            reciprocal = 1 / float(other)
+        except TypeError:
+            return NotImplemented
+
+        return self.__mul__(reciprocal)
+
+    __truediv__ = __div__
+
+    def __repr__(self):
+        l = []
+        for attr in ["years", "months", "days", "leapdays",
+                     "hours", "minutes", "seconds", "microseconds"]:
+            value = getattr(self, attr)
+            if value:
+                l.append("{attr}={value:+g}".format(attr=attr, value=value))
+        for attr in ["year", "month", "day", "weekday",
+                     "hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("{attr}={value}".format(attr=attr, value=repr(value)))
+        return "{classname}({attrs})".format(classname=self.__class__.__name__,
+                                             attrs=", ".join(l))
+
+
+def _sign(x):
+    return int(copysign(1, x))
+
+# vim:ts=4:sw=4:et
diff --git a/Lib/site-packages/dateutil/rrule.py b/Lib/site-packages/dateutil/rrule.py
new file mode 100644
index 0000000..571a0d2
--- /dev/null
+++ b/Lib/site-packages/dateutil/rrule.py
@@ -0,0 +1,1737 @@
+# -*- coding: utf-8 -*-
+"""
+The rrule module offers a small, complete, and very fast, implementation of
+the recurrence rules documented in the
+`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,
+including support for caching of results.
+"""
+import calendar
+import datetime
+import heapq
+import itertools
+import re
+import sys
+from functools import wraps
+# For warning about deprecation of until and count
+from warnings import warn
+
+from six import advance_iterator, integer_types
+
+from six.moves import _thread, range
+
+from ._common import weekday as weekdaybase
+
+try:
+    from math import gcd
+except ImportError:
+    from fractions import gcd
+
+__all__ = ["rrule", "rruleset", "rrulestr",
+           "YEARLY", "MONTHLY", "WEEKLY", "DAILY",
+           "HOURLY", "MINUTELY", "SECONDLY",
+           "MO", "TU", "WE", "TH", "FR", "SA", "SU"]
+
+# Every mask is 7 days longer to handle cross-year weekly periods.
+M366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30 +
+                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)
+M365MASK = list(M366MASK)
+M29, M30, M31 = list(range(1, 30)), list(range(1, 31)), list(range(1, 32))
+MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
+MDAY365MASK = list(MDAY366MASK)
+M29, M30, M31 = list(range(-29, 0)), list(range(-30, 0)), list(range(-31, 0))
+NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
+NMDAY365MASK = list(NMDAY366MASK)
+M366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)
+M365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)
+WDAYMASK = [0, 1, 2, 3, 4, 5, 6]*55
+del M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]
+MDAY365MASK = tuple(MDAY365MASK)
+M365MASK = tuple(M365MASK)
+
+FREQNAMES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY']
+
+(YEARLY,
+ MONTHLY,
+ WEEKLY,
+ DAILY,
+ HOURLY,
+ MINUTELY,
+ SECONDLY) = list(range(7))
+
+# Imported on demand.
+easter = None
+parser = None
+
+
+class weekday(weekdaybase):
+    """
+    This version of weekday does not allow n = 0.
+    """
+    def __init__(self, wkday, n=None):
+        if n == 0:
+            raise ValueError("Can't create weekday with n==0")
+
+        super(weekday, self).__init__(wkday, n)
+
+
+MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))
+
+
+def _invalidates_cache(f):
+    """
+    Decorator for rruleset methods which may invalidate the
+    cached length.
+    """
+    @wraps(f)
+    def inner_func(self, *args, **kwargs):
+        rv = f(self, *args, **kwargs)
+        self._invalidate_cache()
+        return rv
+
+    return inner_func
+
+
+class rrulebase(object):
+    def __init__(self, cache=False):
+        if cache:
+            self._cache = []
+            self._cache_lock = _thread.allocate_lock()
+            self._invalidate_cache()
+        else:
+            self._cache = None
+            self._cache_complete = False
+            self._len = None
+
+    def __iter__(self):
+        if self._cache_complete:
+            return iter(self._cache)
+        elif self._cache is None:
+            return self._iter()
+        else:
+            return self._iter_cached()
+
+    def _invalidate_cache(self):
+        if self._cache is not None:
+            self._cache = []
+            self._cache_complete = False
+            self._cache_gen = self._iter()
+
+            if self._cache_lock.locked():
+                self._cache_lock.release()
+
+        self._len = None
+
+    def _iter_cached(self):
+        i = 0
+        gen = self._cache_gen
+        cache = self._cache
+        acquire = self._cache_lock.acquire
+        release = self._cache_lock.release
+        while gen:
+            if i == len(cache):
+                acquire()
+                if self._cache_complete:
+                    break
+                try:
+                    for j in range(10):
+                        cache.append(advance_iterator(gen))
+                except StopIteration:
+                    self._cache_gen = gen = None
+                    self._cache_complete = True
+                    break
+                release()
+            yield cache[i]
+            i += 1
+        while i < self._len:
+            yield cache[i]
+            i += 1
+
+    def __getitem__(self, item):
+        if self._cache_complete:
+            return self._cache[item]
+        elif isinstance(item, slice):
+            if item.step and item.step < 0:
+                return list(iter(self))[item]
+            else:
+                return list(itertools.islice(self,
+                                             item.start or 0,
+                                             item.stop or sys.maxsize,
+                                             item.step or 1))
+        elif item >= 0:
+            gen = iter(self)
+            try:
+                for i in range(item+1):
+                    res = advance_iterator(gen)
+            except StopIteration:
+                raise IndexError
+            return res
+        else:
+            return list(iter(self))[item]
+
+    def __contains__(self, item):
+        if self._cache_complete:
+            return item in self._cache
+        else:
+            for i in self:
+                if i == item:
+                    return True
+                elif i > item:
+                    return False
+        return False
+
+    # __len__() introduces a large performance penalty.
+    def count(self):
+        """ Returns the number of recurrences in this set. It will have go
+            through the whole recurrence, if this hasn't been done before. """
+        if self._len is None:
+            for x in self:
+                pass
+        return self._len
+
+    def before(self, dt, inc=False):
+        """ Returns the last recurrence before the given datetime instance. The
+            inc keyword defines what happens if dt is an occurrence. With
+            inc=True, if dt itself is an occurrence, it will be returned. """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        last = None
+        if inc:
+            for i in gen:
+                if i > dt:
+                    break
+                last = i
+        else:
+            for i in gen:
+                if i >= dt:
+                    break
+                last = i
+        return last
+
+    def after(self, dt, inc=False):
+        """ Returns the first recurrence after the given datetime instance. The
+            inc keyword defines what happens if dt is an occurrence. With
+            inc=True, if dt itself is an occurrence, it will be returned.  """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        if inc:
+            for i in gen:
+                if i >= dt:
+                    return i
+        else:
+            for i in gen:
+                if i > dt:
+                    return i
+        return None
+
+    def xafter(self, dt, count=None, inc=False):
+        """
+        Generator which yields up to `count` recurrences after the given
+        datetime instance, equivalent to `after`.
+
+        :param dt:
+            The datetime at which to start generating recurrences.
+
+        :param count:
+            The maximum number of recurrences to generate. If `None` (default),
+            dates are generated until the recurrence rule is exhausted.
+
+        :param inc:
+            If `dt` is an instance of the rule and `inc` is `True`, it is
+            included in the output.
+
+        :yields: Yields a sequence of `datetime` objects.
+        """
+
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+
+        # Select the comparison function
+        if inc:
+            comp = lambda dc, dtc: dc >= dtc
+        else:
+            comp = lambda dc, dtc: dc > dtc
+
+        # Generate dates
+        n = 0
+        for d in gen:
+            if comp(d, dt):
+                if count is not None:
+                    n += 1
+                    if n > count:
+                        break
+
+                yield d
+
+    def between(self, after, before, inc=False, count=1):
+        """ Returns all the occurrences of the rrule between after and before.
+        The inc keyword defines what happens if after and/or before are
+        themselves occurrences. With inc=True, they will be included in the
+        list, if they are found in the recurrence set. """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        started = False
+        l = []
+        if inc:
+            for i in gen:
+                if i > before:
+                    break
+                elif not started:
+                    if i >= after:
+                        started = True
+                        l.append(i)
+                else:
+                    l.append(i)
+        else:
+            for i in gen:
+                if i >= before:
+                    break
+                elif not started:
+                    if i > after:
+                        started = True
+                        l.append(i)
+                else:
+                    l.append(i)
+        return l
+
+
+class rrule(rrulebase):
+    """
+    That's the base of the rrule operation. It accepts all the keywords
+    defined in the RFC as its constructor parameters (except byday,
+    which was renamed to byweekday) and more. The constructor prototype is::
+
+            rrule(freq)
+
+    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
+    or SECONDLY.
+
+    .. note::
+        Per RFC section 3.3.10, recurrence instances falling on invalid dates
+        and times are ignored rather than coerced:
+
+            Recurrence rules may generate recurrence instances with an invalid
+            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
+            on a day where the local time is moved forward by an hour at 1:00
+            AM).  Such recurrence instances MUST be ignored and MUST NOT be
+            counted as part of the recurrence set.
+
+        This can lead to possibly surprising behavior when, for example, the
+        start date occurs at the end of the month:
+
+        >>> from dateutil.rrule import rrule, MONTHLY
+        >>> from datetime import datetime
+        >>> start_date = datetime(2014, 12, 31)
+        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
+        ... # doctest: +NORMALIZE_WHITESPACE
+        [datetime.datetime(2014, 12, 31, 0, 0),
+         datetime.datetime(2015, 1, 31, 0, 0),
+         datetime.datetime(2015, 3, 31, 0, 0),
+         datetime.datetime(2015, 5, 31, 0, 0)]
+
+    Additionally, it supports the following keyword arguments:
+
+    :param dtstart:
+        The recurrence start. Besides being the base for the recurrence,
+        missing parameters in the final recurrence instances will also be
+        extracted from this date. If not given, datetime.now() will be used
+        instead.
+    :param interval:
+        The interval between each freq iteration. For example, when using
+        YEARLY, an interval of 2 means once every two years, but with HOURLY,
+        it means once every two hours. The default interval is 1.
+    :param wkst:
+        The week start day. Must be one of the MO, TU, WE constants, or an
+        integer, specifying the first day of the week. This will affect
+        recurrences based on weekly periods. The default week start is got
+        from calendar.firstweekday(), and may be modified by
+        calendar.setfirstweekday().
+    :param count:
+        If given, this determines how many occurrences will be generated.
+
+        .. note::
+            As of version 2.5.0, the use of the keyword ``until`` in conjunction
+            with ``count`` is deprecated, to make sure ``dateutil`` is fully
+            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+            **must not** occur in the same call to ``rrule``.
+    :param until:
+        If given, this must be a datetime instance specifying the upper-bound
+        limit of the recurrence. The last recurrence in the rule is the greatest
+        datetime that is less than or equal to the value specified in the
+        ``until`` parameter.
+
+        .. note::
+            As of version 2.5.0, the use of the keyword ``until`` in conjunction
+            with ``count`` is deprecated, to make sure ``dateutil`` is fully
+            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+            **must not** occur in the same call to ``rrule``.
+    :param bysetpos:
+        If given, it must be either an integer, or a sequence of integers,
+        positive or negative. Each given integer will specify an occurrence
+        number, corresponding to the nth occurrence of the rule inside the
+        frequency period. For example, a bysetpos of -1 if combined with a
+        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will
+        result in the last work day of every month.
+    :param bymonth:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the months to apply the recurrence to.
+    :param bymonthday:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the month days to apply the recurrence to.
+    :param byyearday:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the year days to apply the recurrence to.
+    :param byeaster:
+        If given, it must be either an integer, or a sequence of integers,
+        positive or negative. Each integer will define an offset from the
+        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
+        Sunday itself. This is an extension to the RFC specification.
+    :param byweekno:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the week numbers to apply the recurrence to. Week numbers
+        have the meaning described in ISO8601, that is, the first week of
+        the year is that containing at least four days of the new year.
+    :param byweekday:
+        If given, it must be either an integer (0 == MO), a sequence of
+        integers, one of the weekday constants (MO, TU, etc), or a sequence
+        of these constants. When given, these variables will define the
+        weekdays where the recurrence will be applied. It's also possible to
+        use an argument n for the weekday instances, which will mean the nth
+        occurrence of this weekday in the period. For example, with MONTHLY,
+        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the
+        first friday of the month where the recurrence happens. Notice that in
+        the RFC documentation, this is specified as BYDAY, but was renamed to
+        avoid the ambiguity of that keyword.
+    :param byhour:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the hours to apply the recurrence to.
+    :param byminute:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the minutes to apply the recurrence to.
+    :param bysecond:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the seconds to apply the recurrence to.
+    :param cache:
+        If given, it must be a boolean value specifying to enable or disable
+        caching of results. If you will use the same rrule instance multiple
+        times, enabling caching will improve the performance considerably.
+     """
+    def __init__(self, freq, dtstart=None,
+                 interval=1, wkst=None, count=None, until=None, bysetpos=None,
+                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
+                 byweekno=None, byweekday=None,
+                 byhour=None, byminute=None, bysecond=None,
+                 cache=False):
+        super(rrule, self).__init__(cache)
+        global easter
+        if not dtstart:
+            if until and until.tzinfo:
+                dtstart = datetime.datetime.now(tz=until.tzinfo).replace(microsecond=0)
+            else:
+                dtstart = datetime.datetime.now().replace(microsecond=0)
+        elif not isinstance(dtstart, datetime.datetime):
+            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())
+        else:
+            dtstart = dtstart.replace(microsecond=0)
+        self._dtstart = dtstart
+        self._tzinfo = dtstart.tzinfo
+        self._freq = freq
+        self._interval = interval
+        self._count = count
+
+        # Cache the original byxxx rules, if they are provided, as the _byxxx
+        # attributes do not necessarily map to the inputs, and this can be
+        # a problem in generating the strings. Only store things if they've
+        # been supplied (the string retrieval will just use .get())
+        self._original_rule = {}
+
+        if until and not isinstance(until, datetime.datetime):
+            until = datetime.datetime.fromordinal(until.toordinal())
+        self._until = until
+
+        if self._dtstart and self._until:
+            if (self._dtstart.tzinfo is not None) != (self._until.tzinfo is not None):
+                # According to RFC5545 Section 3.3.10:
+                # https://tools.ietf.org/html/rfc5545#section-3.3.10
+                #
+                # > If the "DTSTART" property is specified as a date with UTC
+                # > time or a date with local time and time zone reference,
+                # > then the UNTIL rule part MUST be specified as a date with
+                # > UTC time.
+                raise ValueError(
+                    'RRULE UNTIL values must be specified in UTC when DTSTART '
+                    'is timezone-aware'
+                )
+
+        if count is not None and until:
+            warn("Using both 'count' and 'until' is inconsistent with RFC 5545"
+                 " and has been deprecated in dateutil. Future versions will "
+                 "raise an error.", DeprecationWarning)
+
+        if wkst is None:
+            self._wkst = calendar.firstweekday()
+        elif isinstance(wkst, integer_types):
+            self._wkst = wkst
+        else:
+            self._wkst = wkst.weekday
+
+        if bysetpos is None:
+            self._bysetpos = None
+        elif isinstance(bysetpos, integer_types):
+            if bysetpos == 0 or not (-366 <= bysetpos <= 366):
+                raise ValueError("bysetpos must be between 1 and 366, "
+                                 "or between -366 and -1")
+            self._bysetpos = (bysetpos,)
+        else:
+            self._bysetpos = tuple(bysetpos)
+            for pos in self._bysetpos:
+                if pos == 0 or not (-366 <= pos <= 366):
+                    raise ValueError("bysetpos must be between 1 and 366, "
+                                     "or between -366 and -1")
+
+        if self._bysetpos:
+            self._original_rule['bysetpos'] = self._bysetpos
+
+        if (byweekno is None and byyearday is None and bymonthday is None and
+                byweekday is None and byeaster is None):
+            if freq == YEARLY:
+                if bymonth is None:
+                    bymonth = dtstart.month
+                    self._original_rule['bymonth'] = None
+                bymonthday = dtstart.day
+                self._original_rule['bymonthday'] = None
+            elif freq == MONTHLY:
+                bymonthday = dtstart.day
+                self._original_rule['bymonthday'] = None
+            elif freq == WEEKLY:
+                byweekday = dtstart.weekday()
+                self._original_rule['byweekday'] = None
+
+        # bymonth
+        if bymonth is None:
+            self._bymonth = None
+        else:
+            if isinstance(bymonth, integer_types):
+                bymonth = (bymonth,)
+
+            self._bymonth = tuple(sorted(set(bymonth)))
+
+            if 'bymonth' not in self._original_rule:
+                self._original_rule['bymonth'] = self._bymonth
+
+        # byyearday
+        if byyearday is None:
+            self._byyearday = None
+        else:
+            if isinstance(byyearday, integer_types):
+                byyearday = (byyearday,)
+
+            self._byyearday = tuple(sorted(set(byyearday)))
+            self._original_rule['byyearday'] = self._byyearday
+
+        # byeaster
+        if byeaster is not None:
+            if not easter:
+                from dateutil import easter
+            if isinstance(byeaster, integer_types):
+                self._byeaster = (byeaster,)
+            else:
+                self._byeaster = tuple(sorted(byeaster))
+
+            self._original_rule['byeaster'] = self._byeaster
+        else:
+            self._byeaster = None
+
+        # bymonthday
+        if bymonthday is None:
+            self._bymonthday = ()
+            self._bynmonthday = ()
+        else:
+            if isinstance(bymonthday, integer_types):
+                bymonthday = (bymonthday,)
+
+            bymonthday = set(bymonthday)            # Ensure it's unique
+
+            self._bymonthday = tuple(sorted(x for x in bymonthday if x > 0))
+            self._bynmonthday = tuple(sorted(x for x in bymonthday if x < 0))
+
+            # Storing positive numbers first, then negative numbers
+            if 'bymonthday' not in self._original_rule:
+                self._original_rule['bymonthday'] = tuple(
+                    itertools.chain(self._bymonthday, self._bynmonthday))
+
+        # byweekno
+        if byweekno is None:
+            self._byweekno = None
+        else:
+            if isinstance(byweekno, integer_types):
+                byweekno = (byweekno,)
+
+            self._byweekno = tuple(sorted(set(byweekno)))
+
+            self._original_rule['byweekno'] = self._byweekno
+
+        # byweekday / bynweekday
+        if byweekday is None:
+            self._byweekday = None
+            self._bynweekday = None
+        else:
+            # If it's one of the valid non-sequence types, convert to a
+            # single-element sequence before the iterator that builds the
+            # byweekday set.
+            if isinstance(byweekday, integer_types) or hasattr(byweekday, "n"):
+                byweekday = (byweekday,)
+
+            self._byweekday = set()
+            self._bynweekday = set()
+            for wday in byweekday:
+                if isinstance(wday, integer_types):
+                    self._byweekday.add(wday)
+                elif not wday.n or freq > MONTHLY:
+                    self._byweekday.add(wday.weekday)
+                else:
+                    self._bynweekday.add((wday.weekday, wday.n))
+
+            if not self._byweekday:
+                self._byweekday = None
+            elif not self._bynweekday:
+                self._bynweekday = None
+
+            if self._byweekday is not None:
+                self._byweekday = tuple(sorted(self._byweekday))
+                orig_byweekday = [weekday(x) for x in self._byweekday]
+            else:
+                orig_byweekday = ()
+
+            if self._bynweekday is not None:
+                self._bynweekday = tuple(sorted(self._bynweekday))
+                orig_bynweekday = [weekday(*x) for x in self._bynweekday]
+            else:
+                orig_bynweekday = ()
+
+            if 'byweekday' not in self._original_rule:
+                self._original_rule['byweekday'] = tuple(itertools.chain(
+                    orig_byweekday, orig_bynweekday))
+
+        # byhour
+        if byhour is None:
+            if freq < HOURLY:
+                self._byhour = {dtstart.hour}
+            else:
+                self._byhour = None
+        else:
+            if isinstance(byhour, integer_types):
+                byhour = (byhour,)
+
+            if freq == HOURLY:
+                self._byhour = self.__construct_byset(start=dtstart.hour,
+                                                      byxxx=byhour,
+                                                      base=24)
+            else:
+                self._byhour = set(byhour)
+
+            self._byhour = tuple(sorted(self._byhour))
+            self._original_rule['byhour'] = self._byhour
+
+        # byminute
+        if byminute is None:
+            if freq < MINUTELY:
+                self._byminute = {dtstart.minute}
+            else:
+                self._byminute = None
+        else:
+            if isinstance(byminute, integer_types):
+                byminute = (byminute,)
+
+            if freq == MINUTELY:
+                self._byminute = self.__construct_byset(start=dtstart.minute,
+                                                        byxxx=byminute,
+                                                        base=60)
+            else:
+                self._byminute = set(byminute)
+
+            self._byminute = tuple(sorted(self._byminute))
+            self._original_rule['byminute'] = self._byminute
+
+        # bysecond
+        if bysecond is None:
+            if freq < SECONDLY:
+                self._bysecond = ((dtstart.second,))
+            else:
+                self._bysecond = None
+        else:
+            if isinstance(bysecond, integer_types):
+                bysecond = (bysecond,)
+
+            self._bysecond = set(bysecond)
+
+            if freq == SECONDLY:
+                self._bysecond = self.__construct_byset(start=dtstart.second,
+                                                        byxxx=bysecond,
+                                                        base=60)
+            else:
+                self._bysecond = set(bysecond)
+
+            self._bysecond = tuple(sorted(self._bysecond))
+            self._original_rule['bysecond'] = self._bysecond
+
+        if self._freq >= HOURLY:
+            self._timeset = None
+        else:
+            self._timeset = []
+            for hour in self._byhour:
+                for minute in self._byminute:
+                    for second in self._bysecond:
+                        self._timeset.append(
+                            datetime.time(hour, minute, second,
+                                          tzinfo=self._tzinfo))
+            self._timeset.sort()
+            self._timeset = tuple(self._timeset)
+
+    def __str__(self):
+        """
+        Output a string that would generate this RRULE if passed to rrulestr.
+        This is mostly compatible with RFC5545, except for the
+        dateutil-specific extension BYEASTER.
+        """
+
+        output = []
+        h, m, s = [None] * 3
+        if self._dtstart:
+            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))
+            h, m, s = self._dtstart.timetuple()[3:6]
+
+        parts = ['FREQ=' + FREQNAMES[self._freq]]
+        if self._interval != 1:
+            parts.append('INTERVAL=' + str(self._interval))
+
+        if self._wkst:
+            parts.append('WKST=' + repr(weekday(self._wkst))[0:2])
+
+        if self._count is not None:
+            parts.append('COUNT=' + str(self._count))
+
+        if self._until:
+            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))
+
+        if self._original_rule.get('byweekday') is not None:
+            # The str() method on weekday objects doesn't generate
+            # RFC5545-compliant strings, so we should modify that.
+            original_rule = dict(self._original_rule)
+            wday_strings = []
+            for wday in original_rule['byweekday']:
+                if wday.n:
+                    wday_strings.append('{n:+d}{wday}'.format(
+                        n=wday.n,
+                        wday=repr(wday)[0:2]))
+                else:
+                    wday_strings.append(repr(wday))
+
+            original_rule['byweekday'] = wday_strings
+        else:
+            original_rule = self._original_rule
+
+        partfmt = '{name}={vals}'
+        for name, key in [('BYSETPOS', 'bysetpos'),
+                          ('BYMONTH', 'bymonth'),
+                          ('BYMONTHDAY', 'bymonthday'),
+                          ('BYYEARDAY', 'byyearday'),
+                          ('BYWEEKNO', 'byweekno'),
+                          ('BYDAY', 'byweekday'),
+                          ('BYHOUR', 'byhour'),
+                          ('BYMINUTE', 'byminute'),
+                          ('BYSECOND', 'bysecond'),
+                          ('BYEASTER', 'byeaster')]:
+            value = original_rule.get(key)
+            if value:
+                parts.append(partfmt.format(name=name, vals=(','.join(str(v)
+                                                             for v in value))))
+
+        output.append('RRULE:' + ';'.join(parts))
+        return '\n'.join(output)
+
+    def replace(self, **kwargs):
+        """Return new rrule with same attributes except for those attributes given new
+           values by whichever keyword arguments are specified."""
+        new_kwargs = {"interval": self._interval,
+                      "count": self._count,
+                      "dtstart": self._dtstart,
+                      "freq": self._freq,
+                      "until": self._until,
+                      "wkst": self._wkst,
+                      "cache": False if self._cache is None else True }
+        new_kwargs.update(self._original_rule)
+        new_kwargs.update(kwargs)
+        return rrule(**new_kwargs)
+
+    def _iter(self):
+        year, month, day, hour, minute, second, weekday, yearday, _ = \
+            self._dtstart.timetuple()
+
+        # Some local variables to speed things up a bit
+        freq = self._freq
+        interval = self._interval
+        wkst = self._wkst
+        until = self._until
+        bymonth = self._bymonth
+        byweekno = self._byweekno
+        byyearday = self._byyearday
+        byweekday = self._byweekday
+        byeaster = self._byeaster
+        bymonthday = self._bymonthday
+        bynmonthday = self._bynmonthday
+        bysetpos = self._bysetpos
+        byhour = self._byhour
+        byminute = self._byminute
+        bysecond = self._bysecond
+
+        ii = _iterinfo(self)
+        ii.rebuild(year, month)
+
+        getdayset = {YEARLY: ii.ydayset,
+                     MONTHLY: ii.mdayset,
+                     WEEKLY: ii.wdayset,
+                     DAILY: ii.ddayset,
+                     HOURLY: ii.ddayset,
+                     MINUTELY: ii.ddayset,
+                     SECONDLY: ii.ddayset}[freq]
+
+        if freq < HOURLY:
+            timeset = self._timeset
+        else:
+            gettimeset = {HOURLY: ii.htimeset,
+                          MINUTELY: ii.mtimeset,
+                          SECONDLY: ii.stimeset}[freq]
+            if ((freq >= HOURLY and
+                 self._byhour and hour not in self._byhour) or
+                (freq >= MINUTELY and
+                 self._byminute and minute not in self._byminute) or
+                (freq >= SECONDLY and
+                 self._bysecond and second not in self._bysecond)):
+                timeset = ()
+            else:
+                timeset = gettimeset(hour, minute, second)
+
+        total = 0
+        count = self._count
+        while True:
+            # Get dayset with the right frequency
+            dayset, start, end = getdayset(year, month, day)
+
+            # Do the "hard" work ;-)
+            filtered = False
+            for i in dayset[start:end]:
+                if ((bymonth and ii.mmask[i] not in bymonth) or
+                    (byweekno and not ii.wnomask[i]) or
+                    (byweekday and ii.wdaymask[i] not in byweekday) or
+                    (ii.nwdaymask and not ii.nwdaymask[i]) or
+                    (byeaster and not ii.eastermask[i]) or
+                    ((bymonthday or bynmonthday) and
+                     ii.mdaymask[i] not in bymonthday and
+                     ii.nmdaymask[i] not in bynmonthday) or
+                    (byyearday and
+                     ((i < ii.yearlen and i+1 not in byyearday and
+                       -ii.yearlen+i not in byyearday) or
+                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and
+                       -ii.nextyearlen+i-ii.yearlen not in byyearday)))):
+                    dayset[i] = None
+                    filtered = True
+
+            # Output results
+            if bysetpos and timeset:
+                poslist = []
+                for pos in bysetpos:
+                    if pos < 0:
+                        daypos, timepos = divmod(pos, len(timeset))
+                    else:
+                        daypos, timepos = divmod(pos-1, len(timeset))
+                    try:
+                        i = [x for x in dayset[start:end]
+                             if x is not None][daypos]
+                        time = timeset[timepos]
+                    except IndexError:
+                        pass
+                    else:
+                        date = datetime.date.fromordinal(ii.yearordinal+i)
+                        res = datetime.datetime.combine(date, time)
+                        if res not in poslist:
+                            poslist.append(res)
+                poslist.sort()
+                for res in poslist:
+                    if until and res > until:
+                        self._len = total
+                        return
+                    elif res >= self._dtstart:
+                        if count is not None:
+                            count -= 1
+                            if count < 0:
+                                self._len = total
+                                return
+                        total += 1
+                        yield res
+            else:
+                for i in dayset[start:end]:
+                    if i is not None:
+                        date = datetime.date.fromordinal(ii.yearordinal + i)
+                        for time in timeset:
+                            res = datetime.datetime.combine(date, time)
+                            if until and res > until:
+                                self._len = total
+                                return
+                            elif res >= self._dtstart:
+                                if count is not None:
+                                    count -= 1
+                                    if count < 0:
+                                        self._len = total
+                                        return
+
+                                total += 1
+                                yield res
+
+            # Handle frequency and interval
+            fixday = False
+            if freq == YEARLY:
+                year += interval
+                if year > datetime.MAXYEAR:
+                    self._len = total
+                    return
+                ii.rebuild(year, month)
+            elif freq == MONTHLY:
+                month += interval
+                if month > 12:
+                    div, mod = divmod(month, 12)
+                    month = mod
+                    year += div
+                    if month == 0:
+                        month = 12
+                        year -= 1
+                    if year > datetime.MAXYEAR:
+                        self._len = total
+                        return
+                ii.rebuild(year, month)
+            elif freq == WEEKLY:
+                if wkst > weekday:
+                    day += -(weekday+1+(6-wkst))+self._interval*7
+                else:
+                    day += -(weekday-wkst)+self._interval*7
+                weekday = wkst
+                fixday = True
+            elif freq == DAILY:
+                day += interval
+                fixday = True
+            elif freq == HOURLY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    hour += ((23-hour)//interval)*interval
+
+                if byhour:
+                    ndays, hour = self.__mod_distance(value=hour,
+                                                      byxxx=self._byhour,
+                                                      base=24)
+                else:
+                    ndays, hour = divmod(hour+interval, 24)
+
+                if ndays:
+                    day += ndays
+                    fixday = True
+
+                timeset = gettimeset(hour, minute, second)
+            elif freq == MINUTELY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    minute += ((1439-(hour*60+minute))//interval)*interval
+
+                valid = False
+                rep_rate = (24*60)
+                for j in range(rep_rate // gcd(interval, rep_rate)):
+                    if byminute:
+                        nhours, minute = \
+                            self.__mod_distance(value=minute,
+                                                byxxx=self._byminute,
+                                                base=60)
+                    else:
+                        nhours, minute = divmod(minute+interval, 60)
+
+                    div, hour = divmod(hour+nhours, 24)
+                    if div:
+                        day += div
+                        fixday = True
+                        filtered = False
+
+                    if not byhour or hour in byhour:
+                        valid = True
+                        break
+
+                if not valid:
+                    raise ValueError('Invalid combination of interval and ' +
+                                     'byhour resulting in empty rule.')
+
+                timeset = gettimeset(hour, minute, second)
+            elif freq == SECONDLY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    second += (((86399 - (hour * 3600 + minute * 60 + second))
+                                // interval) * interval)
+
+                rep_rate = (24 * 3600)
+                valid = False
+                for j in range(0, rep_rate // gcd(interval, rep_rate)):
+                    if bysecond:
+                        nminutes, second = \
+                            self.__mod_distance(value=second,
+                                                byxxx=self._bysecond,
+                                                base=60)
+                    else:
+                        nminutes, second = divmod(second+interval, 60)
+
+                    div, minute = divmod(minute+nminutes, 60)
+                    if div:
+                        hour += div
+                        div, hour = divmod(hour, 24)
+                        if div:
+                            day += div
+                            fixday = True
+
+                    if ((not byhour or hour in byhour) and
+                            (not byminute or minute in byminute) and
+                            (not bysecond or second in bysecond)):
+                        valid = True
+                        break
+
+                if not valid:
+                    raise ValueError('Invalid combination of interval, ' +
+                                     'byhour and byminute resulting in empty' +
+                                     ' rule.')
+
+                timeset = gettimeset(hour, minute, second)
+
+            if fixday and day > 28:
+                daysinmonth = calendar.monthrange(year, month)[1]
+                if day > daysinmonth:
+                    while day > daysinmonth:
+                        day -= daysinmonth
+                        month += 1
+                        if month == 13:
+                            month = 1
+                            year += 1
+                            if year > datetime.MAXYEAR:
+                                self._len = total
+                                return
+                        daysinmonth = calendar.monthrange(year, month)[1]
+                    ii.rebuild(year, month)
+
+    def __construct_byset(self, start, byxxx, base):
+        """
+        If a `BYXXX` sequence is passed to the constructor at the same level as
+        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some
+        specifications which cannot be reached given some starting conditions.
+
+        This occurs whenever the interval is not coprime with the base of a
+        given unit and the difference between the starting position and the
+        ending position is not coprime with the greatest common denominator
+        between the interval and the base. For example, with a FREQ of hourly
+        starting at 17:00 and an interval of 4, the only valid values for
+        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not
+        coprime.
+
+        :param start:
+            Specifies the starting position.
+        :param byxxx:
+            An iterable containing the list of allowed values.
+        :param base:
+            The largest allowable value for the specified frequency (e.g.
+            24 hours, 60 minutes).
+
+        This does not preserve the type of the iterable, returning a set, since
+        the values should be unique and the order is irrelevant, this will
+        speed up later lookups.
+
+        In the event of an empty set, raises a :exception:`ValueError`, as this
+        results in an empty rrule.
+        """
+
+        cset = set()
+
+        # Support a single byxxx value.
+        if isinstance(byxxx, integer_types):
+            byxxx = (byxxx, )
+
+        for num in byxxx:
+            i_gcd = gcd(self._interval, base)
+            # Use divmod rather than % because we need to wrap negative nums.
+            if i_gcd == 1 or divmod(num - start, i_gcd)[1] == 0:
+                cset.add(num)
+
+        if len(cset) == 0:
+            raise ValueError("Invalid rrule byxxx generates an empty set.")
+
+        return cset
+
+    def __mod_distance(self, value, byxxx, base):
+        """
+        Calculates the next value in a sequence where the `FREQ` parameter is
+        specified along with a `BYXXX` parameter at the same "level"
+        (e.g. `HOURLY` specified with `BYHOUR`).
+
+        :param value:
+            The old value of the component.
+        :param byxxx:
+            The `BYXXX` set, which should have been generated by
+            `rrule._construct_byset`, or something else which checks that a
+            valid rule is present.
+        :param base:
+            The largest allowable value for the specified frequency (e.g.
+            24 hours, 60 minutes).
+
+        If a valid value is not found after `base` iterations (the maximum
+        number before the sequence would start to repeat), this raises a
+        :exception:`ValueError`, as no valid values were found.
+
+        This returns a tuple of `divmod(n*interval, base)`, where `n` is the
+        smallest number of `interval` repetitions until the next specified
+        value in `byxxx` is found.
+        """
+        accumulator = 0
+        for ii in range(1, base + 1):
+            # Using divmod() over % to account for negative intervals
+            div, value = divmod(value + self._interval, base)
+            accumulator += div
+            if value in byxxx:
+                return (accumulator, value)
+
+
+class _iterinfo(object):
+    __slots__ = ["rrule", "lastyear", "lastmonth",
+                 "yearlen", "nextyearlen", "yearordinal", "yearweekday",
+                 "mmask", "mrange", "mdaymask", "nmdaymask",
+                 "wdaymask", "wnomask", "nwdaymask", "eastermask"]
+
+    def __init__(self, rrule):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+        self.rrule = rrule
+
+    def rebuild(self, year, month):
+        # Every mask is 7 days longer to handle cross-year weekly periods.
+        rr = self.rrule
+        if year != self.lastyear:
+            self.yearlen = 365 + calendar.isleap(year)
+            self.nextyearlen = 365 + calendar.isleap(year + 1)
+            firstyday = datetime.date(year, 1, 1)
+            self.yearordinal = firstyday.toordinal()
+            self.yearweekday = firstyday.weekday()
+
+            wday = datetime.date(year, 1, 1).weekday()
+            if self.yearlen == 365:
+                self.mmask = M365MASK
+                self.mdaymask = MDAY365MASK
+                self.nmdaymask = NMDAY365MASK
+                self.wdaymask = WDAYMASK[wday:]
+                self.mrange = M365RANGE
+            else:
+                self.mmask = M366MASK
+                self.mdaymask = MDAY366MASK
+                self.nmdaymask = NMDAY366MASK
+                self.wdaymask = WDAYMASK[wday:]
+                self.mrange = M366RANGE
+
+            if not rr._byweekno:
+                self.wnomask = None
+            else:
+                self.wnomask = [0]*(self.yearlen+7)
+                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst)
+                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst) % 7
+                if no1wkst >= 4:
+                    no1wkst = 0
+                    # Number of days in the year, plus the days we got
+                    # from last year.
+                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst) % 7
+                else:
+                    # Number of days in the year, minus the days we
+                    # left in last year.
+                    wyearlen = self.yearlen-no1wkst
+                div, mod = divmod(wyearlen, 7)
+                numweeks = div+mod//4
+                for n in rr._byweekno:
+                    if n < 0:
+                        n += numweeks+1
+                    if not (0 < n <= numweeks):
+                        continue
+                    if n > 1:
+                        i = no1wkst+(n-1)*7
+                        if no1wkst != firstwkst:
+                            i -= 7-firstwkst
+                    else:
+                        i = no1wkst
+                    for j in range(7):
+                        self.wnomask[i] = 1
+                        i += 1
+                        if self.wdaymask[i] == rr._wkst:
+                            break
+                if 1 in rr._byweekno:
+                    # Check week number 1 of next year as well
+                    # TODO: Check -numweeks for next year.
+                    i = no1wkst+numweeks*7
+                    if no1wkst != firstwkst:
+                        i -= 7-firstwkst
+                    if i < self.yearlen:
+                        # If week starts in next year, we
+                        # don't care about it.
+                        for j in range(7):
+                            self.wnomask[i] = 1
+                            i += 1
+                            if self.wdaymask[i] == rr._wkst:
+                                break
+                if no1wkst:
+                    # Check last week number of last year as
+                    # well. If no1wkst is 0, either the year
+                    # started on week start, or week number 1
+                    # got days from last year, so there are no
+                    # days from last year's last week number in
+                    # this year.
+                    if -1 not in rr._byweekno:
+                        lyearweekday = datetime.date(year-1, 1, 1).weekday()
+                        lno1wkst = (7-lyearweekday+rr._wkst) % 7
+                        lyearlen = 365+calendar.isleap(year-1)
+                        if lno1wkst >= 4:
+                            lno1wkst = 0
+                            lnumweeks = 52+(lyearlen +
+                                            (lyearweekday-rr._wkst) % 7) % 7//4
+                        else:
+                            lnumweeks = 52+(self.yearlen-no1wkst) % 7//4
+                    else:
+                        lnumweeks = -1
+                    if lnumweeks in rr._byweekno:
+                        for i in range(no1wkst):
+                            self.wnomask[i] = 1
+
+        if (rr._bynweekday and (month != self.lastmonth or
+                                year != self.lastyear)):
+            ranges = []
+            if rr._freq == YEARLY:
+                if rr._bymonth:
+                    for month in rr._bymonth:
+                        ranges.append(self.mrange[month-1:month+1])
+                else:
+                    ranges = [(0, self.yearlen)]
+            elif rr._freq == MONTHLY:
+                ranges = [self.mrange[month-1:month+1]]
+            if ranges:
+                # Weekly frequency won't get here, so we may not
+                # care about cross-year weekly periods.
+                self.nwdaymask = [0]*self.yearlen
+                for first, last in ranges:
+                    last -= 1
+                    for wday, n in rr._bynweekday:
+                        if n < 0:
+                            i = last+(n+1)*7
+                            i -= (self.wdaymask[i]-wday) % 7
+                        else:
+                            i = first+(n-1)*7
+                            i += (7-self.wdaymask[i]+wday) % 7
+                        if first <= i <= last:
+                            self.nwdaymask[i] = 1
+
+        if rr._byeaster:
+            self.eastermask = [0]*(self.yearlen+7)
+            eyday = easter.easter(year).toordinal()-self.yearordinal
+            for offset in rr._byeaster:
+                self.eastermask[eyday+offset] = 1
+
+        self.lastyear = year
+        self.lastmonth = month
+
+    def ydayset(self, year, month, day):
+        return list(range(self.yearlen)), 0, self.yearlen
+
+    def mdayset(self, year, month, day):
+        dset = [None]*self.yearlen
+        start, end = self.mrange[month-1:month+1]
+        for i in range(start, end):
+            dset[i] = i
+        return dset, start, end
+
+    def wdayset(self, year, month, day):
+        # We need to handle cross-year weeks here.
+        dset = [None]*(self.yearlen+7)
+        i = datetime.date(year, month, day).toordinal()-self.yearordinal
+        start = i
+        for j in range(7):
+            dset[i] = i
+            i += 1
+            # if (not (0 <= i < self.yearlen) or
+            #    self.wdaymask[i] == self.rrule._wkst):
+            # This will cross the year boundary, if necessary.
+            if self.wdaymask[i] == self.rrule._wkst:
+                break
+        return dset, start, i
+
+    def ddayset(self, year, month, day):
+        dset = [None] * self.yearlen
+        i = datetime.date(year, month, day).toordinal() - self.yearordinal
+        dset[i] = i
+        return dset, i, i + 1
+
+    def htimeset(self, hour, minute, second):
+        tset = []
+        rr = self.rrule
+        for minute in rr._byminute:
+            for second in rr._bysecond:
+                tset.append(datetime.time(hour, minute, second,
+                                          tzinfo=rr._tzinfo))
+        tset.sort()
+        return tset
+
+    def mtimeset(self, hour, minute, second):
+        tset = []
+        rr = self.rrule
+        for second in rr._bysecond:
+            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))
+        tset.sort()
+        return tset
+
+    def stimeset(self, hour, minute, second):
+        return (datetime.time(hour, minute, second,
+                tzinfo=self.rrule._tzinfo),)
+
+
+class rruleset(rrulebase):
+    """ The rruleset type allows more complex recurrence setups, mixing
+    multiple rules, dates, exclusion rules, and exclusion dates. The type
+    constructor takes the following keyword arguments:
+
+    :param cache: If True, caching of results will be enabled, improving
+                  performance of multiple queries considerably. """
+
+    class _genitem(object):
+        def __init__(self, genlist, gen):
+            try:
+                self.dt = advance_iterator(gen)
+                genlist.append(self)
+            except StopIteration:
+                pass
+            self.genlist = genlist
+            self.gen = gen
+
+        def __next__(self):
+            try:
+                self.dt = advance_iterator(self.gen)
+            except StopIteration:
+                if self.genlist[0] is self:
+                    heapq.heappop(self.genlist)
+                else:
+                    self.genlist.remove(self)
+                    heapq.heapify(self.genlist)
+
+        next = __next__
+
+        def __lt__(self, other):
+            return self.dt < other.dt
+
+        def __gt__(self, other):
+            return self.dt > other.dt
+
+        def __eq__(self, other):
+            return self.dt == other.dt
+
+        def __ne__(self, other):
+            return self.dt != other.dt
+
+    def __init__(self, cache=False):
+        super(rruleset, self).__init__(cache)
+        self._rrule = []
+        self._rdate = []
+        self._exrule = []
+        self._exdate = []
+
+    @_invalidates_cache
+    def rrule(self, rrule):
+        """ Include the given :py:class:`rrule` instance in the recurrence set
+            generation. """
+        self._rrule.append(rrule)
+
+    @_invalidates_cache
+    def rdate(self, rdate):
+        """ Include the given :py:class:`datetime` instance in the recurrence
+            set generation. """
+        self._rdate.append(rdate)
+
+    @_invalidates_cache
+    def exrule(self, exrule):
+        """ Include the given rrule instance in the recurrence set exclusion
+            list. Dates which are part of the given recurrence rules will not
+            be generated, even if some inclusive rrule or rdate matches them.
+        """
+        self._exrule.append(exrule)
+
+    @_invalidates_cache
+    def exdate(self, exdate):
+        """ Include the given datetime instance in the recurrence set
+            exclusion list. Dates included that way will not be generated,
+            even if some inclusive rrule or rdate matches them. """
+        self._exdate.append(exdate)
+
+    def _iter(self):
+        rlist = []
+        self._rdate.sort()
+        self._genitem(rlist, iter(self._rdate))
+        for gen in [iter(x) for x in self._rrule]:
+            self._genitem(rlist, gen)
+        exlist = []
+        self._exdate.sort()
+        self._genitem(exlist, iter(self._exdate))
+        for gen in [iter(x) for x in self._exrule]:
+            self._genitem(exlist, gen)
+        lastdt = None
+        total = 0
+        heapq.heapify(rlist)
+        heapq.heapify(exlist)
+        while rlist:
+            ritem = rlist[0]
+            if not lastdt or lastdt != ritem.dt:
+                while exlist and exlist[0] < ritem:
+                    exitem = exlist[0]
+                    advance_iterator(exitem)
+                    if exlist and exlist[0] is exitem:
+                        heapq.heapreplace(exlist, exitem)
+                if not exlist or ritem != exlist[0]:
+                    total += 1
+                    yield ritem.dt
+                lastdt = ritem.dt
+            advance_iterator(ritem)
+            if rlist and rlist[0] is ritem:
+                heapq.heapreplace(rlist, ritem)
+        self._len = total
+
+
+
+
+class _rrulestr(object):
+    """ Parses a string representation of a recurrence rule or set of
+    recurrence rules.
+
+    :param s:
+        Required, a string defining one or more recurrence rules.
+
+    :param dtstart:
+        If given, used as the default recurrence start if not specified in the
+        rule string.
+
+    :param cache:
+        If set ``True`` caching of results will be enabled, improving
+        performance of multiple queries considerably.
+
+    :param unfold:
+        If set ``True`` indicates that a rule string is split over more
+        than one line and should be joined before processing.
+
+    :param forceset:
+        If set ``True`` forces a :class:`dateutil.rrule.rruleset` to
+        be returned.
+
+    :param compatible:
+        If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.
+
+    :param ignoretz:
+        If set ``True``, time zones in parsed strings are ignored and a naive
+        :class:`datetime.datetime` object is returned.
+
+    :param tzids:
+        If given, a callable or mapping used to retrieve a
+        :class:`datetime.tzinfo` from a string representation.
+        Defaults to :func:`dateutil.tz.gettz`.
+
+    :param tzinfos:
+        Additional time zone names / aliases which may be present in a string
+        representation.  See :func:`dateutil.parser.parse` for more
+        information.
+
+    :return:
+        Returns a :class:`dateutil.rrule.rruleset` or
+        :class:`dateutil.rrule.rrule`
+    """
+
+    _freq_map = {"YEARLY": YEARLY,
+                 "MONTHLY": MONTHLY,
+                 "WEEKLY": WEEKLY,
+                 "DAILY": DAILY,
+                 "HOURLY": HOURLY,
+                 "MINUTELY": MINUTELY,
+                 "SECONDLY": SECONDLY}
+
+    _weekday_map = {"MO": 0, "TU": 1, "WE": 2, "TH": 3,
+                    "FR": 4, "SA": 5, "SU": 6}
+
+    def _handle_int(self, rrkwargs, name, value, **kwargs):
+        rrkwargs[name.lower()] = int(value)
+
+    def _handle_int_list(self, rrkwargs, name, value, **kwargs):
+        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]
+
+    _handle_INTERVAL = _handle_int
+    _handle_COUNT = _handle_int
+    _handle_BYSETPOS = _handle_int_list
+    _handle_BYMONTH = _handle_int_list
+    _handle_BYMONTHDAY = _handle_int_list
+    _handle_BYYEARDAY = _handle_int_list
+    _handle_BYEASTER = _handle_int_list
+    _handle_BYWEEKNO = _handle_int_list
+    _handle_BYHOUR = _handle_int_list
+    _handle_BYMINUTE = _handle_int_list
+    _handle_BYSECOND = _handle_int_list
+
+    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):
+        rrkwargs["freq"] = self._freq_map[value]
+
+    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):
+        global parser
+        if not parser:
+            from dateutil import parser
+        try:
+            rrkwargs["until"] = parser.parse(value,
+                                             ignoretz=kwargs.get("ignoretz"),
+                                             tzinfos=kwargs.get("tzinfos"))
+        except ValueError:
+            raise ValueError("invalid until date")
+
+    def _handle_WKST(self, rrkwargs, name, value, **kwargs):
+        rrkwargs["wkst"] = self._weekday_map[value]
+
+    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):
+        """
+        Two ways to specify this: +1MO or MO(+1)
+        """
+        l = []
+        for wday in value.split(','):
+            if '(' in wday:
+                # If it's of the form TH(+1), etc.
+                splt = wday.split('(')
+                w = splt[0]
+                n = int(splt[1][:-1])
+            elif len(wday):
+                # If it's of the form +1MO
+                for i in range(len(wday)):
+                    if wday[i] not in '+-0123456789':
+                        break
+                n = wday[:i] or None
+                w = wday[i:]
+                if n:
+                    n = int(n)
+            else:
+                raise ValueError("Invalid (empty) BYDAY specification.")
+
+            l.append(weekdays[self._weekday_map[w]](n))
+        rrkwargs["byweekday"] = l
+
+    _handle_BYDAY = _handle_BYWEEKDAY
+
+    def _parse_rfc_rrule(self, line,
+                         dtstart=None,
+                         cache=False,
+                         ignoretz=False,
+                         tzinfos=None):
+        if line.find(':') != -1:
+            name, value = line.split(':')
+            if name != "RRULE":
+                raise ValueError("unknown parameter name")
+        else:
+            value = line
+        rrkwargs = {}
+        for pair in value.split(';'):
+            name, value = pair.split('=')
+            name = name.upper()
+            value = value.upper()
+            try:
+                getattr(self, "_handle_"+name)(rrkwargs, name, value,
+                                               ignoretz=ignoretz,
+                                               tzinfos=tzinfos)
+            except AttributeError:
+                raise ValueError("unknown parameter '%s'" % name)
+            except (KeyError, ValueError):
+                raise ValueError("invalid '%s': %s" % (name, value))
+        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)
+
+    def _parse_date_value(self, date_value, parms, rule_tzids,
+                          ignoretz, tzids, tzinfos):
+        global parser
+        if not parser:
+            from dateutil import parser
+
+        datevals = []
+        value_found = False
+        TZID = None
+
+        for parm in parms:
+            if parm.startswith("TZID="):
+                try:
+                    tzkey = rule_tzids[parm.split('TZID=')[-1]]
+                except KeyError:
+                    continue
+                if tzids is None:
+                    from . import tz
+                    tzlookup = tz.gettz
+                elif callable(tzids):
+                    tzlookup = tzids
+                else:
+                    tzlookup = getattr(tzids, 'get', None)
+                    if tzlookup is None:
+                        msg = ('tzids must be a callable, mapping, or None, '
+                               'not %s' % tzids)
+                        raise ValueError(msg)
+
+                TZID = tzlookup(tzkey)
+                continue
+
+            # RFC 5445 3.8.2.4: The VALUE parameter is optional, but may be found
+            # only once.
+            if parm not in {"VALUE=DATE-TIME", "VALUE=DATE"}:
+                raise ValueError("unsupported parm: " + parm)
+            else:
+                if value_found:
+                    msg = ("Duplicate value parameter found in: " + parm)
+                    raise ValueError(msg)
+                value_found = True
+
+        for datestr in date_value.split(','):
+            date = parser.parse(datestr, ignoretz=ignoretz, tzinfos=tzinfos)
+            if TZID is not None:
+                if date.tzinfo is None:
+                    date = date.replace(tzinfo=TZID)
+                else:
+                    raise ValueError('DTSTART/EXDATE specifies multiple timezone')
+            datevals.append(date)
+
+        return datevals
+
+    def _parse_rfc(self, s,
+                   dtstart=None,
+                   cache=False,
+                   unfold=False,
+                   forceset=False,
+                   compatible=False,
+                   ignoretz=False,
+                   tzids=None,
+                   tzinfos=None):
+        global parser
+        if compatible:
+            forceset = True
+            unfold = True
+
+        TZID_NAMES = dict(map(
+            lambda x: (x.upper(), x),
+            re.findall('TZID=(?P<name>[^:]+):', s)
+        ))
+        s = s.upper()
+        if not s.strip():
+            raise ValueError("empty string")
+        if unfold:
+            lines = s.splitlines()
+            i = 0
+            while i < len(lines):
+                line = lines[i].rstrip()
+                if not line:
+                    del lines[i]
+                elif i > 0 and line[0] == " ":
+                    lines[i-1] += line[1:]
+                    del lines[i]
+                else:
+                    i += 1
+        else:
+            lines = s.split()
+        if (not forceset and len(lines) == 1 and (s.find(':') == -1 or
+                                                  s.startswith('RRULE:'))):
+            return self._parse_rfc_rrule(lines[0], cache=cache,
+                                         dtstart=dtstart, ignoretz=ignoretz,
+                                         tzinfos=tzinfos)
+        else:
+            rrulevals = []
+            rdatevals = []
+            exrulevals = []
+            exdatevals = []
+            for line in lines:
+                if not line:
+                    continue
+                if line.find(':') == -1:
+                    name = "RRULE"
+                    value = line
+                else:
+                    name, value = line.split(':', 1)
+                parms = name.split(';')
+                if not parms:
+                    raise ValueError("empty property name")
+                name = parms[0]
+                parms = parms[1:]
+                if name == "RRULE":
+                    for parm in parms:
+                        raise ValueError("unsupported RRULE parm: "+parm)
+                    rrulevals.append(value)
+                elif name == "RDATE":
+                    for parm in parms:
+                        if parm != "VALUE=DATE-TIME":
+                            raise ValueError("unsupported RDATE parm: "+parm)
+                    rdatevals.append(value)
+                elif name == "EXRULE":
+                    for parm in parms:
+                        raise ValueError("unsupported EXRULE parm: "+parm)
+                    exrulevals.append(value)
+                elif name == "EXDATE":
+                    exdatevals.extend(
+                        self._parse_date_value(value, parms,
+                                               TZID_NAMES, ignoretz,
+                                               tzids, tzinfos)
+                    )
+                elif name == "DTSTART":
+                    dtvals = self._parse_date_value(value, parms, TZID_NAMES,
+                                                    ignoretz, tzids, tzinfos)
+                    if len(dtvals) != 1:
+                        raise ValueError("Multiple DTSTART values specified:" +
+                                         value)
+                    dtstart = dtvals[0]
+                else:
+                    raise ValueError("unsupported property: "+name)
+            if (forceset or len(rrulevals) > 1 or rdatevals
+                    or exrulevals or exdatevals):
+                if not parser and (rdatevals or exdatevals):
+                    from dateutil import parser
+                rset = rruleset(cache=cache)
+                for value in rrulevals:
+                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,
+                                                     ignoretz=ignoretz,
+                                                     tzinfos=tzinfos))
+                for value in rdatevals:
+                    for datestr in value.split(','):
+                        rset.rdate(parser.parse(datestr,
+                                                ignoretz=ignoretz,
+                                                tzinfos=tzinfos))
+                for value in exrulevals:
+                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,
+                                                      ignoretz=ignoretz,
+                                                      tzinfos=tzinfos))
+                for value in exdatevals:
+                    rset.exdate(value)
+                if compatible and dtstart:
+                    rset.rdate(dtstart)
+                return rset
+            else:
+                return self._parse_rfc_rrule(rrulevals[0],
+                                             dtstart=dtstart,
+                                             cache=cache,
+                                             ignoretz=ignoretz,
+                                             tzinfos=tzinfos)
+
+    def __call__(self, s, **kwargs):
+        return self._parse_rfc(s, **kwargs)
+
+
+rrulestr = _rrulestr()
+
+# vim:ts=4:sw=4:et
diff --git a/Lib/site-packages/dateutil/tz/__init__.py b/Lib/site-packages/dateutil/tz/__init__.py
new file mode 100644
index 0000000..af1352c
--- /dev/null
+++ b/Lib/site-packages/dateutil/tz/__init__.py
@@ -0,0 +1,12 @@
+# -*- coding: utf-8 -*-
+from .tz import *
+from .tz import __doc__
+
+__all__ = ["tzutc", "tzoffset", "tzlocal", "tzfile", "tzrange",
+           "tzstr", "tzical", "tzwin", "tzwinlocal", "gettz",
+           "enfold", "datetime_ambiguous", "datetime_exists",
+           "resolve_imaginary", "UTC", "DeprecatedTzFormatWarning"]
+
+
+class DeprecatedTzFormatWarning(Warning):
+    """Warning raised when time zones are parsed from deprecated formats."""
diff --git a/Lib/site-packages/dateutil/tz/__pycache__/__init__.cpython-312.pyc b/Lib/site-packages/dateutil/tz/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..52504aa642d9495db4eb1eda6601af43effc4041
GIT binary patch
literal 709
zcmX|9y>HYo6t|Py<#cUDi;z%ZAdEq}c3?pWG0+N@(y0|v6v=Yqmz=5df$ea;Obq=W
zx*|4&_z(CGm{}|_fsoh`2TLdH+|f6@_j}(T_UDa_F|ri@_>zCZ2z_(Pe;Ta7;(-Mh
zh#`gr`siVYJb_A_V2ldH{C7C<JoF5);2g05_#gabW)jSYaro2LMKLz`o@F5+tj-9D
zH_bqIt<KCycXggC&?eNKs52_eP<J^O;0%&h1-MY9rL%MAx9W^nX55Qq%Af$PJ2QkT
zuLU#L8P%Y9351p>ylCrInQK=zIO9qyvn4^*;x!On(t=l1&W(S3v}d;Wp^=c;3hbzR
zTFa8^7gScfDzeo@dg0b`wAi%l0s%@eLy5<5;?KR<mp81rd$P)mB;^WNG@C*dxxu2Y
zu0TapLex;{T)C{vh+Vag^1id$IgA4{BBY{r8)C+Ulr?LG!|Q~+YN=RyWMKQfM+?i*
zWwQ4$Jysx9I?b~wPi-w)Ks1B16`Z_m%50)$Fws<<PVT1%{3KOe!=$0vsf|^sJ6Ef@
z*wx)GA-v+6kez1U@71$4+ex`ka*j-JAa7aJ+YjS`@$A#Nf!u>rA?&c>>JrQRZ5P~U
y+_va)^k})%V|mA_?y~BxWxsrk@prWK72W(D_-p(4P55UW<LCHo_!l|Zm-q+u)zjht

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/tz/__pycache__/_common.cpython-312.pyc b/Lib/site-packages/dateutil/tz/__pycache__/_common.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..d6a3ce7cdf6d04e1b0be987162ad11cca37d2d8d
GIT binary patch
literal 14162
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

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/tz/__pycache__/_factories.cpython-312.pyc b/Lib/site-packages/dateutil/tz/__pycache__/_factories.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..f5c6fab1dcbb67b767d6f505159d3754c6f94062
GIT binary patch
literal 4595
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
ClA{*@

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/tz/__pycache__/tz.cpython-312.pyc b/Lib/site-packages/dateutil/tz/__pycache__/tz.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..b52b5dadf1eeb3f2172d6a572ee789314bc80eb4
GIT binary patch
literal 66009
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
Z_kMz@Ctdq~8c$(XN>7#c{YoC;{{S?P6vhAm

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/tz/__pycache__/win.cpython-312.pyc b/Lib/site-packages/dateutil/tz/__pycache__/win.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..982864dadc57ac49ebb1c09f2db10faa51dea7d1
GIT binary patch
literal 17265
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

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/tz/_common.py b/Lib/site-packages/dateutil/tz/_common.py
new file mode 100644
index 0000000..e6ac118
--- /dev/null
+++ b/Lib/site-packages/dateutil/tz/_common.py
@@ -0,0 +1,419 @@
+from six import PY2
+
+from functools import wraps
+
+from datetime import datetime, timedelta, tzinfo
+
+
+ZERO = timedelta(0)
+
+__all__ = ['tzname_in_python2', 'enfold']
+
+
+def tzname_in_python2(namefunc):
+    """Change unicode output into bytestrings in Python 2
+
+    tzname() API changed in Python 3. It used to return bytes, but was changed
+    to unicode strings
+    """
+    if PY2:
+        @wraps(namefunc)
+        def adjust_encoding(*args, **kwargs):
+            name = namefunc(*args, **kwargs)
+            if name is not None:
+                name = name.encode()
+
+            return name
+
+        return adjust_encoding
+    else:
+        return namefunc
+
+
+# The following is adapted from Alexander Belopolsky's tz library
+# https://github.com/abalkin/tz
+if hasattr(datetime, 'fold'):
+    # This is the pre-python 3.6 fold situation
+    def enfold(dt, fold=1):
+        """
+        Provides a unified interface for assigning the ``fold`` attribute to
+        datetimes both before and after the implementation of PEP-495.
+
+        :param fold:
+            The value for the ``fold`` attribute in the returned datetime. This
+            should be either 0 or 1.
+
+        :return:
+            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
+            ``fold`` for all versions of Python. In versions prior to
+            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
+            subclass of :py:class:`datetime.datetime` with the ``fold``
+            attribute added, if ``fold`` is 1.
+
+        .. versionadded:: 2.6.0
+        """
+        return dt.replace(fold=fold)
+
+else:
+    class _DatetimeWithFold(datetime):
+        """
+        This is a class designed to provide a PEP 495-compliant interface for
+        Python versions before 3.6. It is used only for dates in a fold, so
+        the ``fold`` attribute is fixed at ``1``.
+
+        .. versionadded:: 2.6.0
+        """
+        __slots__ = ()
+
+        def replace(self, *args, **kwargs):
+            """
+            Return a datetime with the same attributes, except for those
+            attributes given new values by whichever keyword arguments are
+            specified. Note that tzinfo=None can be specified to create a naive
+            datetime from an aware datetime with no conversion of date and time
+            data.
+
+            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will
+            return a ``datetime.datetime`` even if ``fold`` is unchanged.
+            """
+            argnames = (
+                'year', 'month', 'day', 'hour', 'minute', 'second',
+                'microsecond', 'tzinfo'
+            )
+
+            for arg, argname in zip(args, argnames):
+                if argname in kwargs:
+                    raise TypeError('Duplicate argument: {}'.format(argname))
+
+                kwargs[argname] = arg
+
+            for argname in argnames:
+                if argname not in kwargs:
+                    kwargs[argname] = getattr(self, argname)
+
+            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime
+
+            return dt_class(**kwargs)
+
+        @property
+        def fold(self):
+            return 1
+
+    def enfold(dt, fold=1):
+        """
+        Provides a unified interface for assigning the ``fold`` attribute to
+        datetimes both before and after the implementation of PEP-495.
+
+        :param fold:
+            The value for the ``fold`` attribute in the returned datetime. This
+            should be either 0 or 1.
+
+        :return:
+            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
+            ``fold`` for all versions of Python. In versions prior to
+            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
+            subclass of :py:class:`datetime.datetime` with the ``fold``
+            attribute added, if ``fold`` is 1.
+
+        .. versionadded:: 2.6.0
+        """
+        if getattr(dt, 'fold', 0) == fold:
+            return dt
+
+        args = dt.timetuple()[:6]
+        args += (dt.microsecond, dt.tzinfo)
+
+        if fold:
+            return _DatetimeWithFold(*args)
+        else:
+            return datetime(*args)
+
+
+def _validate_fromutc_inputs(f):
+    """
+    The CPython version of ``fromutc`` checks that the input is a ``datetime``
+    object and that ``self`` is attached as its ``tzinfo``.
+    """
+    @wraps(f)
+    def fromutc(self, dt):
+        if not isinstance(dt, datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        return f(self, dt)
+
+    return fromutc
+
+
+class _tzinfo(tzinfo):
+    """
+    Base class for all ``dateutil`` ``tzinfo`` objects.
+    """
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+
+        dt = dt.replace(tzinfo=self)
+
+        wall_0 = enfold(dt, fold=0)
+        wall_1 = enfold(dt, fold=1)
+
+        same_offset = wall_0.utcoffset() == wall_1.utcoffset()
+        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)
+
+        return same_dt and not same_offset
+
+    def _fold_status(self, dt_utc, dt_wall):
+        """
+        Determine the fold status of a "wall" datetime, given a representation
+        of the same datetime as a (naive) UTC datetime. This is calculated based
+        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all
+        datetimes, and that this offset is the actual number of hours separating
+        ``dt_utc`` and ``dt_wall``.
+
+        :param dt_utc:
+            Representation of the datetime as UTC
+
+        :param dt_wall:
+            Representation of the datetime as "wall time". This parameter must
+            either have a `fold` attribute or have a fold-naive
+            :class:`datetime.tzinfo` attached, otherwise the calculation may
+            fail.
+        """
+        if self.is_ambiguous(dt_wall):
+            delta_wall = dt_wall - dt_utc
+            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))
+        else:
+            _fold = 0
+
+        return _fold
+
+    def _fold(self, dt):
+        return getattr(dt, 'fold', 0)
+
+    def _fromutc(self, dt):
+        """
+        Given a timezone-aware datetime in a given timezone, calculates a
+        timezone-aware datetime in a new timezone.
+
+        Since this is the one time that we *know* we have an unambiguous
+        datetime object, we take this opportunity to determine whether the
+        datetime is ambiguous and in a "fold" state (e.g. if it's the first
+        occurrence, chronologically, of the ambiguous datetime).
+
+        :param dt:
+            A timezone-aware :class:`datetime.datetime` object.
+        """
+
+        # Re-implement the algorithm from Python's datetime.py
+        dtoff = dt.utcoffset()
+        if dtoff is None:
+            raise ValueError("fromutc() requires a non-None utcoffset() "
+                             "result")
+
+        # The original datetime.py code assumes that `dst()` defaults to
+        # zero during ambiguous times. PEP 495 inverts this presumption, so
+        # for pre-PEP 495 versions of python, we need to tweak the algorithm.
+        dtdst = dt.dst()
+        if dtdst is None:
+            raise ValueError("fromutc() requires a non-None dst() result")
+        delta = dtoff - dtdst
+
+        dt += delta
+        # Set fold=1 so we can default to being in the fold for
+        # ambiguous dates.
+        dtdst = enfold(dt, fold=1).dst()
+        if dtdst is None:
+            raise ValueError("fromutc(): dt.dst gave inconsistent "
+                             "results; cannot convert")
+        return dt + dtdst
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        """
+        Given a timezone-aware datetime in a given timezone, calculates a
+        timezone-aware datetime in a new timezone.
+
+        Since this is the one time that we *know* we have an unambiguous
+        datetime object, we take this opportunity to determine whether the
+        datetime is ambiguous and in a "fold" state (e.g. if it's the first
+        occurrence, chronologically, of the ambiguous datetime).
+
+        :param dt:
+            A timezone-aware :class:`datetime.datetime` object.
+        """
+        dt_wall = self._fromutc(dt)
+
+        # Calculate the fold status given the two datetimes.
+        _fold = self._fold_status(dt, dt_wall)
+
+        # Set the default fold value for ambiguous dates
+        return enfold(dt_wall, fold=_fold)
+
+
+class tzrangebase(_tzinfo):
+    """
+    This is an abstract base class for time zones represented by an annual
+    transition into and out of DST. Child classes should implement the following
+    methods:
+
+        * ``__init__(self, *args, **kwargs)``
+        * ``transitions(self, year)`` - this is expected to return a tuple of
+          datetimes representing the DST on and off transitions in standard
+          time.
+
+    A fully initialized ``tzrangebase`` subclass should also provide the
+    following attributes:
+        * ``hasdst``: Boolean whether or not the zone uses DST.
+        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects
+          representing the respective UTC offsets.
+        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short
+          abbreviations in DST and STD, respectively.
+        * ``_hasdst``: Whether or not the zone has DST.
+
+    .. versionadded:: 2.6.0
+    """
+    def __init__(self):
+        raise NotImplementedError('tzrangebase is an abstract base class')
+
+    def utcoffset(self, dt):
+        isdst = self._isdst(dt)
+
+        if isdst is None:
+            return None
+        elif isdst:
+            return self._dst_offset
+        else:
+            return self._std_offset
+
+    def dst(self, dt):
+        isdst = self._isdst(dt)
+
+        if isdst is None:
+            return None
+        elif isdst:
+            return self._dst_base_offset
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        if self._isdst(dt):
+            return self._dst_abbr
+        else:
+            return self._std_abbr
+
+    def fromutc(self, dt):
+        """ Given a datetime in UTC, return local time """
+        if not isinstance(dt, datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        # Get transitions - if there are none, fixed offset
+        transitions = self.transitions(dt.year)
+        if transitions is None:
+            return dt + self.utcoffset(dt)
+
+        # Get the transition times in UTC
+        dston, dstoff = transitions
+
+        dston -= self._std_offset
+        dstoff -= self._std_offset
+
+        utc_transitions = (dston, dstoff)
+        dt_utc = dt.replace(tzinfo=None)
+
+        isdst = self._naive_isdst(dt_utc, utc_transitions)
+
+        if isdst:
+            dt_wall = dt + self._dst_offset
+        else:
+            dt_wall = dt + self._std_offset
+
+        _fold = int(not isdst and self.is_ambiguous(dt_wall))
+
+        return enfold(dt_wall, fold=_fold)
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        if not self.hasdst:
+            return False
+
+        start, end = self.transitions(dt.year)
+
+        dt = dt.replace(tzinfo=None)
+        return (end <= dt < end + self._dst_base_offset)
+
+    def _isdst(self, dt):
+        if not self.hasdst:
+            return False
+        elif dt is None:
+            return None
+
+        transitions = self.transitions(dt.year)
+
+        if transitions is None:
+            return False
+
+        dt = dt.replace(tzinfo=None)
+
+        isdst = self._naive_isdst(dt, transitions)
+
+        # Handle ambiguous dates
+        if not isdst and self.is_ambiguous(dt):
+            return not self._fold(dt)
+        else:
+            return isdst
+
+    def _naive_isdst(self, dt, transitions):
+        dston, dstoff = transitions
+
+        dt = dt.replace(tzinfo=None)
+
+        if dston < dstoff:
+            isdst = dston <= dt < dstoff
+        else:
+            isdst = not dstoff <= dt < dston
+
+        return isdst
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_offset - self._std_offset
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(...)" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
diff --git a/Lib/site-packages/dateutil/tz/_factories.py b/Lib/site-packages/dateutil/tz/_factories.py
new file mode 100644
index 0000000..f8a6589
--- /dev/null
+++ b/Lib/site-packages/dateutil/tz/_factories.py
@@ -0,0 +1,80 @@
+from datetime import timedelta
+import weakref
+from collections import OrderedDict
+
+from six.moves import _thread
+
+
+class _TzSingleton(type):
+    def __init__(cls, *args, **kwargs):
+        cls.__instance = None
+        super(_TzSingleton, cls).__init__(*args, **kwargs)
+
+    def __call__(cls):
+        if cls.__instance is None:
+            cls.__instance = super(_TzSingleton, cls).__call__()
+        return cls.__instance
+
+
+class _TzFactory(type):
+    def instance(cls, *args, **kwargs):
+        """Alternate constructor that returns a fresh instance"""
+        return type.__call__(cls, *args, **kwargs)
+
+
+class _TzOffsetFactory(_TzFactory):
+    def __init__(cls, *args, **kwargs):
+        cls.__instances = weakref.WeakValueDictionary()
+        cls.__strong_cache = OrderedDict()
+        cls.__strong_cache_size = 8
+
+        cls._cache_lock = _thread.allocate_lock()
+
+    def __call__(cls, name, offset):
+        if isinstance(offset, timedelta):
+            key = (name, offset.total_seconds())
+        else:
+            key = (name, offset)
+
+        instance = cls.__instances.get(key, None)
+        if instance is None:
+            instance = cls.__instances.setdefault(key,
+                                                  cls.instance(name, offset))
+
+        # This lock may not be necessary in Python 3. See GH issue #901
+        with cls._cache_lock:
+            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)
+
+            # Remove an item if the strong cache is overpopulated
+            if len(cls.__strong_cache) > cls.__strong_cache_size:
+                cls.__strong_cache.popitem(last=False)
+
+        return instance
+
+
+class _TzStrFactory(_TzFactory):
+    def __init__(cls, *args, **kwargs):
+        cls.__instances = weakref.WeakValueDictionary()
+        cls.__strong_cache = OrderedDict()
+        cls.__strong_cache_size = 8
+
+        cls.__cache_lock = _thread.allocate_lock()
+
+    def __call__(cls, s, posix_offset=False):
+        key = (s, posix_offset)
+        instance = cls.__instances.get(key, None)
+
+        if instance is None:
+            instance = cls.__instances.setdefault(key,
+                cls.instance(s, posix_offset))
+
+        # This lock may not be necessary in Python 3. See GH issue #901
+        with cls.__cache_lock:
+            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)
+
+            # Remove an item if the strong cache is overpopulated
+            if len(cls.__strong_cache) > cls.__strong_cache_size:
+                cls.__strong_cache.popitem(last=False)
+
+        return instance
+
diff --git a/Lib/site-packages/dateutil/tz/tz.py b/Lib/site-packages/dateutil/tz/tz.py
new file mode 100644
index 0000000..6175914
--- /dev/null
+++ b/Lib/site-packages/dateutil/tz/tz.py
@@ -0,0 +1,1849 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers timezone implementations subclassing the abstract
+:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format
+files (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`,
+etc), TZ environment string (in all known formats), given ranges (with help
+from relative deltas), local machine timezone, fixed offset timezone, and UTC
+timezone.
+"""
+import datetime
+import struct
+import time
+import sys
+import os
+import bisect
+import weakref
+from collections import OrderedDict
+
+import six
+from six import string_types
+from six.moves import _thread
+from ._common import tzname_in_python2, _tzinfo
+from ._common import tzrangebase, enfold
+from ._common import _validate_fromutc_inputs
+
+from ._factories import _TzSingleton, _TzOffsetFactory
+from ._factories import _TzStrFactory
+try:
+    from .win import tzwin, tzwinlocal
+except ImportError:
+    tzwin = tzwinlocal = None
+
+# For warning about rounding tzinfo
+from warnings import warn
+
+ZERO = datetime.timedelta(0)
+EPOCH = datetime.datetime(1970, 1, 1, 0, 0)
+EPOCHORDINAL = EPOCH.toordinal()
+
+
+@six.add_metaclass(_TzSingleton)
+class tzutc(datetime.tzinfo):
+    """
+    This is a tzinfo object that represents the UTC time zone.
+
+    **Examples:**
+
+    .. doctest::
+
+        >>> from datetime import *
+        >>> from dateutil.tz import *
+
+        >>> datetime.now()
+        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)
+
+        >>> datetime.now(tzutc())
+        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())
+
+        >>> datetime.now(tzutc()).tzname()
+        'UTC'
+
+    .. versionchanged:: 2.7.0
+        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will
+        always return the same object.
+
+        .. doctest::
+
+            >>> from dateutil.tz import tzutc, UTC
+            >>> tzutc() is tzutc()
+            True
+            >>> tzutc() is UTC
+            True
+    """
+    def utcoffset(self, dt):
+        return ZERO
+
+    def dst(self, dt):
+        return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return "UTC"
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        return False
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        """
+        Fast track version of fromutc() returns the original ``dt`` object for
+        any valid :py:class:`datetime.datetime` object.
+        """
+        return dt
+
+    def __eq__(self, other):
+        if not isinstance(other, (tzutc, tzoffset)):
+            return NotImplemented
+
+        return (isinstance(other, tzutc) or
+                (isinstance(other, tzoffset) and other._offset == ZERO))
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s()" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
+
+
+#: Convenience constant providing a :class:`tzutc()` instance
+#:
+#: .. versionadded:: 2.7.0
+UTC = tzutc()
+
+
+@six.add_metaclass(_TzOffsetFactory)
+class tzoffset(datetime.tzinfo):
+    """
+    A simple class for representing a fixed offset from UTC.
+
+    :param name:
+        The timezone name, to be returned when ``tzname()`` is called.
+    :param offset:
+        The time zone offset in seconds, or (since version 2.6.0, represented
+        as a :py:class:`datetime.timedelta` object).
+    """
+    def __init__(self, name, offset):
+        self._name = name
+
+        try:
+            # Allow a timedelta
+            offset = offset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        self._offset = datetime.timedelta(seconds=_get_supported_offset(offset))
+
+    def utcoffset(self, dt):
+        return self._offset
+
+    def dst(self, dt):
+        return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._name
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        return dt + self._offset
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        return False
+
+    def __eq__(self, other):
+        if not isinstance(other, tzoffset):
+            return NotImplemented
+
+        return self._offset == other._offset
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(%s, %s)" % (self.__class__.__name__,
+                               repr(self._name),
+                               int(self._offset.total_seconds()))
+
+    __reduce__ = object.__reduce__
+
+
+class tzlocal(_tzinfo):
+    """
+    A :class:`tzinfo` subclass built around the ``time`` timezone functions.
+    """
+    def __init__(self):
+        super(tzlocal, self).__init__()
+
+        self._std_offset = datetime.timedelta(seconds=-time.timezone)
+        if time.daylight:
+            self._dst_offset = datetime.timedelta(seconds=-time.altzone)
+        else:
+            self._dst_offset = self._std_offset
+
+        self._dst_saved = self._dst_offset - self._std_offset
+        self._hasdst = bool(self._dst_saved)
+        self._tznames = tuple(time.tzname)
+
+    def utcoffset(self, dt):
+        if dt is None and self._hasdst:
+            return None
+
+        if self._isdst(dt):
+            return self._dst_offset
+        else:
+            return self._std_offset
+
+    def dst(self, dt):
+        if dt is None and self._hasdst:
+            return None
+
+        if self._isdst(dt):
+            return self._dst_offset - self._std_offset
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._tznames[self._isdst(dt)]
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        naive_dst = self._naive_is_dst(dt)
+        return (not naive_dst and
+                (naive_dst != self._naive_is_dst(dt - self._dst_saved)))
+
+    def _naive_is_dst(self, dt):
+        timestamp = _datetime_to_timestamp(dt)
+        return time.localtime(timestamp + time.timezone).tm_isdst
+
+    def _isdst(self, dt, fold_naive=True):
+        # We can't use mktime here. It is unstable when deciding if
+        # the hour near to a change is DST or not.
+        #
+        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,
+        #                         dt.minute, dt.second, dt.weekday(), 0, -1))
+        # return time.localtime(timestamp).tm_isdst
+        #
+        # The code above yields the following result:
+        #
+        # >>> import tz, datetime
+        # >>> t = tz.tzlocal()
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRDT'
+        # >>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()
+        # 'BRST'
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRST'
+        # >>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()
+        # 'BRDT'
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRDT'
+        #
+        # Here is a more stable implementation:
+        #
+        if not self._hasdst:
+            return False
+
+        # Check for ambiguous times:
+        dstval = self._naive_is_dst(dt)
+        fold = getattr(dt, 'fold', None)
+
+        if self.is_ambiguous(dt):
+            if fold is not None:
+                return not self._fold(dt)
+            else:
+                return True
+
+        return dstval
+
+    def __eq__(self, other):
+        if isinstance(other, tzlocal):
+            return (self._std_offset == other._std_offset and
+                    self._dst_offset == other._dst_offset)
+        elif isinstance(other, tzutc):
+            return (not self._hasdst and
+                    self._tznames[0] in {'UTC', 'GMT'} and
+                    self._std_offset == ZERO)
+        elif isinstance(other, tzoffset):
+            return (not self._hasdst and
+                    self._tznames[0] == other._name and
+                    self._std_offset == other._offset)
+        else:
+            return NotImplemented
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s()" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
+
+
+class _ttinfo(object):
+    __slots__ = ["offset", "delta", "isdst", "abbr",
+                 "isstd", "isgmt", "dstoffset"]
+
+    def __init__(self):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+
+    def __repr__(self):
+        l = []
+        for attr in self.__slots__:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("%s=%s" % (attr, repr(value)))
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))
+
+    def __eq__(self, other):
+        if not isinstance(other, _ttinfo):
+            return NotImplemented
+
+        return (self.offset == other.offset and
+                self.delta == other.delta and
+                self.isdst == other.isdst and
+                self.abbr == other.abbr and
+                self.isstd == other.isstd and
+                self.isgmt == other.isgmt and
+                self.dstoffset == other.dstoffset)
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __getstate__(self):
+        state = {}
+        for name in self.__slots__:
+            state[name] = getattr(self, name, None)
+        return state
+
+    def __setstate__(self, state):
+        for name in self.__slots__:
+            if name in state:
+                setattr(self, name, state[name])
+
+
+class _tzfile(object):
+    """
+    Lightweight class for holding the relevant transition and time zone
+    information read from binary tzfiles.
+    """
+    attrs = ['trans_list', 'trans_list_utc', 'trans_idx', 'ttinfo_list',
+             'ttinfo_std', 'ttinfo_dst', 'ttinfo_before', 'ttinfo_first']
+
+    def __init__(self, **kwargs):
+        for attr in self.attrs:
+            setattr(self, attr, kwargs.get(attr, None))
+
+
+class tzfile(_tzinfo):
+    """
+    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)``
+    format timezone files to extract current and historical zone information.
+
+    :param fileobj:
+        This can be an opened file stream or a file name that the time zone
+        information can be read from.
+
+    :param filename:
+        This is an optional parameter specifying the source of the time zone
+        information in the event that ``fileobj`` is a file object. If omitted
+        and ``fileobj`` is a file stream, this parameter will be set either to
+        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.
+
+    See `Sources for Time Zone and Daylight Saving Time Data
+    <https://data.iana.org/time-zones/tz-link.html>`_ for more information.
+    Time zone files can be compiled from the `IANA Time Zone database files
+    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler
+    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_
+
+    .. note::
+
+        Only construct a ``tzfile`` directly if you have a specific timezone
+        file on disk that you want to read into a Python ``tzinfo`` object.
+        If you want to get a ``tzfile`` representing a specific IANA zone,
+        (e.g. ``'America/New_York'``), you should call
+        :func:`dateutil.tz.gettz` with the zone identifier.
+
+
+    **Examples:**
+
+    Using the US Eastern time zone as an example, we can see that a ``tzfile``
+    provides time zone information for the standard Daylight Saving offsets:
+
+    .. testsetup:: tzfile
+
+        from dateutil.tz import gettz
+        from datetime import datetime
+
+    .. doctest:: tzfile
+
+        >>> NYC = gettz('America/New_York')
+        >>> NYC
+        tzfile('/usr/share/zoneinfo/America/New_York')
+
+        >>> print(datetime(2016, 1, 3, tzinfo=NYC))     # EST
+        2016-01-03 00:00:00-05:00
+
+        >>> print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT
+        2016-07-07 00:00:00-04:00
+
+
+    The ``tzfile`` structure contains a fully history of the time zone,
+    so historical dates will also have the right offsets. For example, before
+    the adoption of the UTC standards, New York used local solar  mean time:
+
+    .. doctest:: tzfile
+
+       >>> print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT
+       1901-04-12 00:00:00-04:56
+
+    And during World War II, New York was on "Eastern War Time", which was a
+    state of permanent daylight saving time:
+
+    .. doctest:: tzfile
+
+        >>> print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT
+        1944-02-07 00:00:00-04:00
+
+    """
+
+    def __init__(self, fileobj, filename=None):
+        super(tzfile, self).__init__()
+
+        file_opened_here = False
+        if isinstance(fileobj, string_types):
+            self._filename = fileobj
+            fileobj = open(fileobj, 'rb')
+            file_opened_here = True
+        elif filename is not None:
+            self._filename = filename
+        elif hasattr(fileobj, "name"):
+            self._filename = fileobj.name
+        else:
+            self._filename = repr(fileobj)
+
+        if fileobj is not None:
+            if not file_opened_here:
+                fileobj = _nullcontext(fileobj)
+
+            with fileobj as file_stream:
+                tzobj = self._read_tzfile(file_stream)
+
+            self._set_tzdata(tzobj)
+
+    def _set_tzdata(self, tzobj):
+        """ Set the time zone data of this object from a _tzfile object """
+        # Copy the relevant attributes over as private attributes
+        for attr in _tzfile.attrs:
+            setattr(self, '_' + attr, getattr(tzobj, attr))
+
+    def _read_tzfile(self, fileobj):
+        out = _tzfile()
+
+        # From tzfile(5):
+        #
+        # The time zone information files used by tzset(3)
+        # begin with the magic characters "TZif" to identify
+        # them as time zone information files, followed by
+        # sixteen bytes reserved for future use, followed by
+        # six four-byte values of type long, written in a
+        # ``standard'' byte order (the high-order  byte
+        # of the value is written first).
+        if fileobj.read(4).decode() != "TZif":
+            raise ValueError("magic not found")
+
+        fileobj.read(16)
+
+        (
+            # The number of UTC/local indicators stored in the file.
+            ttisgmtcnt,
+
+            # The number of standard/wall indicators stored in the file.
+            ttisstdcnt,
+
+            # The number of leap seconds for which data is
+            # stored in the file.
+            leapcnt,
+
+            # The number of "transition times" for which data
+            # is stored in the file.
+            timecnt,
+
+            # The number of "local time types" for which data
+            # is stored in the file (must not be zero).
+            typecnt,
+
+            # The  number  of  characters  of "time zone
+            # abbreviation strings" stored in the file.
+            charcnt,
+
+        ) = struct.unpack(">6l", fileobj.read(24))
+
+        # The above header is followed by tzh_timecnt four-byte
+        # values  of  type long,  sorted  in ascending order.
+        # These values are written in ``standard'' byte order.
+        # Each is used as a transition time (as  returned  by
+        # time(2)) at which the rules for computing local time
+        # change.
+
+        if timecnt:
+            out.trans_list_utc = list(struct.unpack(">%dl" % timecnt,
+                                                    fileobj.read(timecnt*4)))
+        else:
+            out.trans_list_utc = []
+
+        # Next come tzh_timecnt one-byte values of type unsigned
+        # char; each one tells which of the different types of
+        # ``local time'' types described in the file is associated
+        # with the same-indexed transition time. These values
+        # serve as indices into an array of ttinfo structures that
+        # appears next in the file.
+
+        if timecnt:
+            out.trans_idx = struct.unpack(">%dB" % timecnt,
+                                          fileobj.read(timecnt))
+        else:
+            out.trans_idx = []
+
+        # Each ttinfo structure is written as a four-byte value
+        # for tt_gmtoff  of  type long,  in  a  standard  byte
+        # order, followed  by a one-byte value for tt_isdst
+        # and a one-byte  value  for  tt_abbrind.   In  each
+        # structure, tt_gmtoff  gives  the  number  of
+        # seconds to be added to UTC, tt_isdst tells whether
+        # tm_isdst should be set by  localtime(3),  and
+        # tt_abbrind serves  as an index into the array of
+        # time zone abbreviation characters that follow the
+        # ttinfo structure(s) in the file.
+
+        ttinfo = []
+
+        for i in range(typecnt):
+            ttinfo.append(struct.unpack(">lbb", fileobj.read(6)))
+
+        abbr = fileobj.read(charcnt).decode()
+
+        # Then there are tzh_leapcnt pairs of four-byte
+        # values, written in  standard byte  order;  the
+        # first  value  of  each pair gives the time (as
+        # returned by time(2)) at which a leap second
+        # occurs;  the  second  gives the  total  number of
+        # leap seconds to be applied after the given time.
+        # The pairs of values are sorted in ascending order
+        # by time.
+
+        # Not used, for now (but seek for correct file position)
+        if leapcnt:
+            fileobj.seek(leapcnt * 8, os.SEEK_CUR)
+
+        # Then there are tzh_ttisstdcnt standard/wall
+        # indicators, each stored as a one-byte value;
+        # they tell whether the transition times associated
+        # with local time types were specified as standard
+        # time or wall clock time, and are used when
+        # a time zone file is used in handling POSIX-style
+        # time zone environment variables.
+
+        if ttisstdcnt:
+            isstd = struct.unpack(">%db" % ttisstdcnt,
+                                  fileobj.read(ttisstdcnt))
+
+        # Finally, there are tzh_ttisgmtcnt UTC/local
+        # indicators, each stored as a one-byte value;
+        # they tell whether the transition times associated
+        # with local time types were specified as UTC or
+        # local time, and are used when a time zone file
+        # is used in handling POSIX-style time zone envi-
+        # ronment variables.
+
+        if ttisgmtcnt:
+            isgmt = struct.unpack(">%db" % ttisgmtcnt,
+                                  fileobj.read(ttisgmtcnt))
+
+        # Build ttinfo list
+        out.ttinfo_list = []
+        for i in range(typecnt):
+            gmtoff, isdst, abbrind = ttinfo[i]
+            gmtoff = _get_supported_offset(gmtoff)
+            tti = _ttinfo()
+            tti.offset = gmtoff
+            tti.dstoffset = datetime.timedelta(0)
+            tti.delta = datetime.timedelta(seconds=gmtoff)
+            tti.isdst = isdst
+            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]
+            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)
+            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)
+            out.ttinfo_list.append(tti)
+
+        # Replace ttinfo indexes for ttinfo objects.
+        out.trans_idx = [out.ttinfo_list[idx] for idx in out.trans_idx]
+
+        # Set standard, dst, and before ttinfos. before will be
+        # used when a given time is before any transitions,
+        # and will be set to the first non-dst ttinfo, or to
+        # the first dst, if all of them are dst.
+        out.ttinfo_std = None
+        out.ttinfo_dst = None
+        out.ttinfo_before = None
+        if out.ttinfo_list:
+            if not out.trans_list_utc:
+                out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[0]
+            else:
+                for i in range(timecnt-1, -1, -1):
+                    tti = out.trans_idx[i]
+                    if not out.ttinfo_std and not tti.isdst:
+                        out.ttinfo_std = tti
+                    elif not out.ttinfo_dst and tti.isdst:
+                        out.ttinfo_dst = tti
+
+                    if out.ttinfo_std and out.ttinfo_dst:
+                        break
+                else:
+                    if out.ttinfo_dst and not out.ttinfo_std:
+                        out.ttinfo_std = out.ttinfo_dst
+
+                for tti in out.ttinfo_list:
+                    if not tti.isdst:
+                        out.ttinfo_before = tti
+                        break
+                else:
+                    out.ttinfo_before = out.ttinfo_list[0]
+
+        # Now fix transition times to become relative to wall time.
+        #
+        # I'm not sure about this. In my tests, the tz source file
+        # is setup to wall time, and in the binary file isstd and
+        # isgmt are off, so it should be in wall time. OTOH, it's
+        # always in gmt time. Let me know if you have comments
+        # about this.
+        lastdst = None
+        lastoffset = None
+        lastdstoffset = None
+        lastbaseoffset = None
+        out.trans_list = []
+
+        for i, tti in enumerate(out.trans_idx):
+            offset = tti.offset
+            dstoffset = 0
+
+            if lastdst is not None:
+                if tti.isdst:
+                    if not lastdst:
+                        dstoffset = offset - lastoffset
+
+                    if not dstoffset and lastdstoffset:
+                        dstoffset = lastdstoffset
+
+                    tti.dstoffset = datetime.timedelta(seconds=dstoffset)
+                    lastdstoffset = dstoffset
+
+            # If a time zone changes its base offset during a DST transition,
+            # then you need to adjust by the previous base offset to get the
+            # transition time in local time. Otherwise you use the current
+            # base offset. Ideally, I would have some mathematical proof of
+            # why this is true, but I haven't really thought about it enough.
+            baseoffset = offset - dstoffset
+            adjustment = baseoffset
+            if (lastbaseoffset is not None and baseoffset != lastbaseoffset
+                    and tti.isdst != lastdst):
+                # The base DST has changed
+                adjustment = lastbaseoffset
+
+            lastdst = tti.isdst
+            lastoffset = offset
+            lastbaseoffset = baseoffset
+
+            out.trans_list.append(out.trans_list_utc[i] + adjustment)
+
+        out.trans_idx = tuple(out.trans_idx)
+        out.trans_list = tuple(out.trans_list)
+        out.trans_list_utc = tuple(out.trans_list_utc)
+
+        return out
+
+    def _find_last_transition(self, dt, in_utc=False):
+        # If there's no list, there are no transitions to find
+        if not self._trans_list:
+            return None
+
+        timestamp = _datetime_to_timestamp(dt)
+
+        # Find where the timestamp fits in the transition list - if the
+        # timestamp is a transition time, it's part of the "after" period.
+        trans_list = self._trans_list_utc if in_utc else self._trans_list
+        idx = bisect.bisect_right(trans_list, timestamp)
+
+        # We want to know when the previous transition was, so subtract off 1
+        return idx - 1
+
+    def _get_ttinfo(self, idx):
+        # For no list or after the last transition, default to _ttinfo_std
+        if idx is None or (idx + 1) >= len(self._trans_list):
+            return self._ttinfo_std
+
+        # If there is a list and the time is before it, return _ttinfo_before
+        if idx < 0:
+            return self._ttinfo_before
+
+        return self._trans_idx[idx]
+
+    def _find_ttinfo(self, dt):
+        idx = self._resolve_ambiguous_time(dt)
+
+        return self._get_ttinfo(idx)
+
+    def fromutc(self, dt):
+        """
+        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.
+
+        :param dt:
+            A :py:class:`datetime.datetime` object.
+
+        :raises TypeError:
+            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.
+
+        :raises ValueError:
+            Raised if this is called with a ``dt`` which does not have this
+            ``tzinfo`` attached.
+
+        :return:
+            Returns a :py:class:`datetime.datetime` object representing the
+            wall time in ``self``'s time zone.
+        """
+        # These isinstance checks are in datetime.tzinfo, so we'll preserve
+        # them, even if we don't care about duck typing.
+        if not isinstance(dt, datetime.datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        # First treat UTC as wall time and get the transition we're in.
+        idx = self._find_last_transition(dt, in_utc=True)
+        tti = self._get_ttinfo(idx)
+
+        dt_out = dt + datetime.timedelta(seconds=tti.offset)
+
+        fold = self.is_ambiguous(dt_out, idx=idx)
+
+        return enfold(dt_out, fold=int(fold))
+
+    def is_ambiguous(self, dt, idx=None):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        if idx is None:
+            idx = self._find_last_transition(dt)
+
+        # Calculate the difference in offsets from current to previous
+        timestamp = _datetime_to_timestamp(dt)
+        tti = self._get_ttinfo(idx)
+
+        if idx is None or idx <= 0:
+            return False
+
+        od = self._get_ttinfo(idx - 1).offset - tti.offset
+        tt = self._trans_list[idx]          # Transition time
+
+        return timestamp < tt + od
+
+    def _resolve_ambiguous_time(self, dt):
+        idx = self._find_last_transition(dt)
+
+        # If we have no transitions, return the index
+        _fold = self._fold(dt)
+        if idx is None or idx == 0:
+            return idx
+
+        # If it's ambiguous and we're in a fold, shift to a different index.
+        idx_offset = int(not _fold and self.is_ambiguous(dt, idx))
+
+        return idx - idx_offset
+
+    def utcoffset(self, dt):
+        if dt is None:
+            return None
+
+        if not self._ttinfo_std:
+            return ZERO
+
+        return self._find_ttinfo(dt).delta
+
+    def dst(self, dt):
+        if dt is None:
+            return None
+
+        if not self._ttinfo_dst:
+            return ZERO
+
+        tti = self._find_ttinfo(dt)
+
+        if not tti.isdst:
+            return ZERO
+
+        # The documentation says that utcoffset()-dst() must
+        # be constant for every dt.
+        return tti.dstoffset
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        if not self._ttinfo_std or dt is None:
+            return None
+        return self._find_ttinfo(dt).abbr
+
+    def __eq__(self, other):
+        if not isinstance(other, tzfile):
+            return NotImplemented
+        return (self._trans_list == other._trans_list and
+                self._trans_idx == other._trans_idx and
+                self._ttinfo_list == other._ttinfo_list)
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._filename))
+
+    def __reduce__(self):
+        return self.__reduce_ex__(None)
+
+    def __reduce_ex__(self, protocol):
+        return (self.__class__, (None, self._filename), self.__dict__)
+
+
+class tzrange(tzrangebase):
+    """
+    The ``tzrange`` object is a time zone specified by a set of offsets and
+    abbreviations, equivalent to the way the ``TZ`` variable can be specified
+    in POSIX-like systems, but using Python delta objects to specify DST
+    start, end and offsets.
+
+    :param stdabbr:
+        The abbreviation for standard time (e.g. ``'EST'``).
+
+    :param stdoffset:
+        An integer or :class:`datetime.timedelta` object or equivalent
+        specifying the base offset from UTC.
+
+        If unspecified, +00:00 is used.
+
+    :param dstabbr:
+        The abbreviation for DST / "Summer" time (e.g. ``'EDT'``).
+
+        If specified, with no other DST information, DST is assumed to occur
+        and the default behavior or ``dstoffset``, ``start`` and ``end`` is
+        used. If unspecified and no other DST information is specified, it
+        is assumed that this zone has no DST.
+
+        If this is unspecified and other DST information is *is* specified,
+        DST occurs in the zone but the time zone abbreviation is left
+        unchanged.
+
+    :param dstoffset:
+        A an integer or :class:`datetime.timedelta` object or equivalent
+        specifying the UTC offset during DST. If unspecified and any other DST
+        information is specified, it is assumed to be the STD offset +1 hour.
+
+    :param start:
+        A :class:`relativedelta.relativedelta` object or equivalent specifying
+        the time and time of year that daylight savings time starts. To
+        specify, for example, that DST starts at 2AM on the 2nd Sunday in
+        March, pass:
+
+            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``
+
+        If unspecified and any other DST information is specified, the default
+        value is 2 AM on the first Sunday in April.
+
+    :param end:
+        A :class:`relativedelta.relativedelta` object or equivalent
+        representing the time and time of year that daylight savings time
+        ends, with the same specification method as in ``start``. One note is
+        that this should point to the first time in the *standard* zone, so if
+        a transition occurs at 2AM in the DST zone and the clocks are set back
+        1 hour to 1AM, set the ``hours`` parameter to +1.
+
+
+    **Examples:**
+
+    .. testsetup:: tzrange
+
+        from dateutil.tz import tzrange, tzstr
+
+    .. doctest:: tzrange
+
+        >>> tzstr('EST5EDT') == tzrange("EST", -18000, "EDT")
+        True
+
+        >>> from dateutil.relativedelta import *
+        >>> range1 = tzrange("EST", -18000, "EDT")
+        >>> range2 = tzrange("EST", -18000, "EDT", -14400,
+        ...                  relativedelta(hours=+2, month=4, day=1,
+        ...                                weekday=SU(+1)),
+        ...                  relativedelta(hours=+1, month=10, day=31,
+        ...                                weekday=SU(-1)))
+        >>> tzstr('EST5EDT') == range1 == range2
+        True
+
+    """
+    def __init__(self, stdabbr, stdoffset=None,
+                 dstabbr=None, dstoffset=None,
+                 start=None, end=None):
+
+        global relativedelta
+        from dateutil import relativedelta
+
+        self._std_abbr = stdabbr
+        self._dst_abbr = dstabbr
+
+        try:
+            stdoffset = stdoffset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        try:
+            dstoffset = dstoffset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        if stdoffset is not None:
+            self._std_offset = datetime.timedelta(seconds=stdoffset)
+        else:
+            self._std_offset = ZERO
+
+        if dstoffset is not None:
+            self._dst_offset = datetime.timedelta(seconds=dstoffset)
+        elif dstabbr and stdoffset is not None:
+            self._dst_offset = self._std_offset + datetime.timedelta(hours=+1)
+        else:
+            self._dst_offset = ZERO
+
+        if dstabbr and start is None:
+            self._start_delta = relativedelta.relativedelta(
+                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))
+        else:
+            self._start_delta = start
+
+        if dstabbr and end is None:
+            self._end_delta = relativedelta.relativedelta(
+                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))
+        else:
+            self._end_delta = end
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = bool(self._start_delta)
+
+    def transitions(self, year):
+        """
+        For a given year, get the DST on and off transition times, expressed
+        always on the standard time side. For zones with no transitions, this
+        function returns ``None``.
+
+        :param year:
+            The year whose transitions you would like to query.
+
+        :return:
+            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
+            ``(dston, dstoff)`` for zones with an annual DST transition, or
+            ``None`` for fixed offset zones.
+        """
+        if not self.hasdst:
+            return None
+
+        base_year = datetime.datetime(year, 1, 1)
+
+        start = base_year + self._start_delta
+        end = base_year + self._end_delta
+
+        return (start, end)
+
+    def __eq__(self, other):
+        if not isinstance(other, tzrange):
+            return NotImplemented
+
+        return (self._std_abbr == other._std_abbr and
+                self._dst_abbr == other._dst_abbr and
+                self._std_offset == other._std_offset and
+                self._dst_offset == other._dst_offset and
+                self._start_delta == other._start_delta and
+                self._end_delta == other._end_delta)
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_base_offset_
+
+
+@six.add_metaclass(_TzStrFactory)
+class tzstr(tzrange):
+    """
+    ``tzstr`` objects are time zone objects specified by a time-zone string as
+    it would be passed to a ``TZ`` variable on POSIX-style systems (see
+    the `GNU C Library: TZ Variable`_ for more details).
+
+    There is one notable exception, which is that POSIX-style time zones use an
+    inverted offset format, so normally ``GMT+3`` would be parsed as an offset
+    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an
+    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX
+    behavior, pass a ``True`` value to ``posix_offset``.
+
+    The :class:`tzrange` object provides the same functionality, but is
+    specified using :class:`relativedelta.relativedelta` objects. rather than
+    strings.
+
+    :param s:
+        A time zone string in ``TZ`` variable format. This can be a
+        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x:
+        :class:`unicode`) or a stream emitting unicode characters
+        (e.g. :class:`StringIO`).
+
+    :param posix_offset:
+        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or
+        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the
+        POSIX standard.
+
+    .. caution::
+
+        Prior to version 2.7.0, this function also supported time zones
+        in the format:
+
+            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``
+            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``
+
+        This format is non-standard and has been deprecated; this function
+        will raise a :class:`DeprecatedTZFormatWarning` until
+        support is removed in a future version.
+
+    .. _`GNU C Library: TZ Variable`:
+        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
+    """
+    def __init__(self, s, posix_offset=False):
+        global parser
+        from dateutil.parser import _parser as parser
+
+        self._s = s
+
+        res = parser._parsetz(s)
+        if res is None or res.any_unused_tokens:
+            raise ValueError("unknown string format")
+
+        # Here we break the compatibility with the TZ variable handling.
+        # GMT-3 actually *means* the timezone -3.
+        if res.stdabbr in ("GMT", "UTC") and not posix_offset:
+            res.stdoffset *= -1
+
+        # We must initialize it first, since _delta() needs
+        # _std_offset and _dst_offset set. Use False in start/end
+        # to avoid building it two times.
+        tzrange.__init__(self, res.stdabbr, res.stdoffset,
+                         res.dstabbr, res.dstoffset,
+                         start=False, end=False)
+
+        if not res.dstabbr:
+            self._start_delta = None
+            self._end_delta = None
+        else:
+            self._start_delta = self._delta(res.start)
+            if self._start_delta:
+                self._end_delta = self._delta(res.end, isend=1)
+
+        self.hasdst = bool(self._start_delta)
+
+    def _delta(self, x, isend=0):
+        from dateutil import relativedelta
+        kwargs = {}
+        if x.month is not None:
+            kwargs["month"] = x.month
+            if x.weekday is not None:
+                kwargs["weekday"] = relativedelta.weekday(x.weekday, x.week)
+                if x.week > 0:
+                    kwargs["day"] = 1
+                else:
+                    kwargs["day"] = 31
+            elif x.day:
+                kwargs["day"] = x.day
+        elif x.yday is not None:
+            kwargs["yearday"] = x.yday
+        elif x.jyday is not None:
+            kwargs["nlyearday"] = x.jyday
+        if not kwargs:
+            # Default is to start on first sunday of april, and end
+            # on last sunday of october.
+            if not isend:
+                kwargs["month"] = 4
+                kwargs["day"] = 1
+                kwargs["weekday"] = relativedelta.SU(+1)
+            else:
+                kwargs["month"] = 10
+                kwargs["day"] = 31
+                kwargs["weekday"] = relativedelta.SU(-1)
+        if x.time is not None:
+            kwargs["seconds"] = x.time
+        else:
+            # Default is 2AM.
+            kwargs["seconds"] = 7200
+        if isend:
+            # Convert to standard time, to follow the documented way
+            # of working with the extra hour. See the documentation
+            # of the tzinfo class.
+            delta = self._dst_offset - self._std_offset
+            kwargs["seconds"] -= delta.seconds + delta.days * 86400
+        return relativedelta.relativedelta(**kwargs)
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
+
+
+class _tzicalvtzcomp(object):
+    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
+                 tzname=None, rrule=None):
+        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)
+        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)
+        self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom
+        self.isdst = isdst
+        self.tzname = tzname
+        self.rrule = rrule
+
+
+class _tzicalvtz(_tzinfo):
+    def __init__(self, tzid, comps=[]):
+        super(_tzicalvtz, self).__init__()
+
+        self._tzid = tzid
+        self._comps = comps
+        self._cachedate = []
+        self._cachecomp = []
+        self._cache_lock = _thread.allocate_lock()
+
+    def _find_comp(self, dt):
+        if len(self._comps) == 1:
+            return self._comps[0]
+
+        dt = dt.replace(tzinfo=None)
+
+        try:
+            with self._cache_lock:
+                return self._cachecomp[self._cachedate.index(
+                    (dt, self._fold(dt)))]
+        except ValueError:
+            pass
+
+        lastcompdt = None
+        lastcomp = None
+
+        for comp in self._comps:
+            compdt = self._find_compdt(comp, dt)
+
+            if compdt and (not lastcompdt or lastcompdt < compdt):
+                lastcompdt = compdt
+                lastcomp = comp
+
+        if not lastcomp:
+            # RFC says nothing about what to do when a given
+            # time is before the first onset date. We'll look for the
+            # first standard component, or the first component, if
+            # none is found.
+            for comp in self._comps:
+                if not comp.isdst:
+                    lastcomp = comp
+                    break
+            else:
+                lastcomp = comp[0]
+
+        with self._cache_lock:
+            self._cachedate.insert(0, (dt, self._fold(dt)))
+            self._cachecomp.insert(0, lastcomp)
+
+            if len(self._cachedate) > 10:
+                self._cachedate.pop()
+                self._cachecomp.pop()
+
+        return lastcomp
+
+    def _find_compdt(self, comp, dt):
+        if comp.tzoffsetdiff < ZERO and self._fold(dt):
+            dt -= comp.tzoffsetdiff
+
+        compdt = comp.rrule.before(dt, inc=True)
+
+        return compdt
+
+    def utcoffset(self, dt):
+        if dt is None:
+            return None
+
+        return self._find_comp(dt).tzoffsetto
+
+    def dst(self, dt):
+        comp = self._find_comp(dt)
+        if comp.isdst:
+            return comp.tzoffsetdiff
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._find_comp(dt).tzname
+
+    def __repr__(self):
+        return "<tzicalvtz %s>" % repr(self._tzid)
+
+    __reduce__ = object.__reduce__
+
+
+class tzical(object):
+    """
+    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure
+    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.
+
+    :param `fileobj`:
+        A file or stream in iCalendar format, which should be UTF-8 encoded
+        with CRLF endings.
+
+    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545
+    """
+    def __init__(self, fileobj):
+        global rrule
+        from dateutil import rrule
+
+        if isinstance(fileobj, string_types):
+            self._s = fileobj
+            # ical should be encoded in UTF-8 with CRLF
+            fileobj = open(fileobj, 'r')
+        else:
+            self._s = getattr(fileobj, 'name', repr(fileobj))
+            fileobj = _nullcontext(fileobj)
+
+        self._vtz = {}
+
+        with fileobj as fobj:
+            self._parse_rfc(fobj.read())
+
+    def keys(self):
+        """
+        Retrieves the available time zones as a list.
+        """
+        return list(self._vtz.keys())
+
+    def get(self, tzid=None):
+        """
+        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.
+
+        :param tzid:
+            If there is exactly one time zone available, omitting ``tzid``
+            or passing :py:const:`None` value returns it. Otherwise a valid
+            key (which can be retrieved from :func:`keys`) is required.
+
+        :raises ValueError:
+            Raised if ``tzid`` is not specified but there are either more
+            or fewer than 1 zone defined.
+
+        :returns:
+            Returns either a :py:class:`datetime.tzinfo` object representing
+            the relevant time zone or :py:const:`None` if the ``tzid`` was
+            not found.
+        """
+        if tzid is None:
+            if len(self._vtz) == 0:
+                raise ValueError("no timezones defined")
+            elif len(self._vtz) > 1:
+                raise ValueError("more than one timezone available")
+            tzid = next(iter(self._vtz))
+
+        return self._vtz.get(tzid)
+
+    def _parse_offset(self, s):
+        s = s.strip()
+        if not s:
+            raise ValueError("empty offset")
+        if s[0] in ('+', '-'):
+            signal = (-1, +1)[s[0] == '+']
+            s = s[1:]
+        else:
+            signal = +1
+        if len(s) == 4:
+            return (int(s[:2]) * 3600 + int(s[2:]) * 60) * signal
+        elif len(s) == 6:
+            return (int(s[:2]) * 3600 + int(s[2:4]) * 60 + int(s[4:])) * signal
+        else:
+            raise ValueError("invalid offset: " + s)
+
+    def _parse_rfc(self, s):
+        lines = s.splitlines()
+        if not lines:
+            raise ValueError("empty string")
+
+        # Unfold
+        i = 0
+        while i < len(lines):
+            line = lines[i].rstrip()
+            if not line:
+                del lines[i]
+            elif i > 0 and line[0] == " ":
+                lines[i-1] += line[1:]
+                del lines[i]
+            else:
+                i += 1
+
+        tzid = None
+        comps = []
+        invtz = False
+        comptype = None
+        for line in lines:
+            if not line:
+                continue
+            name, value = line.split(':', 1)
+            parms = name.split(';')
+            if not parms:
+                raise ValueError("empty property name")
+            name = parms[0].upper()
+            parms = parms[1:]
+            if invtz:
+                if name == "BEGIN":
+                    if value in ("STANDARD", "DAYLIGHT"):
+                        # Process component
+                        pass
+                    else:
+                        raise ValueError("unknown component: "+value)
+                    comptype = value
+                    founddtstart = False
+                    tzoffsetfrom = None
+                    tzoffsetto = None
+                    rrulelines = []
+                    tzname = None
+                elif name == "END":
+                    if value == "VTIMEZONE":
+                        if comptype:
+                            raise ValueError("component not closed: "+comptype)
+                        if not tzid:
+                            raise ValueError("mandatory TZID not found")
+                        if not comps:
+                            raise ValueError(
+                                "at least one component is needed")
+                        # Process vtimezone
+                        self._vtz[tzid] = _tzicalvtz(tzid, comps)
+                        invtz = False
+                    elif value == comptype:
+                        if not founddtstart:
+                            raise ValueError("mandatory DTSTART not found")
+                        if tzoffsetfrom is None:
+                            raise ValueError(
+                                "mandatory TZOFFSETFROM not found")
+                        if tzoffsetto is None:
+                            raise ValueError(
+                                "mandatory TZOFFSETFROM not found")
+                        # Process component
+                        rr = None
+                        if rrulelines:
+                            rr = rrule.rrulestr("\n".join(rrulelines),
+                                                compatible=True,
+                                                ignoretz=True,
+                                                cache=True)
+                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,
+                                              (comptype == "DAYLIGHT"),
+                                              tzname, rr)
+                        comps.append(comp)
+                        comptype = None
+                    else:
+                        raise ValueError("invalid component end: "+value)
+                elif comptype:
+                    if name == "DTSTART":
+                        # DTSTART in VTIMEZONE takes a subset of valid RRULE
+                        # values under RFC 5545.
+                        for parm in parms:
+                            if parm != 'VALUE=DATE-TIME':
+                                msg = ('Unsupported DTSTART param in ' +
+                                       'VTIMEZONE: ' + parm)
+                                raise ValueError(msg)
+                        rrulelines.append(line)
+                        founddtstart = True
+                    elif name in ("RRULE", "RDATE", "EXRULE", "EXDATE"):
+                        rrulelines.append(line)
+                    elif name == "TZOFFSETFROM":
+                        if parms:
+                            raise ValueError(
+                                "unsupported %s parm: %s " % (name, parms[0]))
+                        tzoffsetfrom = self._parse_offset(value)
+                    elif name == "TZOFFSETTO":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZOFFSETTO parm: "+parms[0])
+                        tzoffsetto = self._parse_offset(value)
+                    elif name == "TZNAME":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZNAME parm: "+parms[0])
+                        tzname = value
+                    elif name == "COMMENT":
+                        pass
+                    else:
+                        raise ValueError("unsupported property: "+name)
+                else:
+                    if name == "TZID":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZID parm: "+parms[0])
+                        tzid = value
+                    elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"):
+                        pass
+                    else:
+                        raise ValueError("unsupported property: "+name)
+            elif name == "BEGIN" and value == "VTIMEZONE":
+                tzid = None
+                comps = []
+                invtz = True
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
+
+
+if sys.platform != "win32":
+    TZFILES = ["/etc/localtime", "localtime"]
+    TZPATHS = ["/usr/share/zoneinfo",
+               "/usr/lib/zoneinfo",
+               "/usr/share/lib/zoneinfo",
+               "/etc/zoneinfo"]
+else:
+    TZFILES = []
+    TZPATHS = []
+
+
+def __get_gettz():
+    tzlocal_classes = (tzlocal,)
+    if tzwinlocal is not None:
+        tzlocal_classes += (tzwinlocal,)
+
+    class GettzFunc(object):
+        """
+        Retrieve a time zone object from a string representation
+
+        This function is intended to retrieve the :py:class:`tzinfo` subclass
+        that best represents the time zone that would be used if a POSIX
+        `TZ variable`_ were set to the same value.
+
+        If no argument or an empty string is passed to ``gettz``, local time
+        is returned:
+
+        .. code-block:: python3
+
+            >>> gettz()
+            tzfile('/etc/localtime')
+
+        This function is also the preferred way to map IANA tz database keys
+        to :class:`tzfile` objects:
+
+        .. code-block:: python3
+
+            >>> gettz('Pacific/Kiritimati')
+            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati')
+
+        On Windows, the standard is extended to include the Windows-specific
+        zone names provided by the operating system:
+
+        .. code-block:: python3
+
+            >>> gettz('Egypt Standard Time')
+            tzwin('Egypt Standard Time')
+
+        Passing a GNU ``TZ`` style string time zone specification returns a
+        :class:`tzstr` object:
+
+        .. code-block:: python3
+
+            >>> gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
+            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
+
+        :param name:
+            A time zone name (IANA, or, on Windows, Windows keys), location of
+            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone
+            specifier. An empty string, no argument or ``None`` is interpreted
+            as local time.
+
+        :return:
+            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo`
+            subclasses.
+
+        .. versionchanged:: 2.7.0
+
+            After version 2.7.0, any two calls to ``gettz`` using the same
+            input strings will return the same object:
+
+            .. code-block:: python3
+
+                >>> tz.gettz('America/Chicago') is tz.gettz('America/Chicago')
+                True
+
+            In addition to improving performance, this ensures that
+            `"same zone" semantics`_ are used for datetimes in the same zone.
+
+
+        .. _`TZ variable`:
+            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
+
+        .. _`"same zone" semantics`:
+            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html
+        """
+        def __init__(self):
+
+            self.__instances = weakref.WeakValueDictionary()
+            self.__strong_cache_size = 8
+            self.__strong_cache = OrderedDict()
+            self._cache_lock = _thread.allocate_lock()
+
+        def __call__(self, name=None):
+            with self._cache_lock:
+                rv = self.__instances.get(name, None)
+
+                if rv is None:
+                    rv = self.nocache(name=name)
+                    if not (name is None
+                            or isinstance(rv, tzlocal_classes)
+                            or rv is None):
+                        # tzlocal is slightly more complicated than the other
+                        # time zone providers because it depends on environment
+                        # at construction time, so don't cache that.
+                        #
+                        # We also cannot store weak references to None, so we
+                        # will also not store that.
+                        self.__instances[name] = rv
+                    else:
+                        # No need for strong caching, return immediately
+                        return rv
+
+                self.__strong_cache[name] = self.__strong_cache.pop(name, rv)
+
+                if len(self.__strong_cache) > self.__strong_cache_size:
+                    self.__strong_cache.popitem(last=False)
+
+            return rv
+
+        def set_cache_size(self, size):
+            with self._cache_lock:
+                self.__strong_cache_size = size
+                while len(self.__strong_cache) > size:
+                    self.__strong_cache.popitem(last=False)
+
+        def cache_clear(self):
+            with self._cache_lock:
+                self.__instances = weakref.WeakValueDictionary()
+                self.__strong_cache.clear()
+
+        @staticmethod
+        def nocache(name=None):
+            """A non-cached version of gettz"""
+            tz = None
+            if not name:
+                try:
+                    name = os.environ["TZ"]
+                except KeyError:
+                    pass
+            if name is None or name in ("", ":"):
+                for filepath in TZFILES:
+                    if not os.path.isabs(filepath):
+                        filename = filepath
+                        for path in TZPATHS:
+                            filepath = os.path.join(path, filename)
+                            if os.path.isfile(filepath):
+                                break
+                        else:
+                            continue
+                    if os.path.isfile(filepath):
+                        try:
+                            tz = tzfile(filepath)
+                            break
+                        except (IOError, OSError, ValueError):
+                            pass
+                else:
+                    tz = tzlocal()
+            else:
+                try:
+                    if name.startswith(":"):
+                        name = name[1:]
+                except TypeError as e:
+                    if isinstance(name, bytes):
+                        new_msg = "gettz argument should be str, not bytes"
+                        six.raise_from(TypeError(new_msg), e)
+                    else:
+                        raise
+                if os.path.isabs(name):
+                    if os.path.isfile(name):
+                        tz = tzfile(name)
+                    else:
+                        tz = None
+                else:
+                    for path in TZPATHS:
+                        filepath = os.path.join(path, name)
+                        if not os.path.isfile(filepath):
+                            filepath = filepath.replace(' ', '_')
+                            if not os.path.isfile(filepath):
+                                continue
+                        try:
+                            tz = tzfile(filepath)
+                            break
+                        except (IOError, OSError, ValueError):
+                            pass
+                    else:
+                        tz = None
+                        if tzwin is not None:
+                            try:
+                                tz = tzwin(name)
+                            except (WindowsError, UnicodeEncodeError):
+                                # UnicodeEncodeError is for Python 2.7 compat
+                                tz = None
+
+                        if not tz:
+                            from dateutil.zoneinfo import get_zonefile_instance
+                            tz = get_zonefile_instance().get(name)
+
+                        if not tz:
+                            for c in name:
+                                # name is not a tzstr unless it has at least
+                                # one offset. For short values of "name", an
+                                # explicit for loop seems to be the fastest way
+                                # To determine if a string contains a digit
+                                if c in "0123456789":
+                                    try:
+                                        tz = tzstr(name)
+                                    except ValueError:
+                                        pass
+                                    break
+                            else:
+                                if name in ("GMT", "UTC"):
+                                    tz = UTC
+                                elif name in time.tzname:
+                                    tz = tzlocal()
+            return tz
+
+    return GettzFunc()
+
+
+gettz = __get_gettz()
+del __get_gettz
+
+
+def datetime_exists(dt, tz=None):
+    """
+    Given a datetime and a time zone, determine whether or not a given datetime
+    would fall in a gap.
+
+    :param dt:
+        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
+        is provided.)
+
+    :param tz:
+        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
+        ``None`` or not provided, the datetime's own time zone will be used.
+
+    :return:
+        Returns a boolean value whether or not the "wall time" exists in
+        ``tz``.
+
+    .. versionadded:: 2.7.0
+    """
+    if tz is None:
+        if dt.tzinfo is None:
+            raise ValueError('Datetime is naive and no time zone provided.')
+        tz = dt.tzinfo
+
+    dt = dt.replace(tzinfo=None)
+
+    # This is essentially a test of whether or not the datetime can survive
+    # a round trip to UTC.
+    dt_rt = dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)
+    dt_rt = dt_rt.replace(tzinfo=None)
+
+    return dt == dt_rt
+
+
+def datetime_ambiguous(dt, tz=None):
+    """
+    Given a datetime and a time zone, determine whether or not a given datetime
+    is ambiguous (i.e if there are two times differentiated only by their DST
+    status).
+
+    :param dt:
+        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
+        is provided.)
+
+    :param tz:
+        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
+        ``None`` or not provided, the datetime's own time zone will be used.
+
+    :return:
+        Returns a boolean value whether or not the "wall time" is ambiguous in
+        ``tz``.
+
+    .. versionadded:: 2.6.0
+    """
+    if tz is None:
+        if dt.tzinfo is None:
+            raise ValueError('Datetime is naive and no time zone provided.')
+
+        tz = dt.tzinfo
+
+    # If a time zone defines its own "is_ambiguous" function, we'll use that.
+    is_ambiguous_fn = getattr(tz, 'is_ambiguous', None)
+    if is_ambiguous_fn is not None:
+        try:
+            return tz.is_ambiguous(dt)
+        except Exception:
+            pass
+
+    # If it doesn't come out and tell us it's ambiguous, we'll just check if
+    # the fold attribute has any effect on this particular date and time.
+    dt = dt.replace(tzinfo=tz)
+    wall_0 = enfold(dt, fold=0)
+    wall_1 = enfold(dt, fold=1)
+
+    same_offset = wall_0.utcoffset() == wall_1.utcoffset()
+    same_dst = wall_0.dst() == wall_1.dst()
+
+    return not (same_offset and same_dst)
+
+
+def resolve_imaginary(dt):
+    """
+    Given a datetime that may be imaginary, return an existing datetime.
+
+    This function assumes that an imaginary datetime represents what the
+    wall time would be in a zone had the offset transition not occurred, so
+    it will always fall forward by the transition's change in offset.
+
+    .. doctest::
+
+        >>> from dateutil import tz
+        >>> from datetime import datetime
+        >>> NYC = tz.gettz('America/New_York')
+        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))
+        2017-03-12 03:30:00-04:00
+
+        >>> KIR = tz.gettz('Pacific/Kiritimati')
+        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))
+        1995-01-02 12:30:00+14:00
+
+    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,
+    existing datetime, so a round-trip to and from UTC is sufficient to get
+    an extant datetime, however, this generally "falls back" to an earlier time
+    rather than falling forward to the STD side (though no guarantees are made
+    about this behavior).
+
+    :param dt:
+        A :class:`datetime.datetime` which may or may not exist.
+
+    :return:
+        Returns an existing :class:`datetime.datetime`. If ``dt`` was not
+        imaginary, the datetime returned is guaranteed to be the same object
+        passed to the function.
+
+    .. versionadded:: 2.7.0
+    """
+    if dt.tzinfo is not None and not datetime_exists(dt):
+
+        curr_offset = (dt + datetime.timedelta(hours=24)).utcoffset()
+        old_offset = (dt - datetime.timedelta(hours=24)).utcoffset()
+
+        dt += curr_offset - old_offset
+
+    return dt
+
+
+def _datetime_to_timestamp(dt):
+    """
+    Convert a :class:`datetime.datetime` object to an epoch timestamp in
+    seconds since January 1, 1970, ignoring the time zone.
+    """
+    return (dt.replace(tzinfo=None) - EPOCH).total_seconds()
+
+
+if sys.version_info >= (3, 6):
+    def _get_supported_offset(second_offset):
+        return second_offset
+else:
+    def _get_supported_offset(second_offset):
+        # For python pre-3.6, round to full-minutes if that's not the case.
+        # Python's datetime doesn't accept sub-minute timezones. Check
+        # http://python.org/sf/1447945 or https://bugs.python.org/issue5288
+        # for some information.
+        old_offset = second_offset
+        calculated_offset = 60 * ((second_offset + 30) // 60)
+        return calculated_offset
+
+
+try:
+    # Python 3.7 feature
+    from contextlib import nullcontext as _nullcontext
+except ImportError:
+    class _nullcontext(object):
+        """
+        Class for wrapping contexts so that they are passed through in a
+        with statement.
+        """
+        def __init__(self, context):
+            self.context = context
+
+        def __enter__(self):
+            return self.context
+
+        def __exit__(*args, **kwargs):
+            pass
+
+# vim:ts=4:sw=4:et
diff --git a/Lib/site-packages/dateutil/tz/win.py b/Lib/site-packages/dateutil/tz/win.py
new file mode 100644
index 0000000..cde07ba
--- /dev/null
+++ b/Lib/site-packages/dateutil/tz/win.py
@@ -0,0 +1,370 @@
+# -*- coding: utf-8 -*-
+"""
+This module provides an interface to the native time zone data on Windows,
+including :py:class:`datetime.tzinfo` implementations.
+
+Attempting to import this module on a non-Windows platform will raise an
+:py:obj:`ImportError`.
+"""
+# This code was originally contributed by Jeffrey Harris.
+import datetime
+import struct
+
+from six.moves import winreg
+from six import text_type
+
+try:
+    import ctypes
+    from ctypes import wintypes
+except ValueError:
+    # ValueError is raised on non-Windows systems for some horrible reason.
+    raise ImportError("Running tzwin on non-Windows system")
+
+from ._common import tzrangebase
+
+__all__ = ["tzwin", "tzwinlocal", "tzres"]
+
+ONEWEEK = datetime.timedelta(7)
+
+TZKEYNAMENT = r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones"
+TZKEYNAME9X = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Time Zones"
+TZLOCALKEYNAME = r"SYSTEM\CurrentControlSet\Control\TimeZoneInformation"
+
+
+def _settzkeyname():
+    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
+    try:
+        winreg.OpenKey(handle, TZKEYNAMENT).Close()
+        TZKEYNAME = TZKEYNAMENT
+    except WindowsError:
+        TZKEYNAME = TZKEYNAME9X
+    handle.Close()
+    return TZKEYNAME
+
+
+TZKEYNAME = _settzkeyname()
+
+
+class tzres(object):
+    """
+    Class for accessing ``tzres.dll``, which contains timezone name related
+    resources.
+
+    .. versionadded:: 2.5.0
+    """
+    p_wchar = ctypes.POINTER(wintypes.WCHAR)        # Pointer to a wide char
+
+    def __init__(self, tzres_loc='tzres.dll'):
+        # Load the user32 DLL so we can load strings from tzres
+        user32 = ctypes.WinDLL('user32')
+
+        # Specify the LoadStringW function
+        user32.LoadStringW.argtypes = (wintypes.HINSTANCE,
+                                       wintypes.UINT,
+                                       wintypes.LPWSTR,
+                                       ctypes.c_int)
+
+        self.LoadStringW = user32.LoadStringW
+        self._tzres = ctypes.WinDLL(tzres_loc)
+        self.tzres_loc = tzres_loc
+
+    def load_name(self, offset):
+        """
+        Load a timezone name from a DLL offset (integer).
+
+        >>> from dateutil.tzwin import tzres
+        >>> tzr = tzres()
+        >>> print(tzr.load_name(112))
+        'Eastern Standard Time'
+
+        :param offset:
+            A positive integer value referring to a string from the tzres dll.
+
+        .. note::
+
+            Offsets found in the registry are generally of the form
+            ``@tzres.dll,-114``. The offset in this case is 114, not -114.
+
+        """
+        resource = self.p_wchar()
+        lpBuffer = ctypes.cast(ctypes.byref(resource), wintypes.LPWSTR)
+        nchar = self.LoadStringW(self._tzres._handle, offset, lpBuffer, 0)
+        return resource[:nchar]
+
+    def name_from_string(self, tzname_str):
+        """
+        Parse strings as returned from the Windows registry into the time zone
+        name as defined in the registry.
+
+        >>> from dateutil.tzwin import tzres
+        >>> tzr = tzres()
+        >>> print(tzr.name_from_string('@tzres.dll,-251'))
+        'Dateline Daylight Time'
+        >>> print(tzr.name_from_string('Eastern Standard Time'))
+        'Eastern Standard Time'
+
+        :param tzname_str:
+            A timezone name string as returned from a Windows registry key.
+
+        :return:
+            Returns the localized timezone string from tzres.dll if the string
+            is of the form `@tzres.dll,-offset`, else returns the input string.
+        """
+        if not tzname_str.startswith('@'):
+            return tzname_str
+
+        name_splt = tzname_str.split(',-')
+        try:
+            offset = int(name_splt[1])
+        except:
+            raise ValueError("Malformed timezone string.")
+
+        return self.load_name(offset)
+
+
+class tzwinbase(tzrangebase):
+    """tzinfo class based on win32's timezones available in the registry."""
+    def __init__(self):
+        raise NotImplementedError('tzwinbase is an abstract base class')
+
+    def __eq__(self, other):
+        # Compare on all relevant dimensions, including name.
+        if not isinstance(other, tzwinbase):
+            return NotImplemented
+
+        return  (self._std_offset == other._std_offset and
+                 self._dst_offset == other._dst_offset and
+                 self._stddayofweek == other._stddayofweek and
+                 self._dstdayofweek == other._dstdayofweek and
+                 self._stdweeknumber == other._stdweeknumber and
+                 self._dstweeknumber == other._dstweeknumber and
+                 self._stdhour == other._stdhour and
+                 self._dsthour == other._dsthour and
+                 self._stdminute == other._stdminute and
+                 self._dstminute == other._dstminute and
+                 self._std_abbr == other._std_abbr and
+                 self._dst_abbr == other._dst_abbr)
+
+    @staticmethod
+    def list():
+        """Return a list of all time zones known to the system."""
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            with winreg.OpenKey(handle, TZKEYNAME) as tzkey:
+                result = [winreg.EnumKey(tzkey, i)
+                          for i in range(winreg.QueryInfoKey(tzkey)[0])]
+        return result
+
+    def display(self):
+        """
+        Return the display name of the time zone.
+        """
+        return self._display
+
+    def transitions(self, year):
+        """
+        For a given year, get the DST on and off transition times, expressed
+        always on the standard time side. For zones with no transitions, this
+        function returns ``None``.
+
+        :param year:
+            The year whose transitions you would like to query.
+
+        :return:
+            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
+            ``(dston, dstoff)`` for zones with an annual DST transition, or
+            ``None`` for fixed offset zones.
+        """
+
+        if not self.hasdst:
+            return None
+
+        dston = picknthweekday(year, self._dstmonth, self._dstdayofweek,
+                               self._dsthour, self._dstminute,
+                               self._dstweeknumber)
+
+        dstoff = picknthweekday(year, self._stdmonth, self._stddayofweek,
+                                self._stdhour, self._stdminute,
+                                self._stdweeknumber)
+
+        # Ambiguous dates default to the STD side
+        dstoff -= self._dst_base_offset
+
+        return dston, dstoff
+
+    def _get_hasdst(self):
+        return self._dstmonth != 0
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_base_offset_
+
+
+class tzwin(tzwinbase):
+    """
+    Time zone object created from the zone info in the Windows registry
+
+    These are similar to :py:class:`dateutil.tz.tzrange` objects in that
+    the time zone data is provided in the format of a single offset rule
+    for either 0 or 2 time zone transitions per year.
+
+    :param: name
+        The name of a Windows time zone key, e.g. "Eastern Standard Time".
+        The full list of keys can be retrieved with :func:`tzwin.list`.
+    """
+
+    def __init__(self, name):
+        self._name = name
+
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            tzkeyname = text_type("{kn}\\{name}").format(kn=TZKEYNAME, name=name)
+            with winreg.OpenKey(handle, tzkeyname) as tzkey:
+                keydict = valuestodict(tzkey)
+
+        self._std_abbr = keydict["Std"]
+        self._dst_abbr = keydict["Dlt"]
+
+        self._display = keydict["Display"]
+
+        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm
+        tup = struct.unpack("=3l16h", keydict["TZI"])
+        stdoffset = -tup[0]-tup[1]          # Bias + StandardBias * -1
+        dstoffset = stdoffset-tup[2]        # + DaylightBias * -1
+        self._std_offset = datetime.timedelta(minutes=stdoffset)
+        self._dst_offset = datetime.timedelta(minutes=dstoffset)
+
+        # for the meaning see the win32 TIME_ZONE_INFORMATION structure docs
+        # http://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx
+        (self._stdmonth,
+         self._stddayofweek,   # Sunday = 0
+         self._stdweeknumber,  # Last = 5
+         self._stdhour,
+         self._stdminute) = tup[4:9]
+
+        (self._dstmonth,
+         self._dstdayofweek,   # Sunday = 0
+         self._dstweeknumber,  # Last = 5
+         self._dsthour,
+         self._dstminute) = tup[12:17]
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = self._get_hasdst()
+
+    def __repr__(self):
+        return "tzwin(%s)" % repr(self._name)
+
+    def __reduce__(self):
+        return (self.__class__, (self._name,))
+
+
+class tzwinlocal(tzwinbase):
+    """
+    Class representing the local time zone information in the Windows registry
+
+    While :class:`dateutil.tz.tzlocal` makes system calls (via the :mod:`time`
+    module) to retrieve time zone information, ``tzwinlocal`` retrieves the
+    rules directly from the Windows registry and creates an object like
+    :class:`dateutil.tz.tzwin`.
+
+    Because Windows does not have an equivalent of :func:`time.tzset`, on
+    Windows, :class:`dateutil.tz.tzlocal` instances will always reflect the
+    time zone settings *at the time that the process was started*, meaning
+    changes to the machine's time zone settings during the run of a program
+    on Windows will **not** be reflected by :class:`dateutil.tz.tzlocal`.
+    Because ``tzwinlocal`` reads the registry directly, it is unaffected by
+    this issue.
+    """
+    def __init__(self):
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            with winreg.OpenKey(handle, TZLOCALKEYNAME) as tzlocalkey:
+                keydict = valuestodict(tzlocalkey)
+
+            self._std_abbr = keydict["StandardName"]
+            self._dst_abbr = keydict["DaylightName"]
+
+            try:
+                tzkeyname = text_type('{kn}\\{sn}').format(kn=TZKEYNAME,
+                                                          sn=self._std_abbr)
+                with winreg.OpenKey(handle, tzkeyname) as tzkey:
+                    _keydict = valuestodict(tzkey)
+                    self._display = _keydict["Display"]
+            except OSError:
+                self._display = None
+
+        stdoffset = -keydict["Bias"]-keydict["StandardBias"]
+        dstoffset = stdoffset-keydict["DaylightBias"]
+
+        self._std_offset = datetime.timedelta(minutes=stdoffset)
+        self._dst_offset = datetime.timedelta(minutes=dstoffset)
+
+        # For reasons unclear, in this particular key, the day of week has been
+        # moved to the END of the SYSTEMTIME structure.
+        tup = struct.unpack("=8h", keydict["StandardStart"])
+
+        (self._stdmonth,
+         self._stdweeknumber,  # Last = 5
+         self._stdhour,
+         self._stdminute) = tup[1:5]
+
+        self._stddayofweek = tup[7]
+
+        tup = struct.unpack("=8h", keydict["DaylightStart"])
+
+        (self._dstmonth,
+         self._dstweeknumber,  # Last = 5
+         self._dsthour,
+         self._dstminute) = tup[1:5]
+
+        self._dstdayofweek = tup[7]
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = self._get_hasdst()
+
+    def __repr__(self):
+        return "tzwinlocal()"
+
+    def __str__(self):
+        # str will return the standard name, not the daylight name.
+        return "tzwinlocal(%s)" % repr(self._std_abbr)
+
+    def __reduce__(self):
+        return (self.__class__, ())
+
+
+def picknthweekday(year, month, dayofweek, hour, minute, whichweek):
+    """ dayofweek == 0 means Sunday, whichweek 5 means last instance """
+    first = datetime.datetime(year, month, 1, hour, minute)
+
+    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),
+    # Because 7 % 7 = 0
+    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)
+    wd = weekdayone + ((whichweek - 1) * ONEWEEK)
+    if (wd.month != month):
+        wd -= ONEWEEK
+
+    return wd
+
+
+def valuestodict(key):
+    """Convert a registry key's values to a dictionary."""
+    dout = {}
+    size = winreg.QueryInfoKey(key)[1]
+    tz_res = None
+
+    for i in range(size):
+        key_name, value, dtype = winreg.EnumValue(key, i)
+        if dtype == winreg.REG_DWORD or dtype == winreg.REG_DWORD_LITTLE_ENDIAN:
+            # If it's a DWORD (32-bit integer), it's stored as unsigned - convert
+            # that to a proper signed integer
+            if value & (1 << 31):
+                value = value - (1 << 32)
+        elif dtype == winreg.REG_SZ:
+            # If it's a reference to the tzres DLL, load the actual string
+            if value.startswith('@tzres'):
+                tz_res = tz_res or tzres()
+                value = tz_res.name_from_string(value)
+
+            value = value.rstrip('\x00')    # Remove trailing nulls
+
+        dout[key_name] = value
+
+    return dout
diff --git a/Lib/site-packages/dateutil/tzwin.py b/Lib/site-packages/dateutil/tzwin.py
new file mode 100644
index 0000000..cebc673
--- /dev/null
+++ b/Lib/site-packages/dateutil/tzwin.py
@@ -0,0 +1,2 @@
+# tzwin has moved to dateutil.tz.win
+from .tz.win import *
diff --git a/Lib/site-packages/dateutil/utils.py b/Lib/site-packages/dateutil/utils.py
new file mode 100644
index 0000000..dd2d245
--- /dev/null
+++ b/Lib/site-packages/dateutil/utils.py
@@ -0,0 +1,71 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers general convenience and utility functions for dealing with
+datetimes.
+
+.. versionadded:: 2.7.0
+"""
+from __future__ import unicode_literals
+
+from datetime import datetime, time
+
+
+def today(tzinfo=None):
+    """
+    Returns a :py:class:`datetime` representing the current day at midnight
+
+    :param tzinfo:
+        The time zone to attach (also used to determine the current day).
+
+    :return:
+        A :py:class:`datetime.datetime` object representing the current day
+        at midnight.
+    """
+
+    dt = datetime.now(tzinfo)
+    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))
+
+
+def default_tzinfo(dt, tzinfo):
+    """
+    Sets the ``tzinfo`` parameter on naive datetimes only
+
+    This is useful for example when you are provided a datetime that may have
+    either an implicit or explicit time zone, such as when parsing a time zone
+    string.
+
+    .. doctest::
+
+        >>> from dateutil.tz import tzoffset
+        >>> from dateutil.parser import parse
+        >>> from dateutil.utils import default_tzinfo
+        >>> dflt_tz = tzoffset("EST", -18000)
+        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))
+        2014-01-01 12:30:00+00:00
+        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))
+        2014-01-01 12:30:00-05:00
+
+    :param dt:
+        The datetime on which to replace the time zone
+
+    :param tzinfo:
+        The :py:class:`datetime.tzinfo` subclass instance to assign to
+        ``dt`` if (and only if) it is naive.
+
+    :return:
+        Returns an aware :py:class:`datetime.datetime`.
+    """
+    if dt.tzinfo is not None:
+        return dt
+    else:
+        return dt.replace(tzinfo=tzinfo)
+
+
+def within_delta(dt1, dt2, delta):
+    """
+    Useful for comparing two datetimes that may have a negligible difference
+    to be considered equal.
+    """
+    delta = abs(delta)
+    difference = dt1 - dt2
+    return -delta <= difference <= delta
diff --git a/Lib/site-packages/dateutil/zoneinfo/__init__.py b/Lib/site-packages/dateutil/zoneinfo/__init__.py
new file mode 100644
index 0000000..34f11ad
--- /dev/null
+++ b/Lib/site-packages/dateutil/zoneinfo/__init__.py
@@ -0,0 +1,167 @@
+# -*- coding: utf-8 -*-
+import warnings
+import json
+
+from tarfile import TarFile
+from pkgutil import get_data
+from io import BytesIO
+
+from dateutil.tz import tzfile as _tzfile
+
+__all__ = ["get_zonefile_instance", "gettz", "gettz_db_metadata"]
+
+ZONEFILENAME = "dateutil-zoneinfo.tar.gz"
+METADATA_FN = 'METADATA'
+
+
+class tzfile(_tzfile):
+    def __reduce__(self):
+        return (gettz, (self._filename,))
+
+
+def getzoneinfofile_stream():
+    try:
+        return BytesIO(get_data(__name__, ZONEFILENAME))
+    except IOError as e:  # TODO  switch to FileNotFoundError?
+        warnings.warn("I/O error({0}): {1}".format(e.errno, e.strerror))
+        return None
+
+
+class ZoneInfoFile(object):
+    def __init__(self, zonefile_stream=None):
+        if zonefile_stream is not None:
+            with TarFile.open(fileobj=zonefile_stream) as tf:
+                self.zones = {zf.name: tzfile(tf.extractfile(zf), filename=zf.name)
+                              for zf in tf.getmembers()
+                              if zf.isfile() and zf.name != METADATA_FN}
+                # deal with links: They'll point to their parent object. Less
+                # waste of memory
+                links = {zl.name: self.zones[zl.linkname]
+                         for zl in tf.getmembers() if
+                         zl.islnk() or zl.issym()}
+                self.zones.update(links)
+                try:
+                    metadata_json = tf.extractfile(tf.getmember(METADATA_FN))
+                    metadata_str = metadata_json.read().decode('UTF-8')
+                    self.metadata = json.loads(metadata_str)
+                except KeyError:
+                    # no metadata in tar file
+                    self.metadata = None
+        else:
+            self.zones = {}
+            self.metadata = None
+
+    def get(self, name, default=None):
+        """
+        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method
+        for retrieving zones from the zone dictionary.
+
+        :param name:
+            The name of the zone to retrieve. (Generally IANA zone names)
+
+        :param default:
+            The value to return in the event of a missing key.
+
+        .. versionadded:: 2.6.0
+
+        """
+        return self.zones.get(name, default)
+
+
+# The current API has gettz as a module function, although in fact it taps into
+# a stateful class. So as a workaround for now, without changing the API, we
+# will create a new "global" class instance the first time a user requests a
+# timezone. Ugly, but adheres to the api.
+#
+# TODO: Remove after deprecation period.
+_CLASS_ZONE_INSTANCE = []
+
+
+def get_zonefile_instance(new_instance=False):
+    """
+    This is a convenience function which provides a :class:`ZoneInfoFile`
+    instance using the data provided by the ``dateutil`` package. By default, it
+    caches a single instance of the ZoneInfoFile object and returns that.
+
+    :param new_instance:
+        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and
+        used as the cached instance for the next call. Otherwise, new instances
+        are created only as necessary.
+
+    :return:
+        Returns a :class:`ZoneInfoFile` object.
+
+    .. versionadded:: 2.6
+    """
+    if new_instance:
+        zif = None
+    else:
+        zif = getattr(get_zonefile_instance, '_cached_instance', None)
+
+    if zif is None:
+        zif = ZoneInfoFile(getzoneinfofile_stream())
+
+        get_zonefile_instance._cached_instance = zif
+
+    return zif
+
+
+def gettz(name):
+    """
+    This retrieves a time zone from the local zoneinfo tarball that is packaged
+    with dateutil.
+
+    :param name:
+        An IANA-style time zone name, as found in the zoneinfo file.
+
+    :return:
+        Returns a :class:`dateutil.tz.tzfile` time zone object.
+
+    .. warning::
+        It is generally inadvisable to use this function, and it is only
+        provided for API compatibility with earlier versions. This is *not*
+        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate
+        time zone based on the inputs, favoring system zoneinfo. This is ONLY
+        for accessing the dateutil-specific zoneinfo (which may be out of
+        date compared to the system zoneinfo).
+
+    .. deprecated:: 2.6
+        If you need to use a specific zoneinfofile over the system zoneinfo,
+        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call
+        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.
+
+        Use :func:`get_zonefile_instance` to retrieve an instance of the
+        dateutil-provided zoneinfo.
+    """
+    warnings.warn("zoneinfo.gettz() will be removed in future versions, "
+                  "to use the dateutil-provided zoneinfo files, instantiate a "
+                  "ZoneInfoFile object and use ZoneInfoFile.zones.get() "
+                  "instead. See the documentation for details.",
+                  DeprecationWarning)
+
+    if len(_CLASS_ZONE_INSTANCE) == 0:
+        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
+    return _CLASS_ZONE_INSTANCE[0].zones.get(name)
+
+
+def gettz_db_metadata():
+    """ Get the zonefile metadata
+
+    See `zonefile_metadata`_
+
+    :returns:
+        A dictionary with the database metadata
+
+    .. deprecated:: 2.6
+        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,
+        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.
+    """
+    warnings.warn("zoneinfo.gettz_db_metadata() will be removed in future "
+                  "versions, to use the dateutil-provided zoneinfo files, "
+                  "ZoneInfoFile object and query the 'metadata' attribute "
+                  "instead. See the documentation for details.",
+                  DeprecationWarning)
+
+    if len(_CLASS_ZONE_INSTANCE) == 0:
+        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
+    return _CLASS_ZONE_INSTANCE[0].metadata
diff --git a/Lib/site-packages/dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc b/Lib/site-packages/dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..ab819ed48c1434ec1705e26510ea24867bc872c9
GIT binary patch
literal 7432
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
Q)7i-EU+ZV880`lAAC+DxVgLXD

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc b/Lib/site-packages/dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..87e269d21340856707a7a41f9c1e2e9f0cedafbc
GIT binary patch
literal 3958
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

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz b/Lib/site-packages/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz
new file mode 100644
index 0000000000000000000000000000000000000000..1461f8c862df8c3eae75e0ea376788b5b2602269
GIT binary patch
literal 156400
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

literal 0
HcmV?d00001

diff --git a/Lib/site-packages/dateutil/zoneinfo/rebuild.py b/Lib/site-packages/dateutil/zoneinfo/rebuild.py
new file mode 100644
index 0000000..684c658
--- /dev/null
+++ b/Lib/site-packages/dateutil/zoneinfo/rebuild.py
@@ -0,0 +1,75 @@
+import logging
+import os
+import tempfile
+import shutil
+import json
+from subprocess import check_call, check_output
+from tarfile import TarFile
+
+from dateutil.zoneinfo import METADATA_FN, ZONEFILENAME
+
+
+def rebuild(filename, tag=None, format="gz", zonegroups=[], metadata=None):
+    """Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*
+
+    filename is the timezone tarball from ``ftp.iana.org/tz``.
+
+    """
+    tmpdir = tempfile.mkdtemp()
+    zonedir = os.path.join(tmpdir, "zoneinfo")
+    moduledir = os.path.dirname(__file__)
+    try:
+        with TarFile.open(filename) as tf:
+            for name in zonegroups:
+                tf.extract(name, tmpdir)
+            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]
+
+            _run_zic(zonedir, filepaths)
+
+        # write metadata file
+        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:
+            json.dump(metadata, f, indent=4, sort_keys=True)
+        target = os.path.join(moduledir, ZONEFILENAME)
+        with TarFile.open(target, "w:%s" % format) as tf:
+            for entry in os.listdir(zonedir):
+                entrypath = os.path.join(zonedir, entry)
+                tf.add(entrypath, entry)
+    finally:
+        shutil.rmtree(tmpdir)
+
+
+def _run_zic(zonedir, filepaths):
+    """Calls the ``zic`` compiler in a compatible way to get a "fat" binary.
+
+    Recent versions of ``zic`` default to ``-b slim``, while older versions
+    don't even have the ``-b`` option (but default to "fat" binaries). The
+    current version of dateutil does not support Version 2+ TZif files, which
+    causes problems when used in conjunction with "slim" binaries, so this
+    function is used to ensure that we always get a "fat" binary.
+    """
+
+    try:
+        help_text = check_output(["zic", "--help"])
+    except OSError as e:
+        _print_on_nosuchfile(e)
+        raise
+
+    if b"-b " in help_text:
+        bloat_args = ["-b", "fat"]
+    else:
+        bloat_args = []
+
+    check_call(["zic"] + bloat_args + ["-d", zonedir] + filepaths)
+
+
+def _print_on_nosuchfile(e):
+    """Print helpful troubleshooting message
+
+    e is an exception raised by subprocess.check_call()
+
+    """
+    if e.errno == 2:
+        logging.error(
+            "Could not find zic. Perhaps you need to install "
+            "libc-bin or some other package that provides it, "
+            "or it's not in your PATH?")
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/INSTALLER b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/INSTALLER
new file mode 100644
index 0000000..a1b589e
--- /dev/null
+++ b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/INSTALLER
@@ -0,0 +1 @@
+pip
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/LICENSE b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/LICENSE
new file mode 100644
index 0000000..1e65815
--- /dev/null
+++ b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/LICENSE
@@ -0,0 +1,54 @@
+Copyright 2017- Paul Ganssle <paul@ganssle.io>
+Copyright 2017- dateutil contributors (see AUTHORS file)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+The above license applies to all contributions after 2017-12-01, as well as
+all contributions that have been re-licensed (see AUTHORS file for the list of
+contributors who have re-licensed their code).
+--------------------------------------------------------------------------------
+dateutil - Extensions to the standard Python datetime module.
+
+Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
+Copyright (c) 2012-2014 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>
+Copyright (c) 2014-2016 - Yaron de Leeuw <me@jarondl.net>
+Copyright (c) 2015-     - Paul Ganssle <paul@ganssle.io>
+Copyright (c) 2015-     - dateutil contributors (see AUTHORS file)
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice,
+      this list of conditions and the following disclaimer in the documentation
+      and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+The above BSD License Applies to all code, even that also covered by Apache 2.0.
\ No newline at end of file
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/METADATA b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/METADATA
new file mode 100644
index 0000000..577f2bf
--- /dev/null
+++ b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/METADATA
@@ -0,0 +1,204 @@
+Metadata-Version: 2.1
+Name: python-dateutil
+Version: 2.9.0.post0
+Summary: Extensions to the standard Python datetime module
+Home-page: https://github.com/dateutil/dateutil
+Author: Gustavo Niemeyer
+Author-email: gustavo@niemeyer.net
+Maintainer: Paul Ganssle
+Maintainer-email: dateutil@python.org
+License: Dual License
+Project-URL: Documentation, https://dateutil.readthedocs.io/en/stable/
+Project-URL: Source, https://github.com/dateutil/dateutil
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: BSD License
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Programming Language :: Python :: 3.5
+Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Topic :: Software Development :: Libraries
+Requires-Python: !=3.0.*,!=3.1.*,!=3.2.*,>=2.7
+Description-Content-Type: text/x-rst
+License-File: LICENSE
+Requires-Dist: six >=1.5
+
+dateutil - powerful extensions to datetime
+==========================================
+
+|pypi| |support| |licence|
+
+|gitter| |readthedocs|
+
+|travis| |appveyor| |pipelines| |coverage|
+
+.. |pypi| image:: https://img.shields.io/pypi/v/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: pypi version
+
+.. |support| image:: https://img.shields.io/pypi/pyversions/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: supported Python version
+
+.. |travis| image:: https://img.shields.io/travis/dateutil/dateutil/master.svg?style=flat-square&label=Travis%20Build
+    :target: https://travis-ci.org/dateutil/dateutil
+    :alt: travis build status
+
+.. |appveyor| image:: https://img.shields.io/appveyor/ci/dateutil/dateutil/master.svg?style=flat-square&logo=appveyor
+    :target: https://ci.appveyor.com/project/dateutil/dateutil
+    :alt: appveyor build status
+
+.. |pipelines| image:: https://dev.azure.com/pythondateutilazure/dateutil/_apis/build/status/dateutil.dateutil?branchName=master
+    :target: https://dev.azure.com/pythondateutilazure/dateutil/_build/latest?definitionId=1&branchName=master
+    :alt: azure pipelines build status
+
+.. |coverage| image:: https://codecov.io/gh/dateutil/dateutil/branch/master/graphs/badge.svg?branch=master
+    :target: https://codecov.io/gh/dateutil/dateutil?branch=master
+    :alt: Code coverage
+
+.. |gitter| image:: https://badges.gitter.im/dateutil/dateutil.svg
+   :alt: Join the chat at https://gitter.im/dateutil/dateutil
+   :target: https://gitter.im/dateutil/dateutil
+
+.. |licence| image:: https://img.shields.io/pypi/l/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: licence
+
+.. |readthedocs| image:: https://img.shields.io/readthedocs/dateutil/latest.svg?style=flat-square&label=Read%20the%20Docs
+   :alt: Read the documentation at https://dateutil.readthedocs.io/en/latest/
+   :target: https://dateutil.readthedocs.io/en/latest/
+
+The `dateutil` module provides powerful extensions to
+the standard `datetime` module, available in Python.
+
+Installation
+============
+`dateutil` can be installed from PyPI using `pip` (note that the package name is
+different from the importable name)::
+
+    pip install python-dateutil
+
+Download
+========
+dateutil is available on PyPI
+https://pypi.org/project/python-dateutil/
+
+The documentation is hosted at:
+https://dateutil.readthedocs.io/en/stable/
+
+Code
+====
+The code and issue tracker are hosted on GitHub:
+https://github.com/dateutil/dateutil/
+
+Features
+========
+
+* Computing of relative deltas (next month, next year,
+  next Monday, last week of month, etc);
+* Computing of relative deltas between two given
+  date and/or datetime objects;
+* Computing of dates based on very flexible recurrence rules,
+  using a superset of the `iCalendar <https://www.ietf.org/rfc/rfc2445.txt>`_
+  specification. Parsing of RFC strings is supported as well.
+* Generic parsing of dates in almost any string format;
+* Timezone (tzinfo) implementations for tzfile(5) format
+  files (/etc/localtime, /usr/share/zoneinfo, etc), TZ
+  environment string (in all known formats), iCalendar
+  format files, given ranges (with help from relative deltas),
+  local machine timezone, fixed offset timezone, UTC timezone,
+  and Windows registry-based time zones.
+* Internal up-to-date world timezone information based on
+  Olson's database.
+* Computing of Easter Sunday dates for any given year,
+  using Western, Orthodox or Julian algorithms;
+* A comprehensive test suite.
+
+Quick example
+=============
+Here's a snapshot, just to give an idea about the power of the
+package. For more examples, look at the documentation.
+
+Suppose you want to know how much time is left, in
+years/months/days/etc, before the next easter happening on a
+year with a Friday 13th in August, and you want to get today's
+date out of the "date" unix system command. Here is the code:
+
+.. code-block:: python3
+
+    >>> from dateutil.relativedelta import *
+    >>> from dateutil.easter import *
+    >>> from dateutil.rrule import *
+    >>> from dateutil.parser import *
+    >>> from datetime import *
+    >>> now = parse("Sat Oct 11 17:13:46 UTC 2003")
+    >>> today = now.date()
+    >>> year = rrule(YEARLY,dtstart=now,bymonth=8,bymonthday=13,byweekday=FR)[0].year
+    >>> rdelta = relativedelta(easter(year), today)
+    >>> print("Today is: %s" % today)
+    Today is: 2003-10-11
+    >>> print("Year with next Aug 13th on a Friday is: %s" % year)
+    Year with next Aug 13th on a Friday is: 2004
+    >>> print("How far is the Easter of that year: %s" % rdelta)
+    How far is the Easter of that year: relativedelta(months=+6)
+    >>> print("And the Easter of that year is: %s" % (today+rdelta))
+    And the Easter of that year is: 2004-04-11
+
+Being exactly 6 months ahead was **really** a coincidence :)
+
+Contributing
+============
+
+We welcome many types of contributions - bug reports, pull requests (code, infrastructure or documentation fixes). For more information about how to contribute to the project, see the ``CONTRIBUTING.md`` file in the repository.
+
+
+Author
+======
+The dateutil module was written by Gustavo Niemeyer <gustavo@niemeyer.net>
+in 2003.
+
+It is maintained by:
+
+* Gustavo Niemeyer <gustavo@niemeyer.net> 2003-2011
+* Tomi Pieviläinen <tomi.pievilainen@iki.fi> 2012-2014
+* Yaron de Leeuw <me@jarondl.net> 2014-2016
+* Paul Ganssle <paul@ganssle.io> 2015-
+
+Starting with version 2.4.1 and running until 2.8.2, all source and binary
+distributions will be signed by a PGP key that has, at the very least, been
+signed by the key which made the previous release. A table of release signing
+keys can be found below:
+
+===========  ============================
+Releases     Signing key fingerprint
+===========  ============================
+2.4.1-2.8.2  `6B49 ACBA DCF6 BD1C A206 67AB CD54 FCE3 D964 BEFB`_
+===========  ============================
+
+New releases *may* have signed tags, but binary and source distributions
+uploaded to PyPI will no longer have GPG signatures attached.
+
+Contact
+=======
+Our mailing list is available at `dateutil@python.org <https://mail.python.org/mailman/listinfo/dateutil>`_. As it is hosted by the PSF, it is subject to the `PSF code of
+conduct <https://www.python.org/psf/conduct/>`_.
+
+License
+=======
+
+All contributions after December 1, 2017 released under dual license - either `Apache 2.0 License <https://www.apache.org/licenses/LICENSE-2.0>`_ or the `BSD 3-Clause License <https://opensource.org/licenses/BSD-3-Clause>`_. Contributions before December 1, 2017 - except those those explicitly relicensed - are released only under the BSD 3-Clause License.
+
+
+.. _6B49 ACBA DCF6 BD1C A206 67AB CD54 FCE3 D964 BEFB:
+   https://pgp.mit.edu/pks/lookup?op=vindex&search=0xCD54FCE3D964BEFB
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/RECORD b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/RECORD
new file mode 100644
index 0000000..5560c33
--- /dev/null
+++ b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/RECORD
@@ -0,0 +1,45 @@
+dateutil/__init__.py,sha256=Mqam67WO9IkTmUFyI66vS6IoSXTp9G388DadH2LCMLY,620
+dateutil/__pycache__/__init__.cpython-312.pyc,,
+dateutil/__pycache__/_common.cpython-312.pyc,,
+dateutil/__pycache__/_version.cpython-312.pyc,,
+dateutil/__pycache__/easter.cpython-312.pyc,,
+dateutil/__pycache__/relativedelta.cpython-312.pyc,,
+dateutil/__pycache__/rrule.cpython-312.pyc,,
+dateutil/__pycache__/tzwin.cpython-312.pyc,,
+dateutil/__pycache__/utils.cpython-312.pyc,,
+dateutil/_common.py,sha256=77w0yytkrxlYbSn--lDVPUMabUXRR9I3lBv_vQRUqUY,932
+dateutil/_version.py,sha256=BV031OxDDAmy58neUg5yyqLkLaqIw7ibK9As3jiMib0,166
+dateutil/easter.py,sha256=dyBi-lKvimH1u_k6p7Z0JJK72QhqVtVBsqByvpEPKvc,2678
+dateutil/parser/__init__.py,sha256=wWk6GFuxTpjoggCGtgkceJoti4pVjl4_fHQXpNOaSYg,1766
+dateutil/parser/__pycache__/__init__.cpython-312.pyc,,
+dateutil/parser/__pycache__/_parser.cpython-312.pyc,,
+dateutil/parser/__pycache__/isoparser.cpython-312.pyc,,
+dateutil/parser/_parser.py,sha256=7klDdyicksQB_Xgl-3UAmBwzCYor1AIZqklIcT6dH_8,58796
+dateutil/parser/isoparser.py,sha256=8Fy999bnCd1frSdOYuOraWfJTtd5W7qQ51NwNuH_hXM,13233
+dateutil/relativedelta.py,sha256=IY_mglMjoZbYfrvloTY2ce02aiVjPIkiZfqgNTZRfuA,24903
+dateutil/rrule.py,sha256=KJzKlaCd1jEbu4A38ZltslaoAUh9nSbdbOFdjp70Kew,66557
+dateutil/tz/__init__.py,sha256=F-Mz13v6jYseklQf9Te9J6nzcLDmq47gORa61K35_FA,444
+dateutil/tz/__pycache__/__init__.cpython-312.pyc,,
+dateutil/tz/__pycache__/_common.cpython-312.pyc,,
+dateutil/tz/__pycache__/_factories.cpython-312.pyc,,
+dateutil/tz/__pycache__/tz.cpython-312.pyc,,
+dateutil/tz/__pycache__/win.cpython-312.pyc,,
+dateutil/tz/_common.py,sha256=cgzDTANsOXvEc86cYF77EsliuSab8Puwpsl5-bX3_S4,12977
+dateutil/tz/_factories.py,sha256=unb6XQNXrPMveksTCU-Ag8jmVZs4SojoPUcAHpWnrvU,2569
+dateutil/tz/tz.py,sha256=EUnEdMfeThXiY6l4sh9yBabZ63_POzy01zSsh9thn1o,62855
+dateutil/tz/win.py,sha256=xJszWgSwE1xPx_HJj4ZkepyukC_hNy016WMcXhbRaB8,12935
+dateutil/tzwin.py,sha256=7Ar4vdQCnnM0mKR3MUjbIKsZrBVfHgdwsJZc_mGYRew,59
+dateutil/utils.py,sha256=dKCchEw8eObi0loGTx91unBxm_7UGlU3v_FjFMdqwYM,1965
+dateutil/zoneinfo/__init__.py,sha256=KYg0pthCMjcp5MXSEiBJn3nMjZeNZav7rlJw5-tz1S4,5889
+dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc,,
+dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc,,
+dateutil/zoneinfo/dateutil-zoneinfo.tar.gz,sha256=0-pS57bpaN4NiE3xKIGTWW-pW4A9tPkqGCeac5gARHU,156400
+dateutil/zoneinfo/rebuild.py,sha256=MiqYzCIHvNbMH-LdRYLv-4T0EIA7hDKt5GLR0IRTLdI,2392
+python_dateutil-2.9.0.post0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
+python_dateutil-2.9.0.post0.dist-info/LICENSE,sha256=ugD1Gg2SgjtaHN4n2LW50jIeZ-2NqbwWPv-W1eF-V34,2889
+python_dateutil-2.9.0.post0.dist-info/METADATA,sha256=qdQ22jIr6AgzL5jYgyWZjofLaTpniplp_rTPrXKabpM,8354
+python_dateutil-2.9.0.post0.dist-info/RECORD,,
+python_dateutil-2.9.0.post0.dist-info/REQUESTED,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+python_dateutil-2.9.0.post0.dist-info/WHEEL,sha256=-G_t0oGuE7UD0DrSpVZnq1hHMBV9DD2XkS5v7XpmTnk,110
+python_dateutil-2.9.0.post0.dist-info/top_level.txt,sha256=4tjdWkhRZvF7LA_BYe_L9gB2w_p2a-z5y6ArjaRkot8,9
+python_dateutil-2.9.0.post0.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/REQUESTED b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/REQUESTED
new file mode 100644
index 0000000..e69de29
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/WHEEL b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/WHEEL
new file mode 100644
index 0000000..4724c45
--- /dev/null
+++ b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/WHEEL
@@ -0,0 +1,6 @@
+Wheel-Version: 1.0
+Generator: bdist_wheel (0.42.0)
+Root-Is-Purelib: true
+Tag: py2-none-any
+Tag: py3-none-any
+
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/top_level.txt b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/top_level.txt
new file mode 100644
index 0000000..6650148
--- /dev/null
+++ b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/top_level.txt
@@ -0,0 +1 @@
+dateutil
diff --git a/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/zip-safe b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/zip-safe
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/Lib/site-packages/python_dateutil-2.9.0.post0.dist-info/zip-safe
@@ -0,0 +1 @@
+
diff --git a/Lib/site-packages/six-1.16.0.dist-info/INSTALLER b/Lib/site-packages/six-1.16.0.dist-info/INSTALLER
new file mode 100644
index 0000000..a1b589e
--- /dev/null
+++ b/Lib/site-packages/six-1.16.0.dist-info/INSTALLER
@@ -0,0 +1 @@
+pip
diff --git a/Lib/site-packages/six-1.16.0.dist-info/LICENSE b/Lib/site-packages/six-1.16.0.dist-info/LICENSE
new file mode 100644
index 0000000..de66331
--- /dev/null
+++ b/Lib/site-packages/six-1.16.0.dist-info/LICENSE
@@ -0,0 +1,18 @@
+Copyright (c) 2010-2020 Benjamin Peterson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/Lib/site-packages/six-1.16.0.dist-info/METADATA b/Lib/site-packages/six-1.16.0.dist-info/METADATA
new file mode 100644
index 0000000..6d7525c
--- /dev/null
+++ b/Lib/site-packages/six-1.16.0.dist-info/METADATA
@@ -0,0 +1,49 @@
+Metadata-Version: 2.1
+Name: six
+Version: 1.16.0
+Summary: Python 2 and 3 compatibility utilities
+Home-page: https://github.com/benjaminp/six
+Author: Benjamin Peterson
+Author-email: benjamin@python.org
+License: MIT
+Platform: UNKNOWN
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Utilities
+Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*
+
+.. image:: https://img.shields.io/pypi/v/six.svg
+   :target: https://pypi.org/project/six/
+   :alt: six on PyPI
+
+.. image:: https://travis-ci.org/benjaminp/six.svg?branch=master
+   :target: https://travis-ci.org/benjaminp/six
+   :alt: six on TravisCI
+
+.. image:: https://readthedocs.org/projects/six/badge/?version=latest
+   :target: https://six.readthedocs.io/
+   :alt: six's documentation on Read the Docs
+
+.. image:: https://img.shields.io/badge/license-MIT-green.svg
+   :target: https://github.com/benjaminp/six/blob/master/LICENSE
+   :alt: MIT License badge
+
+Six is a Python 2 and 3 compatibility library.  It provides utility functions
+for smoothing over the differences between the Python versions with the goal of
+writing Python code that is compatible on both Python versions.  See the
+documentation for more information on what is provided.
+
+Six supports Python 2.7 and 3.3+.  It is contained in only one Python
+file, so it can be easily copied into your project. (The copyright and license
+notice must be retained.)
+
+Online documentation is at https://six.readthedocs.io/.
+
+Bugs can be reported to https://github.com/benjaminp/six.  The code can also
+be found there.
+
+
diff --git a/Lib/site-packages/six-1.16.0.dist-info/RECORD b/Lib/site-packages/six-1.16.0.dist-info/RECORD
new file mode 100644
index 0000000..2209ab3
--- /dev/null
+++ b/Lib/site-packages/six-1.16.0.dist-info/RECORD
@@ -0,0 +1,8 @@
+__pycache__/six.cpython-312.pyc,,
+six-1.16.0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
+six-1.16.0.dist-info/LICENSE,sha256=i7hQxWWqOJ_cFvOkaWWtI9gq3_YPI5P8J2K2MYXo5sk,1066
+six-1.16.0.dist-info/METADATA,sha256=VQcGIFCAEmfZcl77E5riPCN4v2TIsc_qtacnjxKHJoI,1795
+six-1.16.0.dist-info/RECORD,,
+six-1.16.0.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+six-1.16.0.dist-info/top_level.txt,sha256=_iVH_iYEtEXnD8nYGQYpYFUvkUW9sEO1GYbkeKSAais,4
+six.py,sha256=TOOfQi7nFGfMrIvtdr6wX4wyHH8M7aknmuLfo2cBBrM,34549
diff --git a/Lib/site-packages/six-1.16.0.dist-info/WHEEL b/Lib/site-packages/six-1.16.0.dist-info/WHEEL
new file mode 100644
index 0000000..01b8fc7
--- /dev/null
+++ b/Lib/site-packages/six-1.16.0.dist-info/WHEEL
@@ -0,0 +1,6 @@
+Wheel-Version: 1.0
+Generator: bdist_wheel (0.36.2)
+Root-Is-Purelib: true
+Tag: py2-none-any
+Tag: py3-none-any
+
diff --git a/Lib/site-packages/six-1.16.0.dist-info/top_level.txt b/Lib/site-packages/six-1.16.0.dist-info/top_level.txt
new file mode 100644
index 0000000..ffe2fce
--- /dev/null
+++ b/Lib/site-packages/six-1.16.0.dist-info/top_level.txt
@@ -0,0 +1 @@
+six
diff --git a/Lib/site-packages/six.py b/Lib/site-packages/six.py
new file mode 100644
index 0000000..4e15675
--- /dev/null
+++ b/Lib/site-packages/six.py
@@ -0,0 +1,998 @@
+# Copyright (c) 2010-2020 Benjamin Peterson
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+"""Utilities for writing code that runs on Python 2 and 3"""
+
+from __future__ import absolute_import
+
+import functools
+import itertools
+import operator
+import sys
+import types
+
+__author__ = "Benjamin Peterson <benjamin@python.org>"
+__version__ = "1.16.0"
+
+
+# Useful for very coarse version differentiation.
+PY2 = sys.version_info[0] == 2
+PY3 = sys.version_info[0] == 3
+PY34 = sys.version_info[0:2] >= (3, 4)
+
+if PY3:
+    string_types = str,
+    integer_types = int,
+    class_types = type,
+    text_type = str
+    binary_type = bytes
+
+    MAXSIZE = sys.maxsize
+else:
+    string_types = basestring,
+    integer_types = (int, long)
+    class_types = (type, types.ClassType)
+    text_type = unicode
+    binary_type = str
+
+    if sys.platform.startswith("java"):
+        # Jython always uses 32 bits.
+        MAXSIZE = int((1 << 31) - 1)
+    else:
+        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
+        class X(object):
+
+            def __len__(self):
+                return 1 << 31
+        try:
+            len(X())
+        except OverflowError:
+            # 32-bit
+            MAXSIZE = int((1 << 31) - 1)
+        else:
+            # 64-bit
+            MAXSIZE = int((1 << 63) - 1)
+        del X
+
+if PY34:
+    from importlib.util import spec_from_loader
+else:
+    spec_from_loader = None
+
+
+def _add_doc(func, doc):
+    """Add documentation to a function."""
+    func.__doc__ = doc
+
+
+def _import_module(name):
+    """Import module, returning the module after the last dot."""
+    __import__(name)
+    return sys.modules[name]
+
+
+class _LazyDescr(object):
+
+    def __init__(self, name):
+        self.name = name
+
+    def __get__(self, obj, tp):
+        result = self._resolve()
+        setattr(obj, self.name, result)  # Invokes __set__.
+        try:
+            # This is a bit ugly, but it avoids running this again by
+            # removing this descriptor.
+            delattr(obj.__class__, self.name)
+        except AttributeError:
+            pass
+        return result
+
+
+class MovedModule(_LazyDescr):
+
+    def __init__(self, name, old, new=None):
+        super(MovedModule, self).__init__(name)
+        if PY3:
+            if new is None:
+                new = name
+            self.mod = new
+        else:
+            self.mod = old
+
+    def _resolve(self):
+        return _import_module(self.mod)
+
+    def __getattr__(self, attr):
+        _module = self._resolve()
+        value = getattr(_module, attr)
+        setattr(self, attr, value)
+        return value
+
+
+class _LazyModule(types.ModuleType):
+
+    def __init__(self, name):
+        super(_LazyModule, self).__init__(name)
+        self.__doc__ = self.__class__.__doc__
+
+    def __dir__(self):
+        attrs = ["__doc__", "__name__"]
+        attrs += [attr.name for attr in self._moved_attributes]
+        return attrs
+
+    # Subclasses should override this
+    _moved_attributes = []
+
+
+class MovedAttribute(_LazyDescr):
+
+    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
+        super(MovedAttribute, self).__init__(name)
+        if PY3:
+            if new_mod is None:
+                new_mod = name
+            self.mod = new_mod
+            if new_attr is None:
+                if old_attr is None:
+                    new_attr = name
+                else:
+                    new_attr = old_attr
+            self.attr = new_attr
+        else:
+            self.mod = old_mod
+            if old_attr is None:
+                old_attr = name
+            self.attr = old_attr
+
+    def _resolve(self):
+        module = _import_module(self.mod)
+        return getattr(module, self.attr)
+
+
+class _SixMetaPathImporter(object):
+
+    """
+    A meta path importer to import six.moves and its submodules.
+
+    This class implements a PEP302 finder and loader. It should be compatible
+    with Python 2.5 and all existing versions of Python3
+    """
+
+    def __init__(self, six_module_name):
+        self.name = six_module_name
+        self.known_modules = {}
+
+    def _add_module(self, mod, *fullnames):
+        for fullname in fullnames:
+            self.known_modules[self.name + "." + fullname] = mod
+
+    def _get_module(self, fullname):
+        return self.known_modules[self.name + "." + fullname]
+
+    def find_module(self, fullname, path=None):
+        if fullname in self.known_modules:
+            return self
+        return None
+
+    def find_spec(self, fullname, path, target=None):
+        if fullname in self.known_modules:
+            return spec_from_loader(fullname, self)
+        return None
+
+    def __get_module(self, fullname):
+        try:
+            return self.known_modules[fullname]
+        except KeyError:
+            raise ImportError("This loader does not know module " + fullname)
+
+    def load_module(self, fullname):
+        try:
+            # in case of a reload
+            return sys.modules[fullname]
+        except KeyError:
+            pass
+        mod = self.__get_module(fullname)
+        if isinstance(mod, MovedModule):
+            mod = mod._resolve()
+        else:
+            mod.__loader__ = self
+        sys.modules[fullname] = mod
+        return mod
+
+    def is_package(self, fullname):
+        """
+        Return true, if the named module is a package.
+
+        We need this method to get correct spec objects with
+        Python 3.4 (see PEP451)
+        """
+        return hasattr(self.__get_module(fullname), "__path__")
+
+    def get_code(self, fullname):
+        """Return None
+
+        Required, if is_package is implemented"""
+        self.__get_module(fullname)  # eventually raises ImportError
+        return None
+    get_source = get_code  # same as get_code
+
+    def create_module(self, spec):
+        return self.load_module(spec.name)
+
+    def exec_module(self, module):
+        pass
+
+_importer = _SixMetaPathImporter(__name__)
+
+
+class _MovedItems(_LazyModule):
+
+    """Lazy loading of moved objects"""
+    __path__ = []  # mark as package
+
+
+_moved_attributes = [
+    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
+    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
+    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
+    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
+    MovedAttribute("intern", "__builtin__", "sys"),
+    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
+    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
+    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
+    MovedAttribute("getoutput", "commands", "subprocess"),
+    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
+    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
+    MovedAttribute("reduce", "__builtin__", "functools"),
+    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
+    MovedAttribute("StringIO", "StringIO", "io"),
+    MovedAttribute("UserDict", "UserDict", "collections"),
+    MovedAttribute("UserList", "UserList", "collections"),
+    MovedAttribute("UserString", "UserString", "collections"),
+    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
+    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
+    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
+    MovedModule("builtins", "__builtin__"),
+    MovedModule("configparser", "ConfigParser"),
+    MovedModule("collections_abc", "collections", "collections.abc" if sys.version_info >= (3, 3) else "collections"),
+    MovedModule("copyreg", "copy_reg"),
+    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
+    MovedModule("dbm_ndbm", "dbm", "dbm.ndbm"),
+    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread" if sys.version_info < (3, 9) else "_thread"),
+    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
+    MovedModule("http_cookies", "Cookie", "http.cookies"),
+    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
+    MovedModule("html_parser", "HTMLParser", "html.parser"),
+    MovedModule("http_client", "httplib", "http.client"),
+    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
+    MovedModule("email_mime_image", "email.MIMEImage", "email.mime.image"),
+    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
+    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
+    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
+    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
+    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
+    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
+    MovedModule("cPickle", "cPickle", "pickle"),
+    MovedModule("queue", "Queue"),
+    MovedModule("reprlib", "repr"),
+    MovedModule("socketserver", "SocketServer"),
+    MovedModule("_thread", "thread", "_thread"),
+    MovedModule("tkinter", "Tkinter"),
+    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
+    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
+    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
+    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
+    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
+    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
+    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
+    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
+    MovedModule("tkinter_colorchooser", "tkColorChooser",
+                "tkinter.colorchooser"),
+    MovedModule("tkinter_commondialog", "tkCommonDialog",
+                "tkinter.commondialog"),
+    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
+    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
+    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
+    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
+                "tkinter.simpledialog"),
+    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
+    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
+    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
+    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
+    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
+    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
+]
+# Add windows specific modules.
+if sys.platform == "win32":
+    _moved_attributes += [
+        MovedModule("winreg", "_winreg"),
+    ]
+
+for attr in _moved_attributes:
+    setattr(_MovedItems, attr.name, attr)
+    if isinstance(attr, MovedModule):
+        _importer._add_module(attr, "moves." + attr.name)
+del attr
+
+_MovedItems._moved_attributes = _moved_attributes
+
+moves = _MovedItems(__name__ + ".moves")
+_importer._add_module(moves, "moves")
+
+
+class Module_six_moves_urllib_parse(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_parse"""
+
+
+_urllib_parse_moved_attributes = [
+    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
+    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
+    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
+    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
+    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
+    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
+    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
+    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
+    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
+    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
+    MovedAttribute("quote", "urllib", "urllib.parse"),
+    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
+    MovedAttribute("unquote", "urllib", "urllib.parse"),
+    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
+    MovedAttribute("unquote_to_bytes", "urllib", "urllib.parse", "unquote", "unquote_to_bytes"),
+    MovedAttribute("urlencode", "urllib", "urllib.parse"),
+    MovedAttribute("splitquery", "urllib", "urllib.parse"),
+    MovedAttribute("splittag", "urllib", "urllib.parse"),
+    MovedAttribute("splituser", "urllib", "urllib.parse"),
+    MovedAttribute("splitvalue", "urllib", "urllib.parse"),
+    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_params", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_query", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
+]
+for attr in _urllib_parse_moved_attributes:
+    setattr(Module_six_moves_urllib_parse, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
+                      "moves.urllib_parse", "moves.urllib.parse")
+
+
+class Module_six_moves_urllib_error(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_error"""
+
+
+_urllib_error_moved_attributes = [
+    MovedAttribute("URLError", "urllib2", "urllib.error"),
+    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
+    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
+]
+for attr in _urllib_error_moved_attributes:
+    setattr(Module_six_moves_urllib_error, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
+                      "moves.urllib_error", "moves.urllib.error")
+
+
+class Module_six_moves_urllib_request(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_request"""
+
+
+_urllib_request_moved_attributes = [
+    MovedAttribute("urlopen", "urllib2", "urllib.request"),
+    MovedAttribute("install_opener", "urllib2", "urllib.request"),
+    MovedAttribute("build_opener", "urllib2", "urllib.request"),
+    MovedAttribute("pathname2url", "urllib", "urllib.request"),
+    MovedAttribute("url2pathname", "urllib", "urllib.request"),
+    MovedAttribute("getproxies", "urllib", "urllib.request"),
+    MovedAttribute("Request", "urllib2", "urllib.request"),
+    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
+    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
+    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
+    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
+    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
+    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
+    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
+    MovedAttribute("URLopener", "urllib", "urllib.request"),
+    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
+    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
+    MovedAttribute("parse_http_list", "urllib2", "urllib.request"),
+    MovedAttribute("parse_keqv_list", "urllib2", "urllib.request"),
+]
+for attr in _urllib_request_moved_attributes:
+    setattr(Module_six_moves_urllib_request, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
+                      "moves.urllib_request", "moves.urllib.request")
+
+
+class Module_six_moves_urllib_response(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_response"""
+
+
+_urllib_response_moved_attributes = [
+    MovedAttribute("addbase", "urllib", "urllib.response"),
+    MovedAttribute("addclosehook", "urllib", "urllib.response"),
+    MovedAttribute("addinfo", "urllib", "urllib.response"),
+    MovedAttribute("addinfourl", "urllib", "urllib.response"),
+]
+for attr in _urllib_response_moved_attributes:
+    setattr(Module_six_moves_urllib_response, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
+                      "moves.urllib_response", "moves.urllib.response")
+
+
+class Module_six_moves_urllib_robotparser(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_robotparser"""
+
+
+_urllib_robotparser_moved_attributes = [
+    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
+]
+for attr in _urllib_robotparser_moved_attributes:
+    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
+                      "moves.urllib_robotparser", "moves.urllib.robotparser")
+
+
+class Module_six_moves_urllib(types.ModuleType):
+
+    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
+    __path__ = []  # mark as package
+    parse = _importer._get_module("moves.urllib_parse")
+    error = _importer._get_module("moves.urllib_error")
+    request = _importer._get_module("moves.urllib_request")
+    response = _importer._get_module("moves.urllib_response")
+    robotparser = _importer._get_module("moves.urllib_robotparser")
+
+    def __dir__(self):
+        return ['parse', 'error', 'request', 'response', 'robotparser']
+
+_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
+                      "moves.urllib")
+
+
+def add_move(move):
+    """Add an item to six.moves."""
+    setattr(_MovedItems, move.name, move)
+
+
+def remove_move(name):
+    """Remove item from six.moves."""
+    try:
+        delattr(_MovedItems, name)
+    except AttributeError:
+        try:
+            del moves.__dict__[name]
+        except KeyError:
+            raise AttributeError("no such move, %r" % (name,))
+
+
+if PY3:
+    _meth_func = "__func__"
+    _meth_self = "__self__"
+
+    _func_closure = "__closure__"
+    _func_code = "__code__"
+    _func_defaults = "__defaults__"
+    _func_globals = "__globals__"
+else:
+    _meth_func = "im_func"
+    _meth_self = "im_self"
+
+    _func_closure = "func_closure"
+    _func_code = "func_code"
+    _func_defaults = "func_defaults"
+    _func_globals = "func_globals"
+
+
+try:
+    advance_iterator = next
+except NameError:
+    def advance_iterator(it):
+        return it.next()
+next = advance_iterator
+
+
+try:
+    callable = callable
+except NameError:
+    def callable(obj):
+        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)
+
+
+if PY3:
+    def get_unbound_function(unbound):
+        return unbound
+
+    create_bound_method = types.MethodType
+
+    def create_unbound_method(func, cls):
+        return func
+
+    Iterator = object
+else:
+    def get_unbound_function(unbound):
+        return unbound.im_func
+
+    def create_bound_method(func, obj):
+        return types.MethodType(func, obj, obj.__class__)
+
+    def create_unbound_method(func, cls):
+        return types.MethodType(func, None, cls)
+
+    class Iterator(object):
+
+        def next(self):
+            return type(self).__next__(self)
+
+    callable = callable
+_add_doc(get_unbound_function,
+         """Get the function out of a possibly unbound function""")
+
+
+get_method_function = operator.attrgetter(_meth_func)
+get_method_self = operator.attrgetter(_meth_self)
+get_function_closure = operator.attrgetter(_func_closure)
+get_function_code = operator.attrgetter(_func_code)
+get_function_defaults = operator.attrgetter(_func_defaults)
+get_function_globals = operator.attrgetter(_func_globals)
+
+
+if PY3:
+    def iterkeys(d, **kw):
+        return iter(d.keys(**kw))
+
+    def itervalues(d, **kw):
+        return iter(d.values(**kw))
+
+    def iteritems(d, **kw):
+        return iter(d.items(**kw))
+
+    def iterlists(d, **kw):
+        return iter(d.lists(**kw))
+
+    viewkeys = operator.methodcaller("keys")
+
+    viewvalues = operator.methodcaller("values")
+
+    viewitems = operator.methodcaller("items")
+else:
+    def iterkeys(d, **kw):
+        return d.iterkeys(**kw)
+
+    def itervalues(d, **kw):
+        return d.itervalues(**kw)
+
+    def iteritems(d, **kw):
+        return d.iteritems(**kw)
+
+    def iterlists(d, **kw):
+        return d.iterlists(**kw)
+
+    viewkeys = operator.methodcaller("viewkeys")
+
+    viewvalues = operator.methodcaller("viewvalues")
+
+    viewitems = operator.methodcaller("viewitems")
+
+_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
+_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
+_add_doc(iteritems,
+         "Return an iterator over the (key, value) pairs of a dictionary.")
+_add_doc(iterlists,
+         "Return an iterator over the (key, [values]) pairs of a dictionary.")
+
+
+if PY3:
+    def b(s):
+        return s.encode("latin-1")
+
+    def u(s):
+        return s
+    unichr = chr
+    import struct
+    int2byte = struct.Struct(">B").pack
+    del struct
+    byte2int = operator.itemgetter(0)
+    indexbytes = operator.getitem
+    iterbytes = iter
+    import io
+    StringIO = io.StringIO
+    BytesIO = io.BytesIO
+    del io
+    _assertCountEqual = "assertCountEqual"
+    if sys.version_info[1] <= 1:
+        _assertRaisesRegex = "assertRaisesRegexp"
+        _assertRegex = "assertRegexpMatches"
+        _assertNotRegex = "assertNotRegexpMatches"
+    else:
+        _assertRaisesRegex = "assertRaisesRegex"
+        _assertRegex = "assertRegex"
+        _assertNotRegex = "assertNotRegex"
+else:
+    def b(s):
+        return s
+    # Workaround for standalone backslash
+
+    def u(s):
+        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
+    unichr = unichr
+    int2byte = chr
+
+    def byte2int(bs):
+        return ord(bs[0])
+
+    def indexbytes(buf, i):
+        return ord(buf[i])
+    iterbytes = functools.partial(itertools.imap, ord)
+    import StringIO
+    StringIO = BytesIO = StringIO.StringIO
+    _assertCountEqual = "assertItemsEqual"
+    _assertRaisesRegex = "assertRaisesRegexp"
+    _assertRegex = "assertRegexpMatches"
+    _assertNotRegex = "assertNotRegexpMatches"
+_add_doc(b, """Byte literal""")
+_add_doc(u, """Text literal""")
+
+
+def assertCountEqual(self, *args, **kwargs):
+    return getattr(self, _assertCountEqual)(*args, **kwargs)
+
+
+def assertRaisesRegex(self, *args, **kwargs):
+    return getattr(self, _assertRaisesRegex)(*args, **kwargs)
+
+
+def assertRegex(self, *args, **kwargs):
+    return getattr(self, _assertRegex)(*args, **kwargs)
+
+
+def assertNotRegex(self, *args, **kwargs):
+    return getattr(self, _assertNotRegex)(*args, **kwargs)
+
+
+if PY3:
+    exec_ = getattr(moves.builtins, "exec")
+
+    def reraise(tp, value, tb=None):
+        try:
+            if value is None:
+                value = tp()
+            if value.__traceback__ is not tb:
+                raise value.with_traceback(tb)
+            raise value
+        finally:
+            value = None
+            tb = None
+
+else:
+    def exec_(_code_, _globs_=None, _locs_=None):
+        """Execute code in a namespace."""
+        if _globs_ is None:
+            frame = sys._getframe(1)
+            _globs_ = frame.f_globals
+            if _locs_ is None:
+                _locs_ = frame.f_locals
+            del frame
+        elif _locs_ is None:
+            _locs_ = _globs_
+        exec("""exec _code_ in _globs_, _locs_""")
+
+    exec_("""def reraise(tp, value, tb=None):
+    try:
+        raise tp, value, tb
+    finally:
+        tb = None
+""")
+
+
+if sys.version_info[:2] > (3,):
+    exec_("""def raise_from(value, from_value):
+    try:
+        raise value from from_value
+    finally:
+        value = None
+""")
+else:
+    def raise_from(value, from_value):
+        raise value
+
+
+print_ = getattr(moves.builtins, "print", None)
+if print_ is None:
+    def print_(*args, **kwargs):
+        """The new-style print function for Python 2.4 and 2.5."""
+        fp = kwargs.pop("file", sys.stdout)
+        if fp is None:
+            return
+
+        def write(data):
+            if not isinstance(data, basestring):
+                data = str(data)
+            # If the file has an encoding, encode unicode with it.
+            if (isinstance(fp, file) and
+                    isinstance(data, unicode) and
+                    fp.encoding is not None):
+                errors = getattr(fp, "errors", None)
+                if errors is None:
+                    errors = "strict"
+                data = data.encode(fp.encoding, errors)
+            fp.write(data)
+        want_unicode = False
+        sep = kwargs.pop("sep", None)
+        if sep is not None:
+            if isinstance(sep, unicode):
+                want_unicode = True
+            elif not isinstance(sep, str):
+                raise TypeError("sep must be None or a string")
+        end = kwargs.pop("end", None)
+        if end is not None:
+            if isinstance(end, unicode):
+                want_unicode = True
+            elif not isinstance(end, str):
+                raise TypeError("end must be None or a string")
+        if kwargs:
+            raise TypeError("invalid keyword arguments to print()")
+        if not want_unicode:
+            for arg in args:
+                if isinstance(arg, unicode):
+                    want_unicode = True
+                    break
+        if want_unicode:
+            newline = unicode("\n")
+            space = unicode(" ")
+        else:
+            newline = "\n"
+            space = " "
+        if sep is None:
+            sep = space
+        if end is None:
+            end = newline
+        for i, arg in enumerate(args):
+            if i:
+                write(sep)
+            write(arg)
+        write(end)
+if sys.version_info[:2] < (3, 3):
+    _print = print_
+
+    def print_(*args, **kwargs):
+        fp = kwargs.get("file", sys.stdout)
+        flush = kwargs.pop("flush", False)
+        _print(*args, **kwargs)
+        if flush and fp is not None:
+            fp.flush()
+
+_add_doc(reraise, """Reraise an exception.""")
+
+if sys.version_info[0:2] < (3, 4):
+    # This does exactly the same what the :func:`py3:functools.update_wrapper`
+    # function does on Python versions after 3.2. It sets the ``__wrapped__``
+    # attribute on ``wrapper`` object and it doesn't raise an error if any of
+    # the attributes mentioned in ``assigned`` and ``updated`` are missing on
+    # ``wrapped`` object.
+    def _update_wrapper(wrapper, wrapped,
+                        assigned=functools.WRAPPER_ASSIGNMENTS,
+                        updated=functools.WRAPPER_UPDATES):
+        for attr in assigned:
+            try:
+                value = getattr(wrapped, attr)
+            except AttributeError:
+                continue
+            else:
+                setattr(wrapper, attr, value)
+        for attr in updated:
+            getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
+        wrapper.__wrapped__ = wrapped
+        return wrapper
+    _update_wrapper.__doc__ = functools.update_wrapper.__doc__
+
+    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
+              updated=functools.WRAPPER_UPDATES):
+        return functools.partial(_update_wrapper, wrapped=wrapped,
+                                 assigned=assigned, updated=updated)
+    wraps.__doc__ = functools.wraps.__doc__
+
+else:
+    wraps = functools.wraps
+
+
+def with_metaclass(meta, *bases):
+    """Create a base class with a metaclass."""
+    # This requires a bit of explanation: the basic idea is to make a dummy
+    # metaclass for one level of class instantiation that replaces itself with
+    # the actual metaclass.
+    class metaclass(type):
+
+        def __new__(cls, name, this_bases, d):
+            if sys.version_info[:2] >= (3, 7):
+                # This version introduced PEP 560 that requires a bit
+                # of extra care (we mimic what is done by __build_class__).
+                resolved_bases = types.resolve_bases(bases)
+                if resolved_bases is not bases:
+                    d['__orig_bases__'] = bases
+            else:
+                resolved_bases = bases
+            return meta(name, resolved_bases, d)
+
+        @classmethod
+        def __prepare__(cls, name, this_bases):
+            return meta.__prepare__(name, bases)
+    return type.__new__(metaclass, 'temporary_class', (), {})
+
+
+def add_metaclass(metaclass):
+    """Class decorator for creating a class with a metaclass."""
+    def wrapper(cls):
+        orig_vars = cls.__dict__.copy()
+        slots = orig_vars.get('__slots__')
+        if slots is not None:
+            if isinstance(slots, str):
+                slots = [slots]
+            for slots_var in slots:
+                orig_vars.pop(slots_var)
+        orig_vars.pop('__dict__', None)
+        orig_vars.pop('__weakref__', None)
+        if hasattr(cls, '__qualname__'):
+            orig_vars['__qualname__'] = cls.__qualname__
+        return metaclass(cls.__name__, cls.__bases__, orig_vars)
+    return wrapper
+
+
+def ensure_binary(s, encoding='utf-8', errors='strict'):
+    """Coerce **s** to six.binary_type.
+
+    For Python 2:
+      - `unicode` -> encoded to `str`
+      - `str` -> `str`
+
+    For Python 3:
+      - `str` -> encoded to `bytes`
+      - `bytes` -> `bytes`
+    """
+    if isinstance(s, binary_type):
+        return s
+    if isinstance(s, text_type):
+        return s.encode(encoding, errors)
+    raise TypeError("not expecting type '%s'" % type(s))
+
+
+def ensure_str(s, encoding='utf-8', errors='strict'):
+    """Coerce *s* to `str`.
+
+    For Python 2:
+      - `unicode` -> encoded to `str`
+      - `str` -> `str`
+
+    For Python 3:
+      - `str` -> `str`
+      - `bytes` -> decoded to `str`
+    """
+    # Optimization: Fast return for the common case.
+    if type(s) is str:
+        return s
+    if PY2 and isinstance(s, text_type):
+        return s.encode(encoding, errors)
+    elif PY3 and isinstance(s, binary_type):
+        return s.decode(encoding, errors)
+    elif not isinstance(s, (text_type, binary_type)):
+        raise TypeError("not expecting type '%s'" % type(s))
+    return s
+
+
+def ensure_text(s, encoding='utf-8', errors='strict'):
+    """Coerce *s* to six.text_type.
+
+    For Python 2:
+      - `unicode` -> `unicode`
+      - `str` -> `unicode`
+
+    For Python 3:
+      - `str` -> `str`
+      - `bytes` -> decoded to `str`
+    """
+    if isinstance(s, binary_type):
+        return s.decode(encoding, errors)
+    elif isinstance(s, text_type):
+        return s
+    else:
+        raise TypeError("not expecting type '%s'" % type(s))
+
+
+def python_2_unicode_compatible(klass):
+    """
+    A class decorator that defines __unicode__ and __str__ methods under Python 2.
+    Under Python 3 it does nothing.
+
+    To support Python 2 and 3 with a single code base, define a __str__ method
+    returning text and apply this decorator to the class.
+    """
+    if PY2:
+        if '__str__' not in klass.__dict__:
+            raise ValueError("@python_2_unicode_compatible cannot be applied "
+                             "to %s because it doesn't define __str__()." %
+                             klass.__name__)
+        klass.__unicode__ = klass.__str__
+        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
+    return klass
+
+
+# Complete the moves implementation.
+# This code is at the end of this module to speed up module loading.
+# Turn this module into a package.
+__path__ = []  # required for PEP 302 and PEP 451
+__package__ = __name__  # see PEP 366 @ReservedAssignment
+if globals().get("__spec__") is not None:
+    __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
+# Remove other six meta path importers, since they cause problems. This can
+# happen if six is removed from sys.modules and then reloaded. (Setuptools does
+# this for some reason.)
+if sys.meta_path:
+    for i, importer in enumerate(sys.meta_path):
+        # Here's some real nastiness: Another "instance" of the six module might
+        # be floating around. Therefore, we can't use isinstance() to check for
+        # the six meta path importer, since the other six instance will have
+        # inserted an importer with different class.
+        if (type(importer).__name__ == "_SixMetaPathImporter" and
+                importer.name == __name__):
+            del sys.meta_path[i]
+            break
+    del i, importer
+# Finally, add the importer to the meta path import hook.
+sys.meta_path.append(_importer)
diff --git a/src/DataManipulator.ts b/src/DataManipulator.ts
index 7f62295..f05c144 100644
--- a/src/DataManipulator.ts
+++ b/src/DataManipulator.ts
@@ -1,20 +1,32 @@
 import { ServerRespond } from './DataStreamer';
 
 export interface Row {
-  stock: string,
-  top_ask_price: number,
+  price_abc: number,
+  price_def: number,
+  ratio: number,
   timestamp: Date,
+  upper_bound: number,
+  lower_bound: number,
+  trigger_alert: number | undefined,
 }
 
 
 export class DataManipulator {
-  static generateRow(serverResponds: ServerRespond[]) {
-    return serverResponds.map((el: any) => {
-      return {
-        stock: el.stock,
-        top_ask_price: el.top_ask && el.top_ask.price || 0,
-        timestamp: el.timestamp,
-      };
-    })
+  static generateRow(serverRespond: ServerRespond[]): Row {
+    const priceABC = (serverRespond[0].top_ask.price + serverRespond[0].top_bid.price) /2;
+    const priceDEF = (serverRespond[1].top_ask.price + serverRespond[1].top_bid.price) /2;
+    const ratio = priceABC / priceDEF;
+    const upperBound = 1 + 0.05; /** tried changing from original 5% to 10% */
+    const lowerBound = 1 - 0.05;
+    return {
+      price_abc: priceABC,
+      price_def: priceDEF,
+      ratio,
+      timestamp: serverRespond[0].timestamp > serverRespond[1].timestamp ?
+        serverRespond[0].timestamp : serverRespond[1].timestamp,
+      upper_bound: upperBound,
+      lower_bound: lowerBound,
+      trigger_alert: (ratio > upperBound || ratio < lowerBound) ? ratio : undefined,
+    };
   }
 }
diff --git a/src/Graph.tsx b/src/Graph.tsx
index 277797d..a450a6f 100644
--- a/src/Graph.tsx
+++ b/src/Graph.tsx
@@ -1,5 +1,5 @@
 import React, { Component } from 'react';
-import { Table } from '@finos/perspective';
+import { Table, TableData } from '@finos/perspective';
 import { ServerRespond } from './DataStreamer';
 import { DataManipulator } from './DataManipulator';
 import './Graph.css';
@@ -23,10 +23,13 @@ class Graph extends Component<IProps, {}> {
     const elem = document.getElementsByTagName('perspective-viewer')[0] as unknown as PerspectiveViewerElement;
 
     const schema = {
-      stock: 'string',
-      top_ask_price: 'float',
-      top_bid_price: 'float',
-      timestamp: 'date',
+      price_abc: "float",
+      price_def: "float",
+      ratio: "float",
+      timestamp: "date",
+      upper_bound: "float",
+      lower_bound: "float",
+      trigger_alert: "float",
     };
 
     if (window.perspective && window.perspective.worker()) {
@@ -36,23 +39,25 @@ class Graph extends Component<IProps, {}> {
       // Load the `table` in the `<perspective-viewer>` DOM reference.
       elem.load(this.table);
       elem.setAttribute('view', 'y_line');
-      elem.setAttribute('column-pivots', '["stock"]');
       elem.setAttribute('row-pivots', '["timestamp"]');
-      elem.setAttribute('columns', '["top_ask_price"]');
+      elem.setAttribute('columns', '["ratio", "lower_bound", "upper_bound", "trigger_alert"]');
       elem.setAttribute('aggregates', JSON.stringify({
-        stock: 'distinctcount',
-        top_ask_price: 'avg',
-        top_bid_price: 'avg',
+        price_abc: "avg",
+        price_def: "avg",
+        ratio: "avg",
         timestamp: 'distinct count',
+        upper_bound: "avg",
+        lower_bound: "avg",
+        trigger_alert: "avg",
       }));
     }
   }
 
   componentDidUpdate() {
     if (this.table) {
-      this.table.update(
+      this.table.update([
         DataManipulator.generateRow(this.props.data),
-      );
+      ] as unknown as TableData);
     }
   }
 }
-- 
2.45.2.windows.1

